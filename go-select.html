<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="true">
  <meta name="msvalidate.01" content="true">
  <meta name="baidu-site-verification" content="true">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jiankunking.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":320,"display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Go Select">
<meta name="keywords" content="转载,Go,Select">
<meta property="og:type" content="article">
<meta property="og:title" content="[转]Go Select 实现分析">
<meta property="og:url" content="https://jiankunking.com/go-select.html">
<meta property="og:site_name" content="衣舞晨风">
<meta property="og:description" content="Go Select">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2021-04-23T06:31:40.224Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[转]Go Select 实现分析">
<meta name="twitter:description" content="Go Select">

<link rel="canonical" href="https://jiankunking.com/go-select.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>[转]Go Select 实现分析 | 衣舞晨风</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-121070942-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-121070942-1');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?3a234fd6ba55e88f18fe2d8e55dd52c5";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="衣舞晨风" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">衣舞晨风</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">164</span></a>

  </li>
        <li class="menu-item menu-item-书籍">

    <a href="/books/" rel="section"><i class="fa fa-th fa-fw"></i>书籍</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">242</span></a>

  </li>
        <li class="menu-item menu-item-友链">

    <a href="/links/" rel="section"><i class="fa fa-external-link-alt fa-fw"></i>友链</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/jiankunking" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiankunking.com/go-select.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar/avatar.png">
      <meta itemprop="name" content="jiankunking">
      <meta itemprop="description" content="如果你来访我，我不在，请和我门外的花坐一会儿，它们很温暖，我注视他们很多很多日子了。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="衣舞晨风">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          [转]Go Select 实现分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-13 12:40:52" itemprop="dateCreated datePublished" datetime="2020-06-13T12:40:52+08:00">2020-06-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-23 14:31:40" itemprop="dateModified" datetime="2021-04-23T14:31:40+08:00">2021-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>Go Select</p>
</blockquote>
<a id="more"></a>

<p>很多 C 语言或者 Unix 开发者听到 <code>select</code> 想到的都是系统调用，而谈到 I&#x2F;O 模型时最终大都会提到基于 <code>select</code>、<code>poll</code> 和 <code>epoll</code> 等函数构建的 IO 多路复用模型。Go 语言的 <code>select</code> 与 C 语言中的 <code>select</code> 有着比较相似的功能。本节会介绍 Go 语言 <code>select</code> 常见的现象、数据结构以及四种不同情况下的实现原理。</p>
<p><font color="DeepPink"><strong>C 语言中的 <code>select</code> 关键字可以同时监听多个文件描述符的可读或者可写的状态，Go 语言中的 <code>select</code> 关键字也能够让 Goroutine 同时等待多个 Channel 的可读或者可写，在多个文件或者 Channel 发生状态改变之前，<code>select</code> 会一直阻塞当前线程或者 Goroutine。</strong></font></p>
<p><img data-src="/images/go-select/Golang-Select-Channels.png"></p>
<p><code>select</code> 是一种与 <code>switch</code> 相似的控制结构，与 <code>switch</code> 不同的是，<code>select</code> 中虽然也有多个 <code>case</code>，但是这些 <code>case</code> 中的表达式必须都是 Channel 的收发操作。下面的代码就展示了一个包含 Channel 收发操作的 <code>select</code> 结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func fibonacci(c, quit chan int) &#123;</span><br><span class="line">	x, y := 0, 1</span><br><span class="line">	for &#123;</span><br><span class="line">		select &#123;</span><br><span class="line">		case c &lt;- x:</span><br><span class="line">			x, y = y, x+y</span><br><span class="line">		case &lt;-quit:</span><br><span class="line">			fmt.Println(&quot;quit&quot;)</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述控制结构会等待 <code>c &lt;- x</code> 或者 <code>&lt;-quit</code> 两个表达式中任意一个的返回。无论哪一个表达式返回都会立刻执行 <code>case</code> 中的代码，当 <code>select</code> 中的两个 <code>case</code> 同时被触发时，就会随机选择一个 <code>case</code> 执行。</p>
<h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>当我们在 Go 语言中使用 <code>select</code> 控制结构时，会遇到两个有趣的现象：</p>
<ul>
<li><code>select</code> 能在 Channel 上进行非阻塞的收发操作；</li>
<li><code>select</code> 在遇到多个 Channel 同时响应时会随机挑选 <code>case</code> 执行；</li>
</ul>
<p>这两个现象是学习 <code>select</code> 时经常会遇到的，我们来深入了解具体的场景并分析这两个现象背后的设计原理。</p>
<h2 id="非阻塞的收发"><a href="#非阻塞的收发" class="headerlink" title="非阻塞的收发"></a>非阻塞的收发</h2><p>在通常情况下，<code>select</code> 语句会阻塞当前 Goroutine 并等待多个 Channel 中的一个达到可以收发的状态。但是如果 <code>select</code> 控制结构中包含 default 语句，那么这个 <code>select</code> 语句在执行时会遇到以下两种情况：</p>
<ul>
<li>当存在可以收发的 Channel 时，直接处理该 Channel 对应的 <code>case</code></li>
<li>当不存在可以收发的 Channel 是，执行 <code>default</code> 中的语句；</li>
</ul>
<p>当我们运行下面的代码时就不会阻塞当前的 Goroutine，它会直接执行 <code>default</code> 中的代码并返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	ch := make(chan int)</span><br><span class="line">	select &#123;</span><br><span class="line">	case i := &lt;-ch:</span><br><span class="line">		println(i)</span><br><span class="line"></span><br><span class="line">	default:</span><br><span class="line">		println(&quot;default&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ go run main.go</span><br><span class="line">default</span><br></pre></td></tr></table></figure>

<p>只要我们稍微想一下，就会发现 Go 语言设计的这个现象就非常合理。<code>select</code> 的作用就是同时监听多个 <code>case</code> 是否可以执行，如果多个 Channel 都不能执行，那么运行 <code>default</code> 中的代码也是理所当然的。</p>
<p>非阻塞的 Channel 发送和接收操作还是很有必要的，在很多场景下我们不希望向 Channel 发送消息或者从 Channel 中接收消息会阻塞当前 Goroutine，我们只是想看看 Channel 的可读或者可写状态。下面就是一个常见的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">errCh := make(chan error, len(tasks))</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(len(tasks))</span><br><span class="line">for i := range tasks &#123;</span><br><span class="line">    go func() &#123;</span><br><span class="line">        defer wg.Done()</span><br><span class="line">        if err := tasks[i].Run(); err != nil &#123;</span><br><span class="line">            errCh &lt;- err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line">select &#123;</span><br><span class="line">case err := &lt;-errCh:</span><br><span class="line">    return err</span><br><span class="line">default:</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面这段代码中，我们不关心到底多少个任务执行失败了，只关心是否存在返回错误的任务，最后的 <code>select</code> 语句就能很好地完成这个任务。然而使用 <code>select</code> 的语法不是最原始的设计，它在最初版本使用 <code>x, ok := &lt;-c</code> 的语法实现非阻塞的收发，以下是与非阻塞收发的相关提交：</p>
<ul>
<li><a href="https://github.com/golang/go/commit/79fbbe37a76502e6f5f9647d2d82bab953ab1546#diff-fb0a5ae9dd70f0a43038d55c0204fdff" target="_blank" rel="noopener">select default</a> 提交支持了 <code>select</code> 语句中的 <code>default</code> 情况<a href="#fnref:1"><sup>1</sup></a>；</li>
<li><a href="https://github.com/golang/go/commit/5038792837355abde32f2e9549ef132fc5ffbd16" target="_blank" rel="noopener">gc: special case code for single-op blocking and non-blocking selects</a> 提交引入了基于 <code>select</code> 的非阻塞收发的特性<a href="#fnref:2"><sup>2</sup></a>。</li>
<li><a href="https://github.com/golang/go/commit/cb584707af2d8803adba88fd9692e665ecd2f059" target="_blank" rel="noopener">gc: remove non-blocking send, receive syntax</a> 提交将 <code>x, ok := &lt;-c</code> 语法删除删除<a href="#fnref:3"><sup>3</sup></a>；</li>
<li><a href="https://github.com/golang/go/commit/8bf34e335686816f7fe7e28614b2c7a3e04e9e7c" target="_blank" rel="noopener">gc, runtime: replace closed(c) with x, ok :&#x3D; &lt;-c</a> 提交使用 <code>x, ok := &lt;-c</code> 语法替代 <code>closed(c)</code> 语法判断 Channel 的关闭状态<a href="#fnref:4"><sup>4</sup></a>；</li>
</ul>
<p>我们可以从上面的几个提交中看到非阻塞收发从最初到现在的演变。</p>
<h2 id="随机执行"><a href="#随机执行" class="headerlink" title="随机执行"></a>随机执行</h2><p>另一个使用 <code>select</code> 遇到的情况是同时有多个 <code>case</code> 就绪时，<code>select</code> 会选择那个 <code>case</code> 执行的问题，我们通过下面的代码可以简单了解一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	ch := make(chan int)</span><br><span class="line">	go func() &#123;</span><br><span class="line">		for range time.Tick(1 * time.Second) &#123;</span><br><span class="line">			ch &lt;- 0</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	for &#123;</span><br><span class="line">		select &#123;</span><br><span class="line">		case &lt;-ch:</span><br><span class="line">			println(&quot;case1&quot;)</span><br><span class="line">		case &lt;-ch:</span><br><span class="line">			println(&quot;case2&quot;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ go run main.go</span><br><span class="line">case1</span><br><span class="line">case2</span><br><span class="line">case1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>从上述代码输出的结果中我们可以看到，<code>select</code> 在遇到多个 <code>&lt;-ch</code> 同时满足可读或者可写条件时会随机选择一个 <code>case</code> 执行其中的代码。</p>
<p>这个设计是在十多年前被 <a href="https://github.com/golang/go/commit/cb9b1038db77198c2b0961634cf161258af2374d" target="_blank" rel="noopener">select</a> 提交<a href="#fnref:5"><sup>5</sup></a>引入并一直保留到现在的，虽然中间经历过一些修改<a href="#fnref:6"><sup>6</sup></a>，但是语义一直都没有改变。在上面的代码中，两个 <code>case</code> 都是同时满足执行条件的，如果我们按照顺序依次判断，那么后面的条件永远都会得不到执行，而随机的引入就是为了避免饥饿问题的发生。</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p><code>select</code> 在 Go 语言的源代码中不存在对应的结构体，但是 <code>select</code> 控制结构中的 <code>case</code> 却使用 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L28-L34" target="_blank" rel="noopener">runtime.scase</a> 结构体来表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type scase struct &#123;</span><br><span class="line">	c           *hchan</span><br><span class="line">	elem        unsafe.Pointer</span><br><span class="line">	kind        uint16</span><br><span class="line">	pc          uintptr</span><br><span class="line">	releasetime int64</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为非默认的 <code>case</code> 中都与 Channel 的发送和接收有关，所以 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L28-L34" target="_blank" rel="noopener">runtime.scase</a> 结构体中也包含一个 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L32-L51" target="_blank" rel="noopener">runtime.hchan</a> 类型的字段存储 <code>case</code> 中使用的 Channel；除此之外，<code>elem</code> 是接收或者发送数据的变量地址、<code>kind</code> 表示 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L28-L34" target="_blank" rel="noopener">runtime.scase</a> 的种类，总共包含以下四种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">	caseNil = iota</span><br><span class="line">	caseRecv</span><br><span class="line">	caseSend</span><br><span class="line">	caseDefault</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这四种常量分别表示不同类型的 <code>case</code>，相信它们的命名已经能够充分帮助我们理解它们的作用了，所以这里也不一一介绍了。</p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p><code>select</code> 语句在编译期间会被转换成 <code>OSELECT</code> 节点。每一个 <code>OSELECT</code> 节点都会持有一组 <code>OCASE</code> 节点，如果 <code>OCASE</code> 的执行条件是空，那就意味着这是一个 <code>default</code> 节点:</p>
<p><img data-src="/images/go-select/golang-oselect-and-ocases.png"></p>
<p>上图展示的就是 <code>select</code> 语句在编译期间的结构，每一个 OCASE 既包含执行条件也包含满足条件后执行的代码。</p>
<p>编译器在中间代码生成期间会根据 <code>select</code> 中 <code>case</code> 的不同对控制语句进行优化，这一过程都发生在 <a href="https://github.com/golang/go/blob/c729116332ffb66a21dd587e3ee003cb8d0b16fe/src/cmd/compile/internal/gc/select.go#L108-L370" target="_blank" rel="noopener">cmd&#x2F;compile&#x2F;internal&#x2F;gc.walkselectcases</a> 函数中，我们在这里会分四种情况介绍处理的过程和结果：</p>
<ul>
<li><code>select</code> 不存在任何的 <code>case</code>；</li>
<li><code>select</code> 只存在一个 <code>case</code>；</li>
<li><code>select</code> 存在两个 <code>case</code>，其中一个 <code>case</code> 是 <code>default</code>；</li>
<li><code>select</code> 存在多个 <code>case</code>；</li>
</ul>
<p>上述的四种情况不仅会涉及编译器的重写和优化，还会涉及 Go 语言的运行时机制，我们会从编译期间和运行时两方面分析上述情况。</p>
<h2 id="直接阻塞"><a href="#直接阻塞" class="headerlink" title="直接阻塞"></a>直接阻塞</h2><p>首先介绍的是最简单的情况，也就是当 <code>select</code> 结构中不包含任何 <code>case</code> 时编译器是如何进行处理的，我们截取 <a href="https://github.com/golang/go/blob/c729116332ffb66a21dd587e3ee003cb8d0b16fe/src/cmd/compile/internal/gc/select.go#L108-L370" target="_blank" rel="noopener">cmd&#x2F;compile&#x2F;internal&#x2F;gc.walkselectcases</a> 函数的前几行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func walkselectcases(cases *Nodes) []*Node &#123;</span><br><span class="line">	n := cases.Len()</span><br><span class="line"></span><br><span class="line">	if n == 0 &#123;</span><br><span class="line">		return []*Node&#123;mkcall(&quot;block&quot;, nil, nil)&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码非常简单并且容易理解，它直接将类似 <code>select {}</code> 的空语句转换成调用 <a href="https://github.com/golang/go/blob/c112289ee4141ebc31db50328c355b01278b987b/src/runtime/select.go#L104-L106" target="_blank" rel="noopener">runtime.block</a> 函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func block() &#123;</span><br><span class="line">	gopark(nil, nil, waitReasonSelectNoCases, traceEvGoStop, 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/golang/go/blob/c112289ee4141ebc31db50328c355b01278b987b/src/runtime/select.go#L104-L106" target="_blank" rel="noopener">runtime.block</a> 函数的实现非常简单，它会调用 <a href="https://github.com/golang/go/blob/c112289ee4141ebc31db50328c355b01278b987b/src/runtime/proc.go#L287-L305" target="_blank" rel="noopener">runtime.gopark</a> 让出当前 Goroutine 对处理器的使用权，传入的等待原因是 <code>waitReasonSelectNoCases</code>。</p>
<p>简单总结一下，空的 <code>select</code> 语句会直接阻塞当前的 Goroutine，导致 Goroutine 进入无法被唤醒的永久休眠状态。</p>
<h2 id="单一管道"><a href="#单一管道" class="headerlink" title="单一管道"></a>单一管道</h2><p>如果当前的 <code>select</code> 条件只包含一个 <code>case</code>，那么就会将 <code>select</code> 改写成 <code>if</code> 条件语句。下面展示了原始的 <code>select</code> 语句和被改写、优化后的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 改写前</span><br><span class="line">select &#123;</span><br><span class="line">case v, ok &lt;-ch: // case ch &lt;- v</span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 改写后</span><br><span class="line">if ch == nil &#123;</span><br><span class="line">    block()</span><br><span class="line">&#125;</span><br><span class="line">v, ok := &lt;-ch // case ch &lt;- v</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/golang/go/blob/c729116332ffb66a21dd587e3ee003cb8d0b16fe/src/cmd/compile/internal/gc/select.go#L108-L370" target="_blank" rel="noopener">cmd&#x2F;compile&#x2F;internal&#x2F;gc.walkselectcases</a> 在处理单操作 <code>select</code> 语句时，会根据 Channel 的收发情况生成不同的语句。当 <code>case</code> 中的 Channel 是空指针时，就会直接挂起当前 Goroutine 并永久休眠。</p>
<h2 id="非阻塞操作"><a href="#非阻塞操作" class="headerlink" title="非阻塞操作"></a>非阻塞操作</h2><p>当 <code>select</code> 中仅包含两个 <code>case</code>，并且其中一个是 <code>default</code> 时，Go 语言的编译器就会认为这是一次非阻塞的收发操作。<a href="https://github.com/golang/go/blob/c729116332ffb66a21dd587e3ee003cb8d0b16fe/src/cmd/compile/internal/gc/select.go#L108-L370" target="_blank" rel="noopener">cmd&#x2F;compile&#x2F;internal&#x2F;gc.walkselectcases</a> 函数会对这种情况单独处理，不过在正式优化之前，该函数会将 <code>case</code> 中的所有 Channel 都转换成指向 Channel 的地址。我们会分别介绍非阻塞发送和非阻塞接收时，编译器进行的不同优化。</p>
<h3 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h3><p>首先是 Channel 的发送过程，当 <code>case</code> 中表达式的类型是 <code>OSEND</code> 时，编译器会使用 <code>if/else</code> 语句和 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L662-L664" target="_blank" rel="noopener">runtime.selectnbsend</a> 函数改写代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select &#123;</span><br><span class="line">case ch &lt;- i:</span><br><span class="line">    ...</span><br><span class="line">default:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if selectnbsend(ch, i) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中最重要的就是 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L662-L664" target="_blank" rel="noopener">runtime.selectnbsend</a> 函数，它为我们提供了向 Channel 非阻塞地发送数据的能力。我们在 Channel 一节介绍了向 Channel 发送数据的 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L157-L278" target="_blank" rel="noopener">runtime.chansend</a> 函数包含一个 <code>block</code> 参数，该参数会决定这一次的发送是不是阻塞的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func selectnbsend(c *hchan, elem unsafe.Pointer) (selected bool) &#123;</span><br><span class="line">	return chansend(c, elem, false, getcallerpc())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h3><p>由于从 Channel 中接收数据可能会返回一个或者两个值，所以接受数据的情况会比发送稍显复杂，不过改写的套路是差不多的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 改写前</span><br><span class="line">select &#123;</span><br><span class="line">case v &lt;- ch: // case v, ok &lt;- ch:</span><br><span class="line">    ......</span><br><span class="line">default:</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 改写后</span><br><span class="line">if selectnbrecv(&amp;v, ch) &#123; // if selectnbrecv2(&amp;v, &amp;ok, ch) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回值数量不同会导致使用函数的不同，两个用于非阻塞接收消息的函数 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L683-L686" target="_blank" rel="noopener">runtime.selectnbrecv</a> 和 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L705-L709" target="_blank" rel="noopener">runtime.selectnbrecv2</a> 只是对 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L448-L579" target="_blank" rel="noopener">runtime.chanrecv</a> 返回值的处理稍有不同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func selectnbrecv(elem unsafe.Pointer, c *hchan) (selected bool) &#123;</span><br><span class="line">	selected, _ = chanrecv(c, elem, false)</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func selectnbrecv2(elem unsafe.Pointer, received *bool, c *hchan) (selected bool) &#123;</span><br><span class="line">	selected, *received = chanrecv(c, elem, false)</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为接收方不需要，所以 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L683-L686" target="_blank" rel="noopener">runtime.selectnbrecv</a> 会直接忽略返回的布尔值，而 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L705-L709" target="_blank" rel="noopener">runtime.selectnbrecv2</a> 会将布尔值回传给调用方。与 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L157-L278" target="_blank" rel="noopener">runtime.chansend</a> 一样，<a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L448-L579" target="_blank" rel="noopener">runtime.chanrecv</a> 也提供了一个 block 参数用于控制这一次接收是否阻塞。</p>
<h3 id="常见流程"><a href="#常见流程" class="headerlink" title="常见流程"></a>常见流程</h3><p>在默认的情况下，编译器会使用如下的流程处理 <code>select</code> 语句：</p>
<ul>
<li>将所有的 <code>case</code> 转换成包含 Channel 以及类型等信息的 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L28-L34" target="_blank" rel="noopener">runtime.scase</a> 结构体；</li>
<li>调用运行时函数 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497" target="_blank" rel="noopener">runtime.selectgo</a> 从多个准备就绪的 Channel 中选择一个可执行的 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L28-L34" target="_blank" rel="noopener">runtime.scase</a> 结构体；</li>
<li>通过 <code>for</code> 循环生成一组 <code>if</code> 语句，在语句中判断自己是不是被选中的 <code>case</code></li>
</ul>
<p>一个包含三个 <code>case</code> 的正常 <code>select</code> 语句其实会被展开成如下所示的逻辑，我们可以看到其中处理的三个部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">selv := [3]scase&#123;&#125;</span><br><span class="line">order := [6]uint16</span><br><span class="line">for i, cas := range cases &#123;</span><br><span class="line">    c := scase&#123;&#125;</span><br><span class="line">    c.kind = ...</span><br><span class="line">    c.elem = ...</span><br><span class="line">    c.c = ...</span><br><span class="line">&#125;</span><br><span class="line">chosen, revcOK := selectgo(selv, order, 3)</span><br><span class="line">if chosen == 0 &#123;</span><br><span class="line">    ...</span><br><span class="line">    break</span><br><span class="line">&#125;</span><br><span class="line">if chosen == 1 &#123;</span><br><span class="line">    ...</span><br><span class="line">    break</span><br><span class="line">&#125;</span><br><span class="line">if chosen == 2 &#123;</span><br><span class="line">    ...</span><br><span class="line">    break</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>展开后的代码片段中最重要的就是用于选择待执行 <code>case</code> 的运行时函数 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497" target="_blank" rel="noopener">runtime.selectgo</a>，这也是我们要关注的重点。因为这个函数的实现比较复杂， 所以这里分两部分分析它的执行过程：</p>
<ul>
<li>执行一些必要的初始化操作并确定 <code>case</code> 的处理顺序；</li>
<li>在循环中根据 <code>case</code> 的类型做出不同的处理；</li>
</ul>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497" target="_blank" rel="noopener">runtime.selectgo</a> 函数首先会进行执行必要的初始化操作并决定处理 <code>case</code> 的两个顺序 — 轮询顺序 <code>pollOrder</code> 和加锁顺序 <code>lockOrder</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool) &#123;</span><br><span class="line">	cas1 := (*[1 &lt;&lt; 16]scase)(unsafe.Pointer(cas0))</span><br><span class="line">	order1 := (*[1 &lt;&lt; 17]uint16)(unsafe.Pointer(order0))</span><br><span class="line">	</span><br><span class="line">	scases := cas1[:ncases:ncases]</span><br><span class="line">	pollorder := order1[:ncases:ncases]</span><br><span class="line">	lockorder := order1[ncases:][:ncases:ncases]</span><br><span class="line">	for i := range scases &#123;</span><br><span class="line">		cas := &amp;scases[i]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for i := 1; i &lt; ncases; i++ &#123;</span><br><span class="line">		j := fastrandn(uint32(i + 1))</span><br><span class="line">		pollorder[i] = pollorder[j]</span><br><span class="line">		pollorder[j] = uint16(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 根据 Channel 的地址排序确定加锁顺序</span><br><span class="line">	...</span><br><span class="line">	sellock(scases, lockorder)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>轮询顺序 <code>pollOrder</code> 和加锁顺序 <code>lockOrder</code> 分别是通过以下的方式确认的：</p>
<ul>
<li>轮询顺序：通过 <a href="https://github.com/golang/go/blob/383b447e0da5bd1fcdc2439230b5a1d3e3402117/src/runtime/stubs.go#L114-L118" target="_blank" rel="noopener">runtime.fastrandn</a> 函数引入随机性；</li>
<li>加锁顺序：按照 Channel 的地址排序后确定加锁顺序；</li>
</ul>
<p>随机的轮询顺序可以避免 Channel 的饥饿问题，保证公平性；而根据 Channel 的地址顺序确定加锁顺序能够避免死锁的发生。这段代码最后调用的 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L45-L54" target="_blank" rel="noopener">runtime.sellock</a> 函数会按照之前生成的加锁顺序锁定 <code>select</code> 语句中包含所有的 Channel。</p>
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>当我们为 <code>select</code> 语句锁定了所有 Channel 之后就会进入 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497" target="_blank" rel="noopener">runtime.selectgo</a> 函数的主循环，它会分三个阶段查找或者等待某个 Channel 准备就绪：</p>
<p>查找是否已经存在准备就绪的 Channel，即可以执行收发操作；<br>将当前 Goroutine 加入 Channel 对应的收发队列上并等待其他 Goroutine 的唤醒；<br>当前 Goroutine 被唤醒之后找到满足条件的 Channel 并进行处理；<br><a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497" target="_blank" rel="noopener">runtime.selectgo</a>  函数会根据不同情况通过 <code>goto</code> 跳转到函数内部的不同标签执行相应的逻辑，其中包括：</p>
<ul>
<li><code>bufrecv</code>：可以从缓冲区读取数据；</li>
<li><code>bufsend</code>：可以向缓冲区写入数据；</li>
<li><code>recv</code>：可以从休眠的发送方获取数据；</li>
<li><code>send</code>：可以向休眠的接收方发送数据；</li>
<li><code>rclose</code>：可以从关闭的 Channel 读取 EOF；</li>
<li><code>sclose</code>：向关闭的 Channel 发送数据；</li>
<li><code>retc</code>：结束调用并返回；</li>
</ul>
<p>我们先来分析循环执行的第一个阶段，查找已经准备就绪的 Channel。循环会遍历所有的 <code>case</code> 并找到需要被唤起的 runtime.sudog 结构，在这个阶段，我们会根据 <code>case</code> 的四种类型分别处理：</p>
<ol>
<li><code>caseNil</code>：当前 <code>case</code> 不包含 Channel；<ul>
<li>这种 <code>case</code> 会被跳过；</li>
</ul>
</li>
<li><code>caseRecv</code>：当前 <code>case</code> 会从 Channel 中接收数据；<ul>
<li>如果当前 Channel 的 <code>sendq</code> 上有等待的 Goroutine，就会跳到 <code>recv</code> 标签从 Goroutine 中读取数据；</li>
<li>如果当前 Channel 的缓冲区不为空，就会跳到 <code>bufrecv</code> 标签处从缓冲区获取数据；</li>
<li>如果当前 Channel 已经被关闭，就会跳到 <code>rclose</code> 做一些清除的收尾工作；</li>
</ul>
</li>
<li><code>caseSend</code>：当前 <code>case</code> 会向 Channel 发送数据；<ul>
<li>如果当前 Channel 已经被关，闭就会直接跳到 <code>sclose</code> 标签，触发 <code>panic</code> 尝试中止程序；</li>
<li>如果当前 Channel 的 <code>recvq</code> 上有等待的 Goroutine，就会跳到 <code>send</code> 标签向 Channel 发送数据；</li>
<li>如果当前 Channel 的缓冲区存在空闲位置，就会将待发送的数据存入缓冲区；</li>
</ul>
</li>
<li><code>caseDefault</code>：当前 <code>case</code> 为 <code>default</code> 语句；<ul>
<li>表示前面的所有 <code>case</code> 都没有被执行，这里会解锁所有 Channel 并返回，意味着当前 <code>select</code> 结构中的收发都是非阻塞的；</li>
</ul>
</li>
</ol>
<p><img data-src="/images/go-select/golang-runtime-selectgo.png"></p>
<p>第一阶段的主要职责是查找所有 <code>case</code> 中 Channel 是否有可以立刻被处理的情况。无论是在包含等待的 Goroutine 还是缓冲区中存在数据，只要满足条件就会立刻处理，如果不能立刻找到活跃的 Channel 就会进入循环的下一阶段，按照需要将当前的 Goroutine 加入到 Channel 的 <code>sendq</code> 或者 <code>recvq</code> 队列中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool) &#123;</span><br><span class="line">	...</span><br><span class="line">	gp = getg()</span><br><span class="line">	nextp = &amp;gp.waiting</span><br><span class="line">	for _, casei := range lockorder &#123;</span><br><span class="line">		casi = int(casei)</span><br><span class="line">		cas = &amp;scases[casi]</span><br><span class="line">		c = cas.c</span><br><span class="line">		sg := acquireSudog()</span><br><span class="line">		sg.g = gp</span><br><span class="line">		sg.c = c</span><br><span class="line"></span><br><span class="line">		switch cas.kind &#123;</span><br><span class="line">		case caseRecv:</span><br><span class="line">			c.recvq.enqueue(sg)</span><br><span class="line">		case caseSend:</span><br><span class="line">			c.sendq.enqueue(sg)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gopark(selparkcommit, nil, waitReasonSelect, traceEvGoBlockSelect, 1)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了将当前 Goroutine 对应的 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L342-L368" target="_blank" rel="noopener">runtime.sudog</a> 结构体加入队列之外，这些 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L342-L368" target="_blank" rel="noopener">runtime.sudog</a> 结构体都会被串成链表附着在 Goroutine 上。在入队之后会调用 <a href="https://github.com/golang/go/blob/c112289ee4141ebc31db50328c355b01278b987b/src/runtime/proc.go#L287-L305" target="_blank" rel="noopener">runtime.gopark</a> 函数挂起当前 Goroutine 等待调度器的唤醒。</p>
<p><img data-src="/images/go-select/Golang-Select-Waiting.png"></p>
<p>等到 <code>select</code> 中的一些 Channel 准备就绪之后，当前 Goroutine 就会被调度器唤醒。这时会继续执行 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497" target="_blank" rel="noopener">runtime.selectgo</a> 函数的第三阶段，从 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L342-L368" target="_blank" rel="noopener">runtime.sudog</a> 结构体中获取数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool) &#123;</span><br><span class="line">	...</span><br><span class="line">	sg = (*sudog)(gp.param)</span><br><span class="line">	gp.param = nil</span><br><span class="line"></span><br><span class="line">	casi = -1</span><br><span class="line">	cas = nil</span><br><span class="line">	sglist = gp.waiting</span><br><span class="line">	for _, casei := range lockorder &#123;</span><br><span class="line">		k = &amp;scases[casei]</span><br><span class="line">		if sg == sglist &#123;</span><br><span class="line">			casi = int(casei)</span><br><span class="line">			cas = k</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			if k.kind == caseSend &#123;</span><br><span class="line">				c.sendq.dequeueSudoG(sglist)</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				c.recvq.dequeueSudoG(sglist)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sgnext = sglist.waitlink</span><br><span class="line">		sglist.waitlink = nil</span><br><span class="line">		releaseSudog(sglist)</span><br><span class="line">		sglist = sgnext</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c = cas.c</span><br><span class="line">	goto retc</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三次遍历全部 <code>case</code> 时，我们会先获取当前 Goroutine 接收到的参数 <code>sudog</code> 结构，我们会依次对比所有 <code>case</code> 对应的 <code>sudog</code> 结构找到被唤醒的 <code>case</code>，获取该 <code>case</code> 对应的索引并返回。</p>
<p>由于当前的 <code>select</code> 结构找到了一个 <code>case</code> 执行，那么剩下 <code>case</code> 中没有被用到的 <code>sudog</code> 就会被忽略并且释放掉。为了不影响 Channel 的正常使用，我们还是需要将这些废弃的 <code>sudog</code> 从 Channel 中出队。</p>
<p>当我们在循环中发现缓冲区中有元素或者缓冲区未满时就会通过 <code>goto</code> 关键字跳转到 <code>bufrecv</code> 和 <code>bufsend</code> 两个代码段，这两段代码的执行过程都很简单，它们只是向 Channel 中发送数据或者从缓冲区中获取新数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">bufrecv:</span><br><span class="line">	recvOK = true</span><br><span class="line">	qp = chanbuf(c, c.recvx)</span><br><span class="line">	if cas.elem != nil &#123;</span><br><span class="line">		typedmemmove(c.elemtype, cas.elem, qp)</span><br><span class="line">	&#125;</span><br><span class="line">	typedmemclr(c.elemtype, qp)</span><br><span class="line">	c.recvx++</span><br><span class="line">	if c.recvx == c.dataqsiz &#123;</span><br><span class="line">		c.recvx = 0</span><br><span class="line">	&#125;</span><br><span class="line">	c.qcount--</span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	goto retc</span><br><span class="line"></span><br><span class="line">bufsend:</span><br><span class="line">	typedmemmove(c.elemtype, chanbuf(c, c.sendx), cas.elem)</span><br><span class="line">	c.sendx++</span><br><span class="line">	if c.sendx == c.dataqsiz &#123;</span><br><span class="line">		c.sendx = 0</span><br><span class="line">	&#125;</span><br><span class="line">	c.qcount++</span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	goto retc</span><br></pre></td></tr></table></figure>

<p>这里在缓冲区进行的操作和直接调用 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L157-L278" target="_blank" rel="noopener">runtime.chansend</a> 和 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L448-L579" target="_blank" rel="noopener">runtime.chanrecv</a> 函数差不多，上述两个过程在执行结束之后都会直接跳到 <code>retc</code> 字段。</p>
<p>两个直接对 Channel 收发的情况会调用 Channel 运行时函数 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L286-L317" target="_blank" rel="noopener">runtime.send</a> 和 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L594-L635" target="_blank" rel="noopener">runtime.recv</a>，这两个函数会直接与处于休眠状态的 Goroutine 打交道：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">recv:</span><br><span class="line">	recv(c, sg, cas.elem, func() &#123; selunlock(scases, lockorder) &#125;, 2)</span><br><span class="line">	recvOK = true</span><br><span class="line">	goto retc</span><br><span class="line"></span><br><span class="line">send:</span><br><span class="line">	send(c, sg, cas.elem, func() &#123; selunlock(scases, lockorder) &#125;, 2)</span><br><span class="line">	goto retc</span><br></pre></td></tr></table></figure>

<p>不过如果向关闭的 Channel 发送数据或者从关闭的 Channel 中接收数据，情况就稍微有一点复杂了：</p>
<ul>
<li>从一个关闭 Channel 中接收数据会直接清除 Channel 中的相关内容；</li>
<li>向一个关闭的 Channel 发送数据就会直接 <code>panic</code> 造成程序崩溃：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rclose:</span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	recvOK = false</span><br><span class="line">	if cas.elem != nil &#123;</span><br><span class="line">		typedmemclr(c.elemtype, cas.elem)</span><br><span class="line">	&#125;</span><br><span class="line">	goto retc</span><br><span class="line"></span><br><span class="line">sclose:</span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	panic(plainError(&quot;send on closed channel&quot;))</span><br></pre></td></tr></table></figure>

<p>总体来看，<code>select</code> 语句中的 Channel 收发操作和直接操作 Channel 没有太多出入，只是由于 <code>select</code> 多出了 <code>default</code> 关键字所以会支持非阻塞的收发。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>我们简单总结一下 <code>select</code> 结构的执行过程与实现原理，首先在编译期间，Go 语言会对 <code>select</code> 语句进行优化，它会根据 <code>select</code> 中 <code>case</code> 的不同选择不同的优化路径：</p>
<ol>
<li>空的 <code>select</code> 语句会被转换成 <a href="https://github.com/golang/go/blob/c112289ee4141ebc31db50328c355b01278b987b/src/runtime/select.go#L104-L106" target="_blank" rel="noopener">runtime.block</a> 函数的调用，直接挂起当前 Goroutine；</li>
<li>如果 <code>select</code> 语句中只包含一个 <code>case</code>，就会被转换成 <code>if ch == nil { block }; n;</code> 表达式；<ul>
<li>首先判断操作的 Channel 是不是空的；</li>
<li>然后执行 <code>case</code> 结构中的内容；</li>
</ul>
</li>
<li>如果 <code>select</code> 语句中只包含两个 <code>case</code> 并且其中一个是 <code>default</code>，那么会使用 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L683-L686" target="_blank" rel="noopener">runtime.selectnbrecv</a> 和 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L662-L664" target="_blank" rel="noopener">runtime.selectnbsend</a> 非阻塞地执行收发操作；</li>
<li>在默认情况下会通过 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497" target="_blank" rel="noopener">runtime.selectgo</a> 函数获取执行 <code>case</code> 的索引，并通过多个 <code>if</code> 语句执行对应 <code>case</code> 中的代码；</li>
</ol>
<p>在编译器已经对 <code>select</code> 语句进行优化之后，Go 语言会在运行时执行编译期间展开的 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497" target="_blank" rel="noopener">runtime.selectgo</a> 函数，该函数会按照以下的流程执行：</p>
<ol>
<li>随机生成一个遍历的轮询顺序 <code>pollOrder</code> 并根据 Channel 地址生成锁定顺序 <code>lockOrder</code>；</li>
<li>根据 <code>pollOrder</code> 遍历所有的 <code>case</code> 查看是否有可以立刻处理的 Channel；<ol>
<li>如果存在就直接获取 <code>case</code> 对应的索引并返回；</li>
<li>如果不存在就会创建 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L342-L368" target="_blank" rel="noopener">runtime.sudog</a> 结构体，将当前 Goroutine 加入到所有相关 Channel 的收发队列，并调用 <a href="https://github.com/golang/go/blob/c112289ee4141ebc31db50328c355b01278b987b/src/runtime/proc.go#L287-L305" target="_blank" rel="noopener">runtime.gopark</a> 挂起当前 Goroutine 等待调度器的唤醒；</li>
</ol>
</li>
<li>当调度器唤醒当前 Goroutine 时就会再次按照 <code>lockOrder</code> 遍历所有的 <code>case</code>，从中查找需要被处理的 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L342-L368" target="_blank" rel="noopener">runtime.sudog</a> 结构对应的索引；</li>
</ol>
<p><code>select</code> 关键字是 Go 语言特有的控制结构，它的实现原理比较复杂，需要编译器和运行时函数的通力合作。</p>
<h1 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h1><p><a href="https://man7.org/linux/man-pages/man2/select.2.html" target="_blank" rel="noopener">SELECT(2) · Linux</a></p>
<div id="fnref:1">1.</div> Ken Thompson. Nov 6, 2008. select default. 

<p><a href="https://github.com/golang/go/commit/79fbbe37a76502e6f5f9647d2d82bab953ab1546#diff-fb0a5ae9dd70f0a43038d55c0204fdff" target="_blank" rel="noopener">https://github.com/golang/go/commit/79fbbe37a76502e6f5f9647d2d82bab953ab1546#diff-fb0a5ae9dd70f0a43038d55c0204fdff</a> ↩︎</p>
<div id="fnref:2">2.</div> Russ Cox. Jan 31, 2011. gc: special case code for single-op blocking and non-blocking selects.

<p><a href="https://github.com/golang/go/commit/5038792837355abde32f2e9549ef132fc5ffbd16" target="_blank" rel="noopener">https://github.com/golang/go/commit/5038792837355abde32f2e9549ef132fc5ffbd16</a> ↩︎</p>
<div id="fnref:3">3.</div> Russ Cox. Feb 1, 2011. gc: remove non-blocking send, receive syntax. 

<p><a href="https://github.com/golang/go/commit/cb584707af2d8803adba88fd9692e665ecd2f059" target="_blank" rel="noopener">https://github.com/golang/go/commit/cb584707af2d8803adba88fd9692e665ecd2f059</a> ↩︎</p>
<div id="fnref:4">4.</div> Russ Cox. Mar 12, 2011. gc, runtime: replace closed(c) with x, ok := <-c. <p><a href="https://github.com/golang/go/commit/8bf34e335686816f7fe7e28614b2c7a3e04e9e7c" target="_blank" rel="noopener">https://github.com/golang/go/commit/8bf34e335686816f7fe7e28614b2c7a3e04e9e7c</a> ↩︎<p></p>
<div id="fnref:5">5.</div> Ken Thompson. Jul 25, 2008. select. 

<p><a href="https://github.com/golang/go/commit/cb9b1038db77198c2b0961634cf161258af2374d" target="_blank" rel="noopener">https://github.com/golang/go/commit/cb9b1038db77198c2b0961634cf161258af2374d</a> ↩︎</p>
<div id="fnref:6">6.</div> Gustavo Niemeyer. Aug 15, 2011. runtime: fix pseudo-randomness on some selects. 

<p><a href="https://github.com/golang/go/commit/175849295ce632c2ddeca7024f7c783327b5e571" target="_blank" rel="noopener">https://github.com/golang/go/commit/175849295ce632c2ddeca7024f7c783327b5e571</a> ↩︎</p>
<h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-select/" target="_blank" rel="noopener">https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-select/</a></p>
</-c.>
    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\uber-go-guide.html" rel="bookmark">[转]Uber Go 语言编码规范</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\golang-practice-advice-for-go-library-authors.html" rel="bookmark">[转]给 Go 库作者的建议</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\how-to-correctly-use-package-context.html" rel="bookmark">[转]Golang 如何正确使用 Context</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\go-channels.html" rel="bookmark">[转]理解 Go Channels</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\tencent-trillion-level-elasticsearch-memory-efficiency-improves-decryption.html" rel="bookmark">[转]腾讯万亿级 Elasticsearch 内存效率提升解密</a></div>
    </li>
  </ul>

        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/reward/wechatpay.png" alt="jiankunking 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/reward/alipay.jpg" alt="jiankunking 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>jiankunking
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://jiankunking.com/go-select.html" title="[转]Go Select 实现分析">https://jiankunking.com/go-select.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-ND</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="/images/wechat/wechat.jpg">
            <span class="icon">
              <i class="fab fa-weixin"></i>
            </span>

            <span class="label">WeChat</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/转载/" rel="tag"># 转载</a>
              <a href="/tags/go/" rel="tag"># Go</a>
              <a href="/tags/select/" rel="tag"># Select</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/go-concurrency-patterns-context.html" rel="prev" title="[译]Go 并发 : Context">
      <i class="fa fa-chevron-left"></i> [译]Go 并发 : Context
    </a></div>
      <div class="post-nav-item">
    <a href="/spring-boot-clound-native-by-graalvm.html" rel="next" title="云原生时代的Spring Boot">
      云原生时代的Spring Boot <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#现象"><span class="nav-number">1.</span> <span class="nav-text">现象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#非阻塞的收发"><span class="nav-number">1.1.</span> <span class="nav-text">非阻塞的收发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#随机执行"><span class="nav-number">1.2.</span> <span class="nav-text">随机执行</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据结构"><span class="nav-number">2.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#实现原理"><span class="nav-number">3.</span> <span class="nav-text">实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#直接阻塞"><span class="nav-number">3.1.</span> <span class="nav-text">直接阻塞</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单一管道"><span class="nav-number">3.2.</span> <span class="nav-text">单一管道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非阻塞操作"><span class="nav-number">3.3.</span> <span class="nav-text">非阻塞操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#发送"><span class="nav-number">3.3.1.</span> <span class="nav-text">发送</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接收"><span class="nav-number">3.3.2.</span> <span class="nav-text">接收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见流程"><span class="nav-number">3.3.3.</span> <span class="nav-text">常见流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#循环"><span class="nav-number">3.3.3.2.</span> <span class="nav-text">循环</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#小结"><span class="nav-number">4.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#拓展阅读"><span class="nav-number">5.</span> <span class="nav-text">拓展阅读</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#原文"><span class="nav-number">6.</span> <span class="nav-text">原文</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="jiankunking"
      src="/images/avatar/avatar.png">
  <p class="site-author-name" itemprop="name">jiankunking</p>
  <div class="site-description" itemprop="description">如果你来访我，我不在，请和我门外的花坐一会儿，它们很温暖，我注视他们很多很多日子了。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">164</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">242</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jiankunking" title="GitHub → https://github.com/jiankunking" rel="noopener" target="_blank">GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/jiankunking" title="CSDN → https://blog.csdn.net/jiankunking" rel="noopener" target="_blank">CSDN</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-nd.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/jiankunking" title="https://blog.csdn.net/jiankunking" rel="noopener" target="_blank">CSDN博客</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn" rel="noopener" target="_blank">鲁ICP备18016400号-1 </a>
  </div>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jiankunking</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.3m</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  <script src="/js/local-search.js"></script>












  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '5e2e6dc5bd7af549261d',
      clientSecret: 'f37069692932676f0ad9fbfecb5164aee191fe23',
      repo        : 'blog-comments',
      owner       : 'jiankunking',
      admin       : ['jiankunking'],
      id          : '03733198bc8ba838a03a9352640c0559',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
