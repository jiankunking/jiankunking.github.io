<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.1">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.1" color="#222">
  <meta name="google-site-verification" content="true">
  <meta name="msvalidate.01" content="true">
  <meta name="baidu-site-verification" content="true">

<link rel="stylesheet" href="/css/main.css?v=7.4.1">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.4.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="MySQL实战45讲 学习笔记作者： 林晓斌">
<meta name="keywords" content="读书笔记,原创,MySQL">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL实战45讲 学习笔记">
<meta property="og:url" content="https://jiankunking.com/45-lectures-on-mysql-in-practice-notes.html">
<meta property="og:site_name" content="衣舞晨风">
<meta property="og:description" content="MySQL实战45讲 学习笔记作者： 林晓斌">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://jiankunking.com/images/45-lectures-on-mysql-in-practice-notes/mysql_logical_architecture_diagram.png">
<meta property="og:image" content="https://jiankunking.com/images/45-lectures-on-mysql-in-practice-notes/checkpoint_and_write_pos.png">
<meta property="og:image" content="https://jiankunking.com/images/45-lectures-on-mysql-in-practice-notes/read-view.png">
<meta property="og:image" content="https://jiankunking.com/images/45-lectures-on-mysql-in-practice-notes/InnoDB%E7%9A%84%E7%B4%A2%E5%BC%95%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://jiankunking.com/images/45-lectures-on-mysql-in-practice-notes/MDL_LOCK_EXAMPLES.png">
<meta property="og:image" content="https://jiankunking.com/images/45-lectures-on-mysql-in-practice-notes/InnoDB%E7%9A%84%E7%B4%A2%E5%BC%95%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://jiankunking.com/images/45-lectures-on-mysql-in-practice-notes/redo_log%E7%8A%B6%E6%80%81%E5%9B%BE.png">
<meta property="og:image" content="https://jiankunking.com/images/45-lectures-on-mysql-in-practice-notes/%E4%BC%9A%E8%AF%9DA%E3%80%81B%E7%9A%84%E6%89%A7%E2%BE%8F%E6%97%B6%E5%BA%8F%E5%9B%BE.png">
<meta property="og:updated_time" content="2020-02-18T01:18:45.945Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MySQL实战45讲 学习笔记">
<meta name="twitter:description" content="MySQL实战45讲 学习笔记作者： 林晓斌">
<meta name="twitter:image" content="https://jiankunking.com/images/45-lectures-on-mysql-in-practice-notes/mysql_logical_architecture_diagram.png">
  <link rel="canonical" href="https://jiankunking.com/45-lectures-on-mysql-in-practice-notes">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>MySQL实战45讲 学习笔记 | 衣舞晨风</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?3a234fd6ba55e88f18fe2d8e55dd52c5";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">衣舞晨风</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="fa fa-search fa-fw"></i>搜索</a>
      </li>
    
  </ul>

    

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/jiankunking" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="https://jiankunking.com/45-lectures-on-mysql-in-practice-notes.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jiankunking">
      <meta itemprop="description" content="愿我所遇之人，所历之事，哪怕因为我有一点点变好，我就心满意足了。">
      <meta itemprop="image" content="/images/avatar/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="衣舞晨风">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">MySQL实战45讲 学习笔记

          
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-02-06 15:15:11" itemprop="dateCreated datePublished" datetime="2020-02-06T15:15:11+08:00">2020-02-06</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-18 09:18:45" itemprop="dateModified" datetime="2020-02-18T09:18:45+08:00">2020-02-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a></span>

                
                
              
            </span>
          

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/45-lectures-on-mysql-in-practice-notes.html#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/45-lectures-on-mysql-in-practice-notes.html" itemprop="commentCount"></span></a>
  </span>
  
  
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>17k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>15 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>MySQL实战45讲 学习笔记<br>作者： 林晓斌</p>
<a id="more"></a>

<h1 id="基础架构：一条SQL查询语句是如何执行的？"><a href="#基础架构：一条SQL查询语句是如何执行的？" class="headerlink" title="基础架构：一条SQL查询语句是如何执行的？"></a>基础架构：一条SQL查询语句是如何执行的？</h1><p><img src="/images/45-lectures-on-mysql-in-practice-notes/mysql_logical_architecture_diagram.png" alt></p>
<p><strong>⼤多数情况下我会建议你不要使⽤查询缓存，为什么呢？因为查询缓存往往弊⼤于利。</strong></p>
<p>查询缓存的失效⾮常频繁，只要有对⼀个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使⽤呢，就被⼀个更新全清空了。对于更新压⼒⼤的数据库来说，查询缓存的命中率会⾮常低。除⾮你的业务就是有⼀张静态表，很长时间才会更新⼀次。⽐如，⼀个系统配置表，那这张表上的查询才适合使⽤查询缓存。</p>
<p>好在MySQL也提供了这种“按需使⽤”的⽅式。你可以将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句都不使⽤查询缓存。⽽对于你确定要使⽤查询缓存的语句，可以⽤SQL_CACHE显式指定，像下⾯这个语句⼀样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select SQL_CACHE * from T where ID=10；</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。</p>
</blockquote>
<h1 id="日志系统：一条SQL更新语句是如何执行的？"><a href="#日志系统：一条SQL更新语句是如何执行的？" class="headerlink" title="日志系统：一条SQL更新语句是如何执行的？"></a>日志系统：一条SQL更新语句是如何执行的？</h1><h2 id="重要的⽇志模块：redo-log"><a href="#重要的⽇志模块：redo-log" class="headerlink" title="重要的⽇志模块：redo log"></a>重要的⽇志模块：redo log</h2><p>当有⼀条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log⾥⾯，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘⾥⾯，⽽这个更新往往是在系统⽐较空闲的时候做。</p>
<p>InnoDB的redo log是固定⼤⼩的，⽐如可以配置为⼀组4个⽂件，每个⽂件的⼤⼩是1GB，总共就可以记录4GB的操作。从头开始写，写到末尾就⼜回到开头循环写，如下⾯这个图所示。</p>
<p><img src="/images/45-lectures-on-mysql-in-practice-notes/checkpoint_and_write_pos.png" alt></p>
<p>write pos是当前记录的位置，⼀边写⼀边后移，写到第3号⽂件末尾后就回到0号⽂件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据⽂件。</p>
<p>如果write pos追上checkpoint，这时候不能再执⾏新的更新，得停下来先擦掉⼀些记录，把checkpoint推进⼀下。</p>
<p>有了redo log，InnoDB就可以保证即使数据库发⽣异常重启，之前提交的记录都不会丢失，这个能⼒称为crash-safe。</p>
<h2 id="重要的⽇志模块：binlog"><a href="#重要的⽇志模块：binlog" class="headerlink" title="重要的⽇志模块：binlog"></a>重要的⽇志模块：binlog</h2><p>MySQL整体来看，其实就有两块：⼀块是Server层，它主要做的是MySQL功能层⾯的事情；还有⼀块是引擎层，负责存储相关的具体事宜。上⾯我们聊到的redo log是InnoDB引擎特有的⽇志，⽽Server层也有⾃⼰的⽇志，称为binlog（归档⽇志）。</p>
<p>我想你肯定会问，为什么会有两份⽇志呢？</p>
<p>因为最开始MySQL⾥并没有InnoDB引擎。MySQL⾃带的引擎是MyISAM，但是MyISAM没有crash-safe的能⼒，binlog⽇志只能⽤于归档。⽽InnoDB是另⼀个公司以插件形式引⼊MySQL的，既然只依靠binlog是没有crash-safe能⼒的，所以InnoDB使⽤另外⼀套⽇志系统——也就是redo log来实现crash-safe能⼒。</p>
<p>这两种⽇志有以下三点不同。</p>
<ol>
<li>redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使⽤。</li>
<li>redo log是物理⽇志，记录的是“在某个数据上做了什么修改”；binlog是逻辑⽇志，记录的是这个语句的原始逻辑，⽐如“给ID=2这⼀⾏的c字段加1 ”。</li>
<li>redo log是循环写的，空间固定会⽤完；binlog是可以追加写⼊的。“追加写”是指binlog⽂件写到⼀定⼤⼩后会切换到下⼀个，并不会覆盖以前的⽇志。</li>
</ol>
<p>有了对这两个⽇志的概念性理解，我们再来看执⾏器和InnoDB引擎在执⾏这个简单的update语句时的内部流程。</p>
<ol>
<li>执⾏器先找引擎取ID=2这⼀⾏。ID是主键，引擎直接⽤树搜索找到这⼀⾏。如果ID=2这⼀⾏所在的数据本来就在内存中，就直接返回给执⾏器；否则，需要先从磁盘读⼊内存，然后再返回。</li>
<li>执⾏器拿到引擎给的⾏数据，把这个值加上1，⽐如原来是N，现在就是N+1，得到新的⼀⾏数据，再调⽤引擎接⼝写⼊这⾏新数据。</li>
<li>引擎将这⾏新数据更新到内存中，同时将这个更新操作记录到redo log⾥⾯，此时redo log处于prepare状态。然后告知执⾏器执⾏完成了，随时可以提交事务。</li>
<li>执⾏器⽣成这个操作的binlog，并把binlog写⼊磁盘。</li>
<li>执⾏器调⽤引擎的提交事务接⼝，引擎把刚刚写⼊的redo log改成提交（commit）状态，更新完成。</li>
</ol>
<p>最后三步看上去有点“绕”，将redo log的写⼊拆成了两个步骤：prepare和commit，这就是”两阶段提交”。</p>
<h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><p>为什么必须有“两阶段提交”呢？这是为了让两份⽇志之间的逻辑⼀致。要说明这个问题，我们得从⽂章开头的那个问题说起：怎样让数据库恢复到半个⽉内任意⼀秒的状态？</p>
<p>前⾯我们说过了，binlog会记录所有的逻辑操作，并且是采⽤“追加写”的形式。如果你的DBA承诺说半个⽉内可以恢复，那么备份系统中⼀定会保存最近半个⽉的所有binlog，同时系统会定期做整库备份。这⾥的“定期”取决于系统的重要性，可以是⼀天⼀备，也可以是⼀周⼀备。</p>
<p>当需要恢复到指定的某⼀秒时，⽐如某天下午两点发现中午⼗⼆点有⼀次误删表，需要找回数据，那你可以这么做：</p>
<ul>
<li>⾸先，找到最近的⼀次全量备份，如果你运⽓好，可能就是昨天晚上的⼀个备份，从这个备份恢复到临时库；</li>
<li>然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。</li>
</ul>
<p>这样你的临时库就跟误删之前的线上库⼀样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。</p>
<p>好了，说完了数据恢复过程，我们回来说说，为什么⽇志需要“两阶段提交”。这⾥不妨⽤反证法来进⾏解释。</p>
<p>由于redo log和binlog是两个独⽴的逻辑，如果不⽤两阶段提交，要么就是先写完redo log再写binlog，或者采⽤反过来的顺序。我们看看这两种⽅式会有什么问题。</p>
<p>仍然⽤前⾯的update语句来做例⼦。假设当前ID=2的⾏，字段c的值是0，再假设执⾏update语句过程中在写完第⼀个⽇志后，第⼆个⽇志还没有写完期间发⽣了crash，会出现什么情况呢？</p>
<ol>
<li>先写redo log后写binlog。假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前⾯说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这⼀⾏c的值是1。<br>但是由于binlog没写完就crash了，这时候binlog⾥⾯就没有记录这个语句。因此，之后备份⽇志的时候，存起来的binlog⾥⾯就没有这条语句。<br>然后你会发现，如果需要⽤这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这⼀次更新，恢复出来的这⼀⾏c的值就是0，与原库的值不同。</li>
<li>先写binlog后写redo log。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务⽆效，所以这⼀⾏c的值是0。但是binlog⾥⾯已经记录了“把c从0改成1”这个⽇志。所以，在之后⽤binlog来恢复的时候就多了⼀个事务出来，恢复出来的这⼀⾏c的值就是1，与原库的值不同。</li>
</ol>
<p>可以看到，如果不使⽤“两阶段提交”，那么数据库的状态就有可能和⽤它的⽇志恢复出来的库的状态不⼀致。</p>
<p>你可能会说，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀？<br>其实不是的，不只是误操作后需要⽤这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建⼀些备库来增加系统的读能⼒的时候，现在常见的做法也是⽤全量备份加上应⽤binlog来实现的，这个“不⼀致”就会导致你的线上出现主从数据库不⼀致的情况。</p>
<p>简单说，redo log和binlog都可以⽤于表示事务的提交状态，⽽两阶段提交就是让这两个状态保持逻辑上的⼀致。</p>
<h1 id="事务隔离：为什么你改了我还看不见？"><a href="#事务隔离：为什么你改了我还看不见？" class="headerlink" title="事务隔离：为什么你改了我还看不见？"></a>事务隔离：为什么你改了我还看不见？</h1><p>SQL标准的事务隔离级别包括：</p>
<ul>
<li>读未提交是指，⼀个事务还没提交时，它做的变更就能被别的事务看到。</li>
<li>读提交是指，⼀个事务提交之后，它做的变更才会被其他事务看到。</li>
<li><strong>可重复读是指，⼀个事务执⾏过程中看到的数据，总是跟这个事务在启动时看到的数据是⼀致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</strong></li>
<li>串⾏化，顾名思义是对于同⼀⾏记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前<br>⼀个事务执⾏完成，才能继续执⾏。</li>
</ul>
<p>在实现上，数据库⾥⾯会创建⼀个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都⽤这个视图。在“读提交”隔离级别下，这个视图是在每个SQL语句开始执⾏的时候创建的。这⾥需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；⽽“串⾏化”隔离级别下直接⽤加锁的⽅式来避免并⾏访问。</p>
<p>总结来说，存在即合理，哪个隔离级别都有它⾃⼰的使⽤场景，你要根据⾃⼰的业务情况来定。我想你可能会问那什么时候需要“可重复读”的场景呢？我们来看⼀个数据校对逻辑的案例。</p>
<p>假设你在管理⼀个个⼈银⾏账户表。⼀个表存了每个⽉⽉底的余额，⼀个表存了账单明细。这时候你要做数据校对，也就是判断上个⽉的余额和当前余额的差额，是否与本⽉的账单明细⼀致。你⼀定希望在校对过程中，即使有⽤户发⽣了⼀笔新的交易，也不影响你的校对结果。</p>
<p>这时候使⽤“可重复读”隔离级别就很⽅便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。</p>
<h2 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h2><p>理解了事务的隔离级别，我们再来看看事务隔离具体是怎么实现的。这⾥我们展开说明“可重复读”。</p>
<p>在MySQL中，实际上每条记录在更新的时候都会同时记录⼀条回滚操作。记录上的最新值，通过回滚操作，都可以得到前⼀个状态的值。</p>
<p>假设⼀个值从1被按顺序改成了2、3、4，在回滚⽇志⾥⾯就会有类似下⾯的记录。</p>
<p><img src="/images/45-lectures-on-mysql-in-practice-notes/read-view.png" alt></p>
<p>当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看到的，<strong>在视图A、B、C⾥⾯，这⼀个记录的值分别是1、2、4</strong>，同⼀条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于read-view A，要得到1，就必须将当前值依次执⾏图中所有的回滚操作得到。</p>
<p>同时你会发现，即使现在有另外⼀个事务正在将4改成5，这个事务跟read-view A、B、C对应的事务是不会冲突的。</p>
<h1 id="深入浅出索引（上）"><a href="#深入浅出索引（上）" class="headerlink" title="深入浅出索引（上）"></a>深入浅出索引（上）</h1><p>为了让⼀个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使⽤⼆叉树，⽽是要使⽤“N叉”树。这⾥，“N叉”树中的“N”取决于数据块的⼤⼩。</p>
<p><font color="DeepPink"><strong>以InnoDB的⼀个整数字段索引为例，这个N差不多是1200。这棵树⾼是4的时候，就可以存1200的3次⽅个值，这已经17亿了。考虑到树根的数据块总是在内存中的，⼀个10亿⾏的表上⼀个整数字段的索引，查找⼀个值最多只需要访问3次磁盘。其实，树的第⼆层也有很⼤概率在内存中，那么访问磁盘的平均次数就更少了。</strong></font></p>
<p>N叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被⼴泛应⽤在数据库引擎中了。</p>
<p>不管是哈希还是有序数组，或者N叉树，它们都是不断迭代、不断优化的产物或者解决⽅案。数据库技术发展到今天，跳表、LSM树等数据结构也被⽤于引擎设计中，这⾥我就不再⼀⼀展开了。</p>
<p><font color="DeepPink"><strong>你⼼⾥要有个概念，数据库底层存储的核⼼就是基于这些数据模型的。每碰到⼀个新数据库，我们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适⽤场景。</strong></font></p>
<p>在MySQL中，索引是在存储引擎层实现的，所以并没有统⼀的索引标准，即不同存储引擎的索引的⼯作⽅式并不⼀样。⽽即使多个存储引擎⽀持同⼀种类型的索引，其底层的实现也可能不同。</p>
<h2 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h2><p><strong>主键索引的叶⼦节点存的是整⾏数据。</strong>在InnoDB⾥，主键索引也被称为聚簇索引（clustered index）。<br><strong>⾮主键索引的叶⼦节点内容是主键的值。</strong>在InnoDB⾥，⾮主键索引也被称为⼆级索引（secondary index）。<br>根据上⾯的索引结构说明，我们来讨论⼀个问题：基于主键索引和普通索引的查询有什么区别？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 主键列为ID的表，表中有字段k，并且在k上有索引。</span><br><span class="line">create table T(</span><br><span class="line">id int primary key,</span><br><span class="line">k int not null,</span><br><span class="line">name varchar(16),</span><br><span class="line">index (k))engine=InnoDB;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果语句是select * from T where ID=500，即主键查询⽅式，则只需要搜索ID这棵B+树；</li>
<li>如果语句是select * from T where k=5，即普通索引查询⽅式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索⼀次。这个过程称为回表。</li>
</ul>
<p>也就是说，基于⾮主键索引的查询需要多扫描⼀棵索引树。因此，我们在应⽤中应该尽量使⽤主键查询。</p>
<h2 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h2><p>B+树为了维护索引有序性，在插⼊新值的时候需要做必要的维护。</p>
<blockquote>
<p>你可能在⼀些建表规范⾥⾯见到过类似的描述，要求建表语句⾥⼀定要有⾃增主键。当然事⽆绝对，我们来分析⼀下哪些场景下应该使⽤⾃增主键，⽽哪些场景下不应该。</p>
</blockquote>
<p>⾃增主键是指⾃增列上定义的主键，在建表语句中⼀般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。</p>
<p>插⼊新记录的时候可以不指定ID的值，系统会获取当前ID最⼤值加1作为下⼀条记录的ID值。</p>
<p>也就是说，<font color="DeepPink"><strong>⾃增主键的插⼊数据模式，正符合了我们前⾯提到的递增插⼊的场景。每次插⼊⼀条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶⼦节点的分裂。</strong></font></p>
<p>⽽有业务逻辑的字段做主键，则往往不容易保证有序插⼊，这样写数据成本相对较⾼。</p>
<p>除了考虑性能外，我们还可以从存储空间的⻆度来看。假设你的表中确实有⼀个唯⼀字段，⽐如字符串类型的身份证号，那应该⽤身份证号做主键，还是⽤⾃增字段做主键呢？</p>
<p>由于每个⾮主键索引的叶⼦节点上都是主键的值。如果⽤身份证号做主键，那么每个⼆级索引的叶⼦节点占⽤约20个字节，⽽如果⽤整型做主键，则只要4个字节，如果是长整型（bigint）则是8个字节。</p>
<p>显然，主键长度越⼩，普通索引的叶⼦节点就越⼩，普通索引占⽤的空间也就越⼩。</p>
<p>所以，从性能和存储空间⽅⾯考量，⾃增主键往往是更合理的选择。</p>
<p>有没有什么场景适合⽤业务字段直接做主键的呢？还是有的。⽐如，有些业务的场景需求是这样的：</p>
<ol>
<li>只有⼀个索引；</li>
<li>该索引必须是唯⼀索引。</li>
</ol>
<p>你⼀定看出来了，这就是典型的KV场景。</p>
<p>由于没有其他索引，所以也就不⽤考虑其他索引的叶⼦节点⼤⼩的问题。</p>
<p>这时候我们就要优先考虑上⼀段提到的“尽量使⽤主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。</p>
<h1 id="深⼊浅出索引（下）"><a href="#深⼊浅出索引（下）" class="headerlink" title="深⼊浅出索引（下）"></a>深⼊浅出索引（下）</h1><p>在下⾯这个表T中，如果我执⾏ select * from T where k between 3 and 5，需要执⾏⼏次树的搜索操作，会扫描多少⾏？</p>
<p>下⾯是这个表的初始化语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table T (</span><br><span class="line">ID int primary key,</span><br><span class="line">k int NOT NULL DEFAULT 0,</span><br><span class="line">s varchar(16) NOT NULL DEFAULT &apos;&apos;,</span><br><span class="line">index k(k))</span><br><span class="line">engine=InnoDB;</span><br><span class="line">insert into T values(100,1, &apos;aa&apos;),(200,2,&apos;bb&apos;),(300,3,&apos;cc&apos;),(500,5,&apos;ee&apos;),(600,6,&apos;ff&apos;),(700,7,&apos;gg&apos;);</span><br></pre></td></tr></table></figure>

<p><img src="/images/45-lectures-on-mysql-in-practice-notes/InnoDB%E7%9A%84%E7%B4%A2%E5%BC%95%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84.png" alt></p>
<p>现在，我们⼀起来看看这条SQL查询语句的执⾏流程：</p>
<ol>
<li>在k索引树上找到k=3的记录，取得 ID = 300；</li>
<li>再到ID索引树查到ID=300对应的R3；</li>
<li>在k索引树取下⼀个值k=5，取得ID=500；</li>
<li>再回到ID索引树查到ID=500对应的R4；</li>
<li>在k索引树取下⼀个值k=6，不满⾜条件，循环结束。</li>
</ol>
<p>在这个过程中，<strong>回到主键索引树搜索的过程，我们称为回表</strong>。可以看到，这个查询过程读了k索引树的3条记录（步骤1、3和5），回表了两次（步骤2和4）。</p>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>如果执⾏的语句是select ID from T where k between 3 and 5，这时只需要查ID的值，⽽ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询⾥⾯，索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p>
<h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p>⽽MySQL 5.6 引⼊的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满⾜条件的记录，减少回表次数。</p>
<h1 id="全局锁和表锁"><a href="#全局锁和表锁" class="headerlink" title="全局锁和表锁"></a>全局锁和表锁</h1><p>根据加锁的范围，MySQL⾥⾯的锁⼤致可以分成全局锁、表级锁和⾏锁三类。</p>
<h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>顾名思义，全局锁就是对整个数据库实例加锁。MySQL提供了⼀个加全局读锁的⽅法，命令是 Flush tables with read lock(FTWRL)。当你需要让整个库处于只读状态的时候，可以使⽤这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p>
<p><strong>全局锁的典型使⽤场景是，做全库逻辑备份。</strong>也就是把整库每个表都select出来存成⽂本。</p>
<p>官⽅⾃带的逻辑备份⼯具是mysqldump。当mysqldump使⽤参数–single-transaction的时候，导数据之前就会启动⼀个事务，来确保拿到⼀致性视图。⽽由于MVCC的⽀持，这个过程中数据是可以正常更新的。</p>
<p>你⼀定在疑惑，有了这个功能，为什么还需要FTWRL呢？<strong>⼀致性读是好，但前提是引擎要⽀持这个隔离级别</strong>。⽐如，对于MyISAM这种不⽀持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的⼀致性。这时，我们就需要使⽤FTWRL命令了。</p>
<p>所以，<strong>single-transaction⽅法只适⽤于所有的表使⽤事务引擎的库</strong>。如果有的表使⽤了不⽀持事务的引擎，那么备份就只能通过FTWRL⽅法。这往往是DBA要求业务开发⼈员使⽤InnoDB替代MyISAM的原因之⼀。</p>
<p>你也许会问，既然要全库只读，为什么不使⽤set global readonly=true的⽅式呢？确实readonly⽅式也可以让全库进⼊只读状态，但我还是会建议你⽤FTWRL⽅式，主要有两个原因：</p>
<ul>
<li>⼀是，在有些系统中，readonly的值会被⽤来做其他逻辑，⽐如⽤来判断⼀个库是主库还是备库。因此，修改global变量的⽅式影响⾯更⼤，我不建议你使⽤。</li>
<li>⼆是，在异常处理机制上有差异。如果执⾏FTWRL命令之后由于客户端发⽣异常断开，那么MySQL会⾃动释放这个全局锁，整个库回到可以正常更新的状态。⽽将整个库设置为readonly之后，如果客户端发⽣异常，则数据库就会⼀直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较⾼。</li>
</ul>
<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>MySQL⾥⾯表级别的锁有两种：⼀种是表锁，⼀种是元数据锁（meta data lock，MDL)。</p>
<p><strong>表锁的语法是 lock tables … read/write</strong>。与FTWRL类似，可以⽤unlock tables主动释放锁，也可以在客户端断开的时候⾃动释放。需要注意，lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p>
<p>举个例⼦, 如果在某个线程A中执⾏lock tables t1 read, t2 write; 这个语句，则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执⾏unlock tables之前，也只能执⾏读t1、读写t2的操作。连写t1都不允许，⾃然也不能访问其他表。</p>
<p>在还没有出现更细粒度的锁的时候，表锁是最常⽤的处理并发的⽅式。⽽对于InnoDB这种⽀持⾏锁的引擎，⼀般不使⽤lock tables命令来控制并发，毕竟锁住整个表的影响⾯还是太⼤。</p>
<p><strong>另⼀类表级的锁是MDL（metadata lock)</strong>。MDL不需要显式使⽤，在访问⼀个表的时候会被⾃动加上。MDL的作⽤是，保证读写的正确性。你可以想象⼀下，如果⼀个查询正在遍历⼀个表中的数据，⽽执⾏期间另⼀个线程对这个表结构做变更，删了⼀列，那么查询线程拿到的结果跟表结构对不上，肯定是不⾏的。</p>
<p>因此，在MySQL 5.5版本中引⼊了MDL，当对⼀个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。</p>
<ul>
<li>读锁之间不互斥，因此你可以有多个线程同时对⼀张表增删改查。</li>
<li>读写锁之间、写锁之间是互斥的，⽤来保证变更表结构操作的安全性。因此，如果有两个线程要同时给⼀个表加字段，其中⼀个要等另⼀个执⾏完才能开始执⾏。</li>
</ul>
<p>你肯定知道，给⼀个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。在对⼤表操作的时候，你肯定会特别⼩⼼，以免对线上服务造成影响。⽽实际上，即使是⼩表，操作不慎也会出问题。我们来看⼀下下⾯的操作序列，假设表t是⼀个⼩表。</p>
<blockquote>
<p>备注：这⾥的实验环境是MySQL 5.6。</p>
</blockquote>
<p><img src="/images/45-lectures-on-mysql-in-practice-notes/MDL_LOCK_EXAMPLES.png" alt></p>
<p>我们可以看到session A先启动，这时候会对表t加⼀个MDL读锁。由于session B需要的也是MDL读锁，因此可以正常执⾏。之后session C会被blocked，是因为session A的MDL读锁还没有释放，⽽session C需要MDL写锁，因此只能被阻塞。</p>
<p>如果只有session C⾃⼰被阻塞还没什么关系，但是之后所有要在表t上新申请MDL读锁的请求也会被session C阻塞。前⾯我们说了，所有对表的增删改查操作都需要先申请MDL读锁，就都被锁住，等于这个表现在完全不可读写了。</p>
<p>如果某个表上的查询语句频繁，⽽且客户端有重试机制，也就是说超时后会再起⼀个新session再请求的话，这个库的线程很快就会爆满。</p>
<p>你现在应该知道了，事务中的MDL锁，在语句执⾏开始时申请，但是语句结束后并不会马上释放，⽽会等到整个事务提交后再释放。</p>
<h1 id="⾏锁"><a href="#⾏锁" class="headerlink" title="⾏锁"></a>⾏锁</h1><p><strong>在InnoDB事务中，⾏锁是在需要的时候才加上的，但并不是不需要了就⽴刻释放，⽽是要等到事务结束时才释放</strong>。这个就是两阶段锁协议。</p>
<p>知道了这个设定，对我们使⽤事务有什么帮助呢？那就是，<font color="DeepPink"><strong>如果你的事务中需要锁多个⾏，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</strong></font>我给你举个例⼦。</p>
<p>假设你负责实现⼀个电影票在线交易业务，顾客A要在影院B购买电影票。我们简化⼀点，这个业务需要涉及到以下操作：</p>
<ol>
<li>从顾客A账户余额中扣除电影票价；</li>
<li>给影院B的账户余额增加这张电影票价；</li>
<li>记录⼀条交易⽇志。</li>
</ol>
<p>也就是说，要完成这个交易，我们需要update两条记录，并insert⼀条记录。当然，为了保证交易的原⼦性，我们要把这三个操作放在⼀个事务中。那么，你会怎样安排这三个语句在事务中的顺序呢？</p>
<p>试想如果同时有另外⼀个顾客C要在影院B买票，那么这两个事务冲突的部分就是语句2了。因为它们要更新同⼀个影院账户的余额，需要修改同⼀⾏数据。</p>
<p>根据两阶段锁协议，不论你怎样安排语句顺序，所有的操作需要的⾏锁都是在事务提交的时候才释放的。所以，如果你把语句2安排在最后，⽐如按照3、1、2这样的顺序，那么影院账户余额这⼀⾏的锁时间就最少。这就最⼤程度地减少了事务之间的锁等待，提升了并发度。</p>
<h1 id="事务到底是隔离的还是不隔离的？"><a href="#事务到底是隔离的还是不隔离的？" class="headerlink" title="事务到底是隔离的还是不隔离的？"></a>事务到底是隔离的还是不隔离的？</h1><p>begin/start transaction 命令并不是⼀个事务的起点，在执⾏到它们之后的第⼀个操作InnoDB表的语句（第⼀个快照读语句），事务才真正启动。如果你想要马上启动⼀个事务，可以使⽤start transaction with consistent snapshot 这个命令。</p>
<p>在MySQL⾥，有两个“视图”的概念：</p>
<ul>
<li>⼀个是view。它是⼀个⽤查询语句定义的虚拟表，在调⽤的时候执⾏查询语句并⽣成结果。创建视图的语法是create view… ，⽽它的查询⽅法与表⼀样。</li>
<li>另⼀个是InnoDB在实现MVCC时⽤到的⼀致性读视图，即consistent read view，⽤于⽀持RC（Read Committed，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。</li>
</ul>
<p>它没有物理结构，作⽤是事务执⾏期间⽤来定义“我能看到什么数据”。</p>
<h2 id="“快照”在MVCC⾥是怎么⼯作的？"><a href="#“快照”在MVCC⾥是怎么⼯作的？" class="headerlink" title="“快照”在MVCC⾥是怎么⼯作的？"></a>“快照”在MVCC⾥是怎么⼯作的？</h2><p>在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的。</p>
<p>⼀个数据版本，对于⼀个事务视图来说，除了⾃⼰的更新总是可见以外，有三种情况：</p>
<ol>
<li>版本未提交，不可见；</li>
<li>版本已提交，但是是在视图创建后提交的，不可见；</li>
<li>版本已提交，⽽且是在视图创建前提交的，可见。</li>
</ol>
<p>更新数据都是先读后写的，⽽这个读，只能读当前的值，称为“当前读”（current read）。</p>
<blockquote>
<p><font color="DeepPink"><strong>当前读的规则，就是要能读到所有已经提交的记录的最新值。</strong></font></p>
</blockquote>
<p>这⾥我们提到了⼀个概念，叫作当前读。<font color="DeepPink"><strong>其实，除了update语句外，select语句如果加锁，也是当前读。</strong></font></p>
<blockquote>
<p>事务更新数据的时候，只能⽤当前读。如果当前的记录的⾏锁被其他事务占⽤的话，就需要进⼊锁等待。</p>
</blockquote>
<p><a href="/attachments/MySQL实战45讲/08讲事务到底是隔离的还是不隔离的.pdf" target="_blank">事务到底是隔离的还是不隔离的？</a></p>
<h1 id="普通索引和唯一索引，应该怎么选择"><a href="#普通索引和唯一索引，应该怎么选择" class="headerlink" title="普通索引和唯一索引，应该怎么选择?"></a>普通索引和唯一索引，应该怎么选择?</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(</span><br><span class="line">id int primary key,</span><br><span class="line">k int not null,</span><br><span class="line">name varchar(16),</span><br><span class="line">index (k))engine=InnoDB;</span><br></pre></td></tr></table></figure>

<p>假设字段 k 上的值都不重复。</p>
<p><img src="/images/45-lectures-on-mysql-in-practice-notes/InnoDB%E7%9A%84%E7%B4%A2%E5%BC%95%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84.png" alt></p>
<h2 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h2><p>假设，执⾏查询的语句是 select id from T where k=5。这个查询语句在索引树上查找的过程，先是通过B+树从树根开始，按层搜索到叶⼦节点，也就是图中右下⻆的这个数据页，然后可以认为数据页内部通过⼆分法来定位记录。</p>
<ul>
<li>对于普通索引来说，查找到满⾜条件的第⼀个记录(5,500)后，需要查找下⼀个记录，直到碰到第⼀个不满⾜k=5条件的记录。</li>
<li>对于唯⼀索引来说，由于索引定义了唯⼀性，查找到第⼀个满⾜条件的记录后，就会停⽌继续检索。</li>
</ul>
<p>那么，这个不同带来的性能差距会有多少呢？答案是，微乎其微。</p>
<p>你知道的，InnoDB的数据是按数据页为单位来读写的。也就是说，当需要读⼀条记录的时候，并不是将这个记录本身从磁盘读出来，⽽是以页为单位，将其整体读⼊内存。在InnoDB中，每个数据页的⼤⼩默认是16KB。</p>
<p>因为引擎是按页读写的，所以说，当找到k=5的记录的时候，它所在的数据页就都在内存⾥了。那么，对于普通索引来说，要多做的那⼀次“查找和判断下⼀条记录”的操作，就只需要⼀次指针寻找和⼀次计算。</p>
<p>当然，如果k=5这个记录刚好是这个数据页的最后⼀个记录，那么要取下⼀个记录，必须读取下⼀个数据页，这个操作会稍微复杂⼀些。</p>
<p>但是，我们之前计算过，对于整型字段，⼀个数据页可以放近千个key，因此出现这种情况的概率会很低。所以，我们计算平均性能差异时，仍可以认为这个操作成本对于现在的CPU来说可以忽略不计。</p>
<h2 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h2><p>当需要更新⼀个数据页时，如果数据页在内存中就直接更新，⽽如果这个数据页还没有在内存中的话，在不影响数据⼀致性的前提下，InooDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读⼊这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读⼊内存，然后执⾏change buffer中与这个页有关的操作。通过这种⽅式就能保证这个数据逻辑的正确性。</p>
<p>需要说明的是，虽然名字叫作change buffer，实际上它是可以持久化的数据。也就是说，change buffer在内存中有拷贝，也会被写⼊到磁盘上。</p>
<p>将change buffer中的操作应⽤到原数据页，得到最新结果的过程称为merge。除了访问这个数据页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭（shutdown）的过程中，也会执⾏merge操作。</p>
<p>显然，如果能够将更新操作先记录在change buffer，减少读磁盘，语句的执⾏速度会得到明显的提升。⽽且，数据读⼊内存是需要占⽤buffer pool的，所以这种⽅式还能够避免占⽤内存，提⾼内存利⽤率。</p>
<p>那么，什么条件下可以使⽤change buffer呢？</p>
<p>对于唯⼀索引来说，所有的更新操作都要先判断这个操作是否违反唯⼀性约束。⽐如，要插⼊(4,400)这个记录，就要先判断现在表中是否已经存在k=4的记录，⽽这必须要将数据页读⼊内存才能判断。如果都已经读⼊到内存了，那直接更新内存会更快，就没必要使⽤change buffer了。</p>
<p>因此，<strong>唯⼀索引的更新就不能使⽤change buffer，实际上也只有普通索引可以使⽤。</strong></p>
<p><a href="/attachments/MySQL实战45讲/09讲普通索引和唯一索引，应该怎么选择.pdf" target="_blank">普通索引和唯一索引，应该怎么选择?</a></p>
<h1 id="MySQL为什么有时候会选错索引"><a href="#MySQL为什么有时候会选错索引" class="headerlink" title="MySQL为什么有时候会选错索引?"></a>MySQL为什么有时候会选错索引?</h1><p>MySQL在真正开始执⾏语句之前，并不能精确地知道满⾜这个条件的记录有多少条，⽽只能根据统计信息来估算记录数。</p>
<p>估算出来的数字有可能会不准确，从而导致索引选择不对。</p>
<p><a href="/attachments/MySQL实战45讲/10讲MySQL为什么有时候会选错索引.pdf" target="_blank">MySQL为什么有时候会选错索引?</a></p>
<h1 id="怎么给字符串字段加索引？"><a href="#怎么给字符串字段加索引？" class="headerlink" title="怎么给字符串字段加索引？"></a>怎么给字符串字段加索引？</h1><ol>
<li>直接创建完整索引，这样可能⽐较占⽤空间；</li>
<li>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使⽤覆盖索引；</li>
<li>倒序存储，再创建前缀索引，⽤于绕过字符串本身前缀的区分度不够的问题；</li>
<li>创建hash字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种⽅式⼀样，都不⽀持范围扫描。</li>
</ol>
<h1 id="为什么我的MySQL会“抖”一下？"><a href="#为什么我的MySQL会“抖”一下？" class="headerlink" title="为什么我的MySQL会“抖”一下？"></a>为什么我的MySQL会“抖”一下？</h1><p>MySQL偶尔“抖”⼀下的那个瞬间，可能就是在刷脏页（flush）。</p>
<p>那么，什么情况会引发数据库的flush过程呢？</p>
<p>第⼀种场景是，InnoDB的redo log写满了。这时候系统会停⽌所有更新操作，把checkpoint往前推进，redo log留出空间可以继续写。</p>
<p><img src="/images/45-lectures-on-mysql-in-practice-notes/redo_log%E7%8A%B6%E6%80%81%E5%9B%BE.png" alt></p>
<p>第⼆种场景是，就是系统内存不⾜。当需要新的内存页，⽽内存不够⽤的时候，就要淘汰⼀些数据页，空出内存给别的数据页使⽤。如果淘汰的是“脏页”，就要先将脏页写到磁盘。</p>
<p>你⼀定会说，这时候难道不能直接把内存淘汰掉，下次需要请求的时候，从磁盘读⼊数据页，然后拿redo log出来应⽤不就⾏了？这⾥其实是从性能考虑的。如果刷脏页⼀定会写盘，就保证了每个数据页有两种状态：</p>
<ul>
<li>⼀种是内存⾥存在，内存⾥就肯定是正确的结果，直接返回；</li>
<li>另⼀种是内存⾥没有数据，就可以肯定数据⽂件上是正确的结果，读⼊内存后返回。这样的效率最⾼。</li>
</ul>
<p>第三种场景是，就是MySQL认为系统“空闲”的时候。<br>第四种场景是，就是MySQL正常关闭的情况。这时候，MySQL会把内存的脏页都flush到磁盘上，这样下次MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</p>
<p>刷脏页虽然是常态，但是出现以下这两种情况，都是会明显影响性能的：</p>
<ol>
<li>⼀个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；</li>
<li>⽇志写满，更新全部堵住，写性能跌为0，这种情况对敏感业务来说，是不能接受的。</li>
</ol>
<p>所以，InnoDB需要有控制脏页⽐例的机制，来尽量避免上⾯的这两种情况。</p>
<h2 id="InnoDB刷脏页的控制策略"><a href="#InnoDB刷脏页的控制策略" class="headerlink" title="InnoDB刷脏页的控制策略"></a>InnoDB刷脏页的控制策略</h2><p>合理地设置innodb_io_capacity的值，并且平时要多关注脏页⽐例，不要让它经常接近75%。</p>
<p>更详细的关于innodb_io_capacity、innodb_max_dirty_pages_pct等参数的设置参见：<a href="/attachments/MySQL实战45讲/12讲为什么我的MySQL会“抖”一下.pdf" target="_blank">为什么我的MySQL会“抖”一下?</a></p>
<h1 id="为什么表数据删掉一半，表文件大小不变？"><a href="#为什么表数据删掉一半，表文件大小不变？" class="headerlink" title="为什么表数据删掉一半，表文件大小不变？"></a>为什么表数据删掉一半，表文件大小不变？</h1><p>delete命令其实只是把记录的位置，或者数据页标记为了“可复⽤”，但磁盘⽂件的⼤⼩是不会变的。也就是说，通过delete命令是不能回收表空间的。这些可以复⽤，⽽没有被使⽤的空间，看起来就像是“空洞”。</p>
<p>实际上，不⽌是删除数据会造成空洞，插⼊数据也会。</p>
<p>如果数据是按照索引递增顺序插⼊的，那么索引是紧凑的。但如果数据是随机插⼊的，就可能造成索引的数据页分裂。</p>
<p>表空间收缩的方式：重建表</p>
<p>重建表的方式及需要注意的问题，参见：<a href="/attachments/MySQL实战45讲/13讲为什么表数据删掉一半，表文件大小不变.pdf" target="_blank">为什么表数据删掉一半，表文件大小不变?</a></p>
<h1 id="count-这么慢，我该怎么办？"><a href="#count-这么慢，我该怎么办？" class="headerlink" title="count()这么慢，我该怎么办？"></a>count()这么慢，我该怎么办？</h1><h2 id="count-的实现⽅式"><a href="#count-的实现⽅式" class="headerlink" title="count(*)的实现⽅式"></a>count(*)的实现⽅式</h2><p>在不同的MySQL引擎中，count(*)有不同的实现⽅式。</p>
<ul>
<li>MyISAM引擎把⼀个表的总⾏数存在了磁盘上，因此执⾏count(*)的时候会直接返回这个数，效率很⾼；</li>
<li>⽽InnoDB引擎就麻烦了，它执⾏count(*)的时候，需要把数据⼀⾏⼀⾏地从引擎⾥⾯读出来，然后累积计数。</li>
</ul>
<p>这⾥需要注意的是，我们在这篇⽂章⾥讨论的是没有过滤条件的count(*)，如果加了where 条件的话，MyISAM表也是不能返回得这么快的。</p>
<p>那为什么<strong>InnoDB不跟MyISAM⼀样，也把数字存起来呢？</strong><br>这是因为即使是在同⼀个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB表“应该返回多少⾏”也是不确定的。</p>
<p>由于InnoDB要⽀持事务，从⽽导致InnoDB表不能把count(*)直接存起来，然后查询的时候直接返回形成的。</p>
<p>所谓以⼦之⽭攻⼦之盾，现在我们就利⽤“事务”这个特性，把问题解决掉。</p>
<p><img src="/images/45-lectures-on-mysql-in-practice-notes/%E4%BC%9A%E8%AF%9DA%E3%80%81B%E7%9A%84%E6%89%A7%E2%BE%8F%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt></p>
<p>我们来看下现在的执⾏结果。虽然会话B的读操作仍然是在T3执⾏的，但是因为这时候更新事务还没有提交，所以计数值加1这个操作对会话B还不可见。</p>
<p>因此，会话B看到的结果⾥， 查计数值和“最近100条记录”看到的结果，逻辑上就是⼀致的。</p>
<h2 id="不同的count⽤法"><a href="#不同的count⽤法" class="headerlink" title="不同的count⽤法"></a>不同的count⽤法</h2><p>count(*)、count(主键id)和count(1) 都表示返回满⾜条件的结果集的总⾏数；⽽count(字段），则表示返回满⾜条件的数据⾏⾥⾯，参数“字段”不为NULL的总个数。</p>
<p>⾄于分析性能差别的时候，你可以记住这么⼏个原则：</p>
<ol>
<li>server层要什么就给什么；</li>
<li>InnoDB只给必要的值；</li>
<li>现在的优化器只优化了count(*)的语义为“取⾏数”，其他“显⽽易见”的优化并没有做。</li>
</ol>
<p>对于count(主键id)来说，InnoDB引擎会遍历整张表，把每⼀⾏的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空的，就按⾏累加。</p>
<p>对于count(1)来说，InnoDB引擎遍历整张表，但不取值。server层对于返回的每⼀⾏，放⼀个数字“1”进去，判断是不可能为空的，按⾏累加。</p>
<p>单看这两个⽤法的差别的话，你能对⽐出来，count(1)执⾏得要⽐count(主键id)快。因为从引擎返回id会涉及到解析数据⾏，以及拷贝字段值的操作。</p>
<p>对于count(字段)来说：</p>
<ol>
<li>如果这个“字段”是定义为not null的话，⼀⾏⾏地从记录⾥⾯读出这个字段，判断不能为null，按⾏累加；</li>
<li>如果这个“字段”定义允许为null，那么执⾏的时候，判断到有可能是null，还要把值取出来再判断⼀下，不是null才累加。</li>
</ol>
<p>也就是前⾯的第⼀条原则，server层要什么字段，InnoDB就返回什么字段。<br>但是count(&#42;)是例外，并不会把全部字段取出来，⽽是专门做了优化，不取值。count(&#42;)肯定不是null，按⾏累加。</p>
<p>所以结论是：按照效率排序的话，count(字段)&lt;count(主键id)&lt;count(1)≈count(&#42;)，所以我建议你，尽量使⽤count(&#42;)。</p>
<!-- * 转义字符为 &#42; -->

<h1 id="答疑：日志和索引相关问题"><a href="#答疑：日志和索引相关问题" class="headerlink" title="答疑：日志和索引相关问题"></a>答疑：日志和索引相关问题</h1><ul>
<li>MySQL怎么知道binlog是完整的?</li>
<li>redo log 和 binlog是怎么关联起来的?</li>
<li>处于prepare阶段的redo log加上完整binlog，重启就能恢复，MySQL为什么要这么设计?</li>
<li>如果这样的话，为什么还要两阶段提交呢？⼲脆先redo log写完，再写binlog。崩溃恢复的时候，必须得两个⽇志都完整才可以。是不是⼀样的逻辑？</li>
<li>不引⼊两个⽇志，也就没有两阶段提交的必要了。只⽤binlog来⽀持崩溃恢复，⼜能⽀持归档，不就可以了？</li>
<li>那能不能反过来，只⽤redo log，不要binlog？</li>
<li>redo log⼀般设置多⼤？</li>
<li>正常运⾏中的实例，数据写⼊后的最终落盘，是从redo log更新过来的还是从buffer pool更新过来的呢？</li>
<li>redo log buffer是什么？是先修改内存，还是先写redo log⽂件？</li>
</ul>
<p>详细解答参见：<a href="/attachments/MySQL实战45讲/15讲答疑文章（一）：日志和索引相关问题.pdf" target="_blank">答疑：日志和索引相关问题?</a></p>
<h1 id="“order-by”是怎么工作的？"><a href="#“order-by”是怎么工作的？" class="headerlink" title="“order by”是怎么工作的？"></a>“order by”是怎么工作的？</h1><p>sort_buffer_size，就是MySQL为排序开辟的内存（sort_buffer）的⼤⼩。如果要排序的数据量⼩于sort_buffer_size，排序就在内存中完成。但如果排序数据量太⼤，内存放不下，则不得不利⽤磁盘临时⽂件辅助排序。</p>
<p>optimizer_trace 可支持把MySQL查询执行计划树打印出来。</p>
<p><a href="/attachments/MySQL实战45讲/16讲“orderby”是怎么工作的.pdf" target="_blank">“order by”是怎么工作的？</a></p>
<h1 id="为什么这些SQL语句逻辑相同，性能却差异巨大？"><a href="#为什么这些SQL语句逻辑相同，性能却差异巨大？" class="headerlink" title="为什么这些SQL语句逻辑相同，性能却差异巨大？"></a>为什么这些SQL语句逻辑相同，性能却差异巨大？</h1><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>数据库⾥⾯类型这么多，这种数据类型转换规则更多，我记不住，应该怎么办呢？</p>
<p>这⾥有⼀个简单的⽅法，看 select “10” &gt; 9 的结果：</p>
<ol>
<li>如果规则是“将字符串转成数字”，那么就是做数字⽐较，结果应该是1；</li>
<li>如果规则是“将数字转成字符串”，那么就是做字符串⽐较，结果应该是0。</li>
</ol>
<h2 id="隐式字符编码转换"><a href="#隐式字符编码转换" class="headerlink" title="隐式字符编码转换"></a>隐式字符编码转换</h2><p>不同表之间字符集不同，可能会导致索引失效。</p>
<p>具体例子可以参见下文，第3小结：<br><a href="/attachments/MySQL实战45讲/18讲为什么这些SQL语句逻辑相同，性能却差异巨大.pdf" target="_blank">为什么这些SQL语句逻辑相同，性能却差异巨大？</a></p>
<h1 id="为什么我只查一行的语句，也执行这么慢？"><a href="#为什么我只查一行的语句，也执行这么慢？" class="headerlink" title="为什么我只查一行的语句，也执行这么慢？"></a>为什么我只查一行的语句，也执行这么慢？</h1><h2 id="查询长时间不返回"><a href="#查询长时间不返回" class="headerlink" title="查询长时间不返回"></a>查询长时间不返回</h2><p>等MDL锁<br>等flush<br>等⾏锁</p>
<h2 id="查询慢"><a href="#查询慢" class="headerlink" title="查询慢"></a>查询慢</h2><p>详细排查过程参见：<a href="/attachments/MySQL实战45讲/19讲为什么我只查一行的语句，也执行这么慢.pdf" target="_blank">为什么我只查一行的语句，也执行这么慢？</a></p>
<h1 id="幻读是什么，幻读有什么问题？"><a href="#幻读是什么，幻读有什么问题？" class="headerlink" title="幻读是什么，幻读有什么问题？"></a>幻读是什么，幻读有什么问题？</h1><h2 id="如何解决幻读？"><a href="#如何解决幻读？" class="headerlink" title="如何解决幻读？"></a>如何解决幻读？</h2><p>产⽣幻读的原因是，⾏锁只能锁住⾏，但是新插⼊记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB只好引⼊新的锁，也就是间隙锁(Gap Lock)。</p>
<p>间隙锁和⾏锁合称next-key lock，每个next-key lock是前开后闭区间。</p>
<p>间隙锁是在可重复读隔离级别下才会⽣效的。所以，你如果把隔离级别设置为读提交的话，就没有间隙锁了。但同时，你要解决可能出现的数据和⽇志不⼀致问题，需要把binlog格式设置为row。这，也是现在不少公司使⽤的配置组合。</p>
<h1 id="为什么我只改⼀⾏的语句，锁这么多？"><a href="#为什么我只改⼀⾏的语句，锁这么多？" class="headerlink" title="为什么我只改⼀⾏的语句，锁这么多？"></a>为什么我只改⼀⾏的语句，锁这么多？</h1><p>加锁规则⾥⾯，包含了两个“原则”、两个“优化”和⼀个“bug”。</p>
<ol>
<li>原则1：<font color="DeepPink"><strong>加锁的基本单位是next-key lock</strong></font>。希望你还记得，next-key lock是前开后闭区间。</li>
<li>原则2：查找过程中访问到的对象才会加锁。</li>
<li>优化1：索引上的等值查询，给唯⼀索引加锁的时候，next-key lock退化为⾏锁。</li>
<li>优化2：索引上的等值查询，向右遍历时且最后⼀个值不满⾜等值条件的时候，next-key lock退化为间隙锁。</li>
<li>⼀个bug：唯⼀索引上的范围查询会访问到不满⾜条件的第⼀个值为⽌。</li>
</ol>
<blockquote>
<p>MySQL后⾯的版本可能会改变加锁策略，所以这个规则只限于截⽌到现在的最新版本，即5.x系列&lt;=5.7.24，8.0系列&lt;=8.0.13。</p>
</blockquote>
<p>间隙锁、⾏锁、next-key lock案例分析：<a href="/attachments/MySQL实战45讲/21讲为什么我只改一行的语句，锁这么多.pdf" target="_blank">为什么我只改一行的语句，锁这么多？</a></p>
<h1 id="MySQL有哪些“饮鸩⽌渴”提⾼性能的⽅法"><a href="#MySQL有哪些“饮鸩⽌渴”提⾼性能的⽅法" class="headerlink" title="MySQL有哪些“饮鸩⽌渴”提⾼性能的⽅法"></a>MySQL有哪些“饮鸩⽌渴”提⾼性能的⽅法</h1><ul>
<li>短连接风暴<ul>
<li>先处理掉那些占着连接但是不⼯作的线程</li>
<li>减少连接过程的消耗</li>
</ul>
</li>
<li>慢查询性能问题<ul>
<li>索引没有设计好</li>
<li>语句没写好</li>
</ul>
</li>
<li>QPS突增问题</li>
</ul>
<p>更加详细的处理方法参见：<a href="/attachments/MySQL实战45讲/22讲MySQL有哪些“饮鸩止渴”提高性能的方法.pdf" target="_blank">MySQL有哪些“饮鸩止渴”提高性能的方法</a></p>
<h1 id="MySQL是怎么保证数据不丢的？"><a href="#MySQL是怎么保证数据不丢的？" class="headerlink" title="MySQL是怎么保证数据不丢的？"></a>MySQL是怎么保证数据不丢的？</h1><p>WAL机制主要得益于两个⽅⾯：</p>
<ol>
<li>redo log 和 binlog都是顺序写，磁盘的顺序写⽐随机写速度要快；</li>
<li>组提交机制，可以⼤幅度降低磁盘的IOPS消耗。</li>
</ol>
<p>事务执⾏期间，还没到提交阶段，如果发⽣crash的话，redo log肯定丢了，这会不会导致主备不⼀致呢？<br>回答：不会。因为这时候binlog 也还在binlog cache⾥，没发给备库。crash以后redo log和binlog都没有了，从业务⻆度看这个事务也没有提交，所以数据是⼀致的。</p>
<p><a href="/attachments/MySQL实战45讲/23讲MySQL是怎么保证数据不丢的.pdf" target="_blank">MySQL是怎么保证数据不丢的？</a></p>
<h1 id="MySQL是怎么保证主备一致的？"><a href="#MySQL是怎么保证主备一致的？" class="headerlink" title="MySQL是怎么保证主备一致的？"></a>MySQL是怎么保证主备一致的？</h1><p><a href="/attachments/MySQL实战45讲/24讲MySQL是怎么保证主备一致的.pdf" target="_blank">MySQL是怎么保证主备一致的？</a></p>
<h1 id="MySQL是怎么保证高可用的？"><a href="#MySQL是怎么保证高可用的？" class="headerlink" title="MySQL是怎么保证高可用的？"></a>MySQL是怎么保证高可用的？</h1><p><a href="/attachments/MySQL实战45讲/25讲MySQL是怎么保证高可用的.pdf" target="_blank">MySQL是怎么保证高可用的？</a></p>
<h1 id="备库为什么会延迟好几个小时？"><a href="#备库为什么会延迟好几个小时？" class="headerlink" title="备库为什么会延迟好几个小时？"></a>备库为什么会延迟好几个小时？</h1><ul>
<li>MySQL 5.5版本的并⾏复制策略<ul>
<li>按表分发策略</li>
<li>按⾏分发策略</li>
</ul>
</li>
<li>MySQL 5.6版本的并⾏复制策略</li>
<li>MariaDB的并⾏复制策略</li>
<li>MySQL 5.7的并⾏复制策略</li>
<li>MySQL 5.7.22的并⾏复制策略</li>
</ul>
<p><a href="/attachments/MySQL实战45讲/26讲备库为什么会延迟好几个小时.pdf" target="_blank">备库为什么会延迟好几个小时？</a></p>
<h1 id="主库出问题了从库怎么办？"><a href="#主库出问题了从库怎么办？" class="headerlink" title="主库出问题了从库怎么办？"></a>主库出问题了从库怎么办？</h1><ul>
<li>基于位点的主备切换</li>
<li>GTID</li>
<li>基于 GTID 的主备切换</li>
<li>GTID 和在线 DDL</li>
</ul>
<p><a href="/attachments/MySQL实战45讲/27讲主库出问题了从库怎么办.pdf" target="_blank">主库出问题了从库怎么办？</a></p>
<h1 id="读写分离有哪些坑？"><a href="#读写分离有哪些坑？" class="headerlink" title="读写分离有哪些坑？"></a>读写分离有哪些坑？</h1><ul>
<li>强制走主库方案</li>
<li>sleep 方案</li>
<li>判断主备无延迟方案</li>
<li>配合 semi-sync 方案</li>
<li>等主库位点方案</li>
<li>等 GTID 方案</li>
</ul>
<p><a href="/attachments/MySQL实战45讲/28讲读写分离有哪些坑.pdf" target="_blank">读写分离有哪些坑？</a></p>
<h1 id="如何判断一个数据库是不是出问题了？"><a href="#如何判断一个数据库是不是出问题了？" class="headerlink" title="如何判断一个数据库是不是出问题了？"></a>如何判断一个数据库是不是出问题了？</h1><ul>
<li>select 1 判断</li>
<li>查表判断</li>
<li>更新判断</li>
<li>内部统计</li>
</ul>
<p><a href="/attachments/MySQL实战45讲/29讲如何判断一个数据库是不是出问题了.pdf" target="_blank">如何判断一个数据库是不是出问题了？</a></p>
<h1 id="误删数据后除了跑路还能怎么办？"><a href="#误删数据后除了跑路还能怎么办？" class="headerlink" title="误删数据后除了跑路还能怎么办？"></a>误删数据后除了跑路还能怎么办？</h1><ul>
<li>误删行</li>
<li>误删库/表</li>
<li>延迟复制备库</li>
<li>预防误删库/表的方法</li>
<li>rm 删除数据</li>
</ul>
<p><a href="/attachments/MySQL实战45讲/31讲误删数据后除了跑路还能怎么办.pdf" target="_blank">误删数据后除了跑路还能怎么办？</a></p>
<h1 id="为什么还有kill不掉的语句？"><a href="#为什么还有kill不掉的语句？" class="headerlink" title="为什么还有kill不掉的语句？"></a>为什么还有kill不掉的语句？</h1><p><a href="/attachments/MySQL实战45讲/32讲为什么还有kill不掉的语句.pdf" target="_blank">为什么还有kill不掉的语句？</a></p>
<h1 id="关于Join"><a href="#关于Join" class="headerlink" title="关于Join"></a>关于Join</h1><p><a href="/attachments/MySQL实战45讲/34讲到底可不可以使用join.pdf" target="_blank">到底可不可以使用join？</a></p>
<p><a href="/attachments/MySQL实战45讲/35讲join语句怎么优化.pdf" target="_blank">join语句怎么优化？</a></p>
<h1 id="自增主键为什么不是连续的？"><a href="#自增主键为什么不是连续的？" class="headerlink" title="自增主键为什么不是连续的？"></a>自增主键为什么不是连续的？</h1><p>在 MyISAM 引擎里面，自增值是被写在数据文件上的。而在 InnoDB 中，自增值是被记录在内存的。 MySQL 直到 8.0 版本，才给 InnoDB 表的自增值加上了持久化的能力，确保重启前后一个表的自增值不变。</p>
<p><a href="/attachments/MySQL实战45讲/39讲自增主键为什么不是连续的.pdf" target="_blank">自增主键为什么不是连续的？</a></p>
<h1 id="insert语句的锁为什么这么多？"><a href="#insert语句的锁为什么这么多？" class="headerlink" title="insert语句的锁为什么这么多？"></a>insert语句的锁为什么这么多？</h1><p>insert … select  是很常见的在两个表之间拷贝数据的方法。你需要注意，在可重复读隔离级别下，这个语句会给 select 的表里扫描到的记录和间隙加读锁。<br>而如果 insert 和 select 的对象是同一个表，则有可能会造成循环写入。这种情况下，我们需要引入用户临时表来做优化。<br>insert  语句如果出现唯一键冲突，会在冲突的唯一值上加共享的 next-key lock(S 锁 ) 。因此，碰到由于唯一键约束导致报错后，要尽快提交或回滚事务，避免加锁时间过长。</p>
<p>读到41</p>

    </div>

    
    
    
      
  <div class="popular-posts-header">推荐阅读</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="\fun-talk-about-network-protocols.html" rel="bookmark">趣谈网络协议 学习笔记</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="\linux-performance-optimization-practices-notes.html" rel="bookmark">Linux性能优化实战 笔记</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="\mysql-innodb-consistent-nonlocking-read.html" rel="bookmark">MySQL InnoDB存储引擎：一致性非锁定读</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="\mysql-innodb-row-lock-algorithm.html" rel="bookmark">MySQL InnoDB存储引擎：行锁的3种算法</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="\mysql-innodb-consistent-locking-read.html" rel="bookmark">MySQL InnoDB存储引擎：一致性锁定读</a></div>
      
    </li>
  
  </ul>

        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center;">
  <img id="wechat_subscriber_qcode" src="/images/wechat/wechat.jpg" alt="jiankunking wechat" style="width: 200px; max-width: 100%;">
  <div>喜欢就关注一下呗</div>
</div>

      
        
      
        <div id="reward-container">
  <div></div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
        
      
      <div style="display: inline-block">
        <img src="/images/reward/wechatpay.png" alt="jiankunking 微信支付">
        <p>微信支付</p>
      </div>
        
      
      <div style="display: inline-block">
        <img src="/images/reward/alipay.jpg" alt="jiankunking 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

      
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>jiankunking</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://jiankunking.com/45-lectures-on-mysql-in-practice-notes.html" title="MySQL实战45讲 学习笔记">https://jiankunking.com/45-lectures-on-mysql-in-practice-notes.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-ND</a> 许可协议。转载请注明出处！</li>
</ul>
</div>

      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/读书笔记/" rel="tag"># 读书笔记</a>
            
              <a href="/tags/原创/" rel="tag"># 原创</a>
            
              <a href="/tags/MySQL/" rel="tag"># MySQL</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/tcp-state-diagram.html" rel="next" title="TCP 状态图">
                  <i class="fa fa-chevron-left"></i> TCP 状态图
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/sentry-high-availability-deploy.html" rel="prev" title="Sentry 高可用部署">
                  Sentry 高可用部署 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="comments"></div>
  

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基础架构：一条SQL查询语句是如何执行的？"><span class="nav-number">1.</span> <span class="nav-text">基础架构：一条SQL查询语句是如何执行的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#日志系统：一条SQL更新语句是如何执行的？"><span class="nav-number">2.</span> <span class="nav-text">日志系统：一条SQL更新语句是如何执行的？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#重要的⽇志模块：redo-log"><span class="nav-number">2.1.</span> <span class="nav-text">重要的⽇志模块：redo log</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重要的⽇志模块：binlog"><span class="nav-number">2.2.</span> <span class="nav-text">重要的⽇志模块：binlog</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#两阶段提交"><span class="nav-number">2.3.</span> <span class="nav-text">两阶段提交</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#事务隔离：为什么你改了我还看不见？"><span class="nav-number">3.</span> <span class="nav-text">事务隔离：为什么你改了我还看不见？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#事务隔离的实现"><span class="nav-number">3.1.</span> <span class="nav-text">事务隔离的实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#深入浅出索引（上）"><span class="nav-number">4.</span> <span class="nav-text">深入浅出索引（上）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB-的索引模型"><span class="nav-number">4.1.</span> <span class="nav-text">InnoDB 的索引模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引维护"><span class="nav-number">4.2.</span> <span class="nav-text">索引维护</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#深⼊浅出索引（下）"><span class="nav-number">5.</span> <span class="nav-text">深⼊浅出索引（下）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#覆盖索引"><span class="nav-number">5.1.</span> <span class="nav-text">覆盖索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引下推"><span class="nav-number">5.2.</span> <span class="nav-text">索引下推</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#全局锁和表锁"><span class="nav-number">6.</span> <span class="nav-text">全局锁和表锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#全局锁"><span class="nav-number">6.1.</span> <span class="nav-text">全局锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#表级锁"><span class="nav-number">6.2.</span> <span class="nav-text">表级锁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#⾏锁"><span class="nav-number">7.</span> <span class="nav-text">⾏锁</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#事务到底是隔离的还是不隔离的？"><span class="nav-number">8.</span> <span class="nav-text">事务到底是隔离的还是不隔离的？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#“快照”在MVCC⾥是怎么⼯作的？"><span class="nav-number">8.1.</span> <span class="nav-text">“快照”在MVCC⾥是怎么⼯作的？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#普通索引和唯一索引，应该怎么选择"><span class="nav-number">9.</span> <span class="nav-text">普通索引和唯一索引，应该怎么选择?</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#查询过程"><span class="nav-number">9.1.</span> <span class="nav-text">查询过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更新过程"><span class="nav-number">9.2.</span> <span class="nav-text">更新过程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL为什么有时候会选错索引"><span class="nav-number">10.</span> <span class="nav-text">MySQL为什么有时候会选错索引?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#怎么给字符串字段加索引？"><span class="nav-number">11.</span> <span class="nav-text">怎么给字符串字段加索引？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#为什么我的MySQL会“抖”一下？"><span class="nav-number">12.</span> <span class="nav-text">为什么我的MySQL会“抖”一下？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB刷脏页的控制策略"><span class="nav-number">12.1.</span> <span class="nav-text">InnoDB刷脏页的控制策略</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#为什么表数据删掉一半，表文件大小不变？"><span class="nav-number">13.</span> <span class="nav-text">为什么表数据删掉一半，表文件大小不变？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#count-这么慢，我该怎么办？"><span class="nav-number">14.</span> <span class="nav-text">count()这么慢，我该怎么办？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#count-的实现⽅式"><span class="nav-number">14.1.</span> <span class="nav-text">count(*)的实现⽅式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不同的count⽤法"><span class="nav-number">14.2.</span> <span class="nav-text">不同的count⽤法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#答疑：日志和索引相关问题"><span class="nav-number">15.</span> <span class="nav-text">答疑：日志和索引相关问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#“order-by”是怎么工作的？"><span class="nav-number">16.</span> <span class="nav-text">“order by”是怎么工作的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#为什么这些SQL语句逻辑相同，性能却差异巨大？"><span class="nav-number">17.</span> <span class="nav-text">为什么这些SQL语句逻辑相同，性能却差异巨大？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#隐式类型转换"><span class="nav-number">17.1.</span> <span class="nav-text">隐式类型转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#隐式字符编码转换"><span class="nav-number">17.2.</span> <span class="nav-text">隐式字符编码转换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#为什么我只查一行的语句，也执行这么慢？"><span class="nav-number">18.</span> <span class="nav-text">为什么我只查一行的语句，也执行这么慢？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#查询长时间不返回"><span class="nav-number">18.1.</span> <span class="nav-text">查询长时间不返回</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查询慢"><span class="nav-number">18.2.</span> <span class="nav-text">查询慢</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#幻读是什么，幻读有什么问题？"><span class="nav-number">19.</span> <span class="nav-text">幻读是什么，幻读有什么问题？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#如何解决幻读？"><span class="nav-number">19.1.</span> <span class="nav-text">如何解决幻读？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#为什么我只改⼀⾏的语句，锁这么多？"><span class="nav-number">20.</span> <span class="nav-text">为什么我只改⼀⾏的语句，锁这么多？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL有哪些“饮鸩⽌渴”提⾼性能的⽅法"><span class="nav-number">21.</span> <span class="nav-text">MySQL有哪些“饮鸩⽌渴”提⾼性能的⽅法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL是怎么保证数据不丢的？"><span class="nav-number">22.</span> <span class="nav-text">MySQL是怎么保证数据不丢的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL是怎么保证主备一致的？"><span class="nav-number">23.</span> <span class="nav-text">MySQL是怎么保证主备一致的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL是怎么保证高可用的？"><span class="nav-number">24.</span> <span class="nav-text">MySQL是怎么保证高可用的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#备库为什么会延迟好几个小时？"><span class="nav-number">25.</span> <span class="nav-text">备库为什么会延迟好几个小时？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#主库出问题了从库怎么办？"><span class="nav-number">26.</span> <span class="nav-text">主库出问题了从库怎么办？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#读写分离有哪些坑？"><span class="nav-number">27.</span> <span class="nav-text">读写分离有哪些坑？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如何判断一个数据库是不是出问题了？"><span class="nav-number">28.</span> <span class="nav-text">如何判断一个数据库是不是出问题了？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#误删数据后除了跑路还能怎么办？"><span class="nav-number">29.</span> <span class="nav-text">误删数据后除了跑路还能怎么办？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#为什么还有kill不掉的语句？"><span class="nav-number">30.</span> <span class="nav-text">为什么还有kill不掉的语句？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#关于Join"><span class="nav-number">31.</span> <span class="nav-text">关于Join</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#自增主键为什么不是连续的？"><span class="nav-number">32.</span> <span class="nav-text">自增主键为什么不是连续的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#insert语句的锁为什么这么多？"><span class="nav-number">33.</span> <span class="nav-text">insert语句的锁为什么这么多？</span></a></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar/avatar.png"
      alt="jiankunking">
  <p class="site-author-name" itemprop="name">jiankunking</p>
  <div class="site-description" itemprop="description">愿我所遇之人，所历之事，哪怕因为我有一点点变好，我就心满意足了。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">81</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">113</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/jiankunking" title="GitHub &rarr; https://github.com/jiankunking" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
  </div>
  <div class="cc-license motion-element" itemprop="license">
    
  
    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-nd.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-book"></i>
      推荐阅读
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/jiankunking" title="https://blog.csdn.net/jiankunking" rel="noopener" target="_blank">CSDN博客</a>
        </li>
      
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright"><a href="http://www.beian.miit.gov.cn" rel="noopener" target="_blank">鲁ICP备18016400号-1 </a>
  <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=" rel="noopener" target="_blank"> </a>&copy; 2019 – <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jiankunking</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">581k</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
  
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.1"></script><script src="/js/motion.js?v=7.4.1"></script>
<script src="/js/schemes/muse.js?v=7.4.1"></script>
<script src="/js/next-boot.js?v=7.4.1"></script>



  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>








  <script src="/js/local-search.js?v=7.4.1"></script>














  

  

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: true,
    notify: false,
    appId: '6Qd847qBRIzFk0sECwvtfgI2-9Nh9j0Va',
    appKey: 'a2veKRXyF7edg7bijbnArVof',
    placeholder: '有啥疑问、心得，交流一下呗',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: 'zh-cn' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);
</script>

</body>
</html>
