<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>API网关架构设计</title>
      <link href="/api-gateway-design.html"/>
      <url>/api-gateway-design.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>构建一个API网关</p></blockquote><a id="more"></a><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>API Gateway一个比较广泛的定义如下：</p><blockquote><p>API网关是一个服务器，是系统的唯一入口。从面向对象设计的角度看，它与外观模式类似。API网关封装了系统内部架构，为每个客户端提供一个定制的API。<br>API网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。通常，网关也是提供REST/HTTP的访问API。服务端通过API-GW注册和管理服务。</p></blockquote><p>从定义中可以归纳出一下几个核心点：</p><ol><li>服务调用的统一入口</li><li>AuthN（Authentication is establishing the your identity.）</li><li>AuthZ （Authorization is establishing your privileges.）</li><li>监控（请求延迟、异常数、审计日志、访问日志）</li><li>高可用</li><li>白名单、黑名单</li><li>限流</li><li>熔断</li><li>服务发现</li><li>协议支持 （协议转换）</li><li>…</li></ol><h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img alt data-src="/images/api-gateway-design/API-Gateway.png"></p><p>介绍几个概念：</p><ol><li><p>先说RC（Replication Controller）是什么？</p><p> RC保证在同一时间能够运行指定数量的Pod副本，保证Pod总是可用。如果实际Pod数量比指定的多就结束掉多余的，如果实际数量比指定的少就启动缺少的。当Pod失败、被删除或被终结时RC会自动创建新的Pod来保证副本数量。所以即使只有一个Pod也应该使用RC来进行管理。</p></li><li><p>HPA<br> Horizontal Pod Autoscaling，简称HPA，是Kubernetes中实现POD水平自动伸缩的功能。</p><p> HPA是kubernetes里面pod弹性伸缩的实现,它能根据设置的监控阀值进行pod的弹性扩缩容，目前默认HPA只能支持cpu和内存的阀值检测扩缩容，但也可以通过custom metric api 调用prometheus实现自定义metric 来更加灵活的监控指标实现弹性伸缩。</p></li></ol><h1 id="取舍"><a href="#取舍" class="headerlink" title="取舍"></a>取舍</h1><p>取舍也就是如何构建适合自己的API Gateway？</p><p>其实，这个问题也可以拓展为如何开发适应自己业务的某系统，个人感觉应该从以下几点考虑：</p><ul><li>自己的业务系统需要什么样的功能？</li><li>业界中该类系统都是如何实现的？</li><li>自己的基础设施情况（主要是PaaS及中间件）如何？</li></ul><p>综合1、2考虑，在满足业务需求的前提下，往远了考虑，往简单了实现（既满足目前的功能，又方便以后拓展）。<br>回到API Gateway这个话题，那就需要考虑一下，自己的业务系统是否需要以上列出的所有功能点？如果不是或者目前不是，那我应该先实现哪一部分？</p><p>其中，作为一个Gateway，以下几点应该是基础功能：</p><ul><li>服务调用的统一入口</li><li>AuthN（Authentication is establishing the your identity.）</li><li>AuthZ （Authorization is establishing your privileges.）</li><li>监控（请求延迟、异常数、审计日志、访问日志）</li><li>高可用</li></ul><p>剩下的功能实现就要看业务需要及时间了。<br>如果系统本身的访问量不大，那么限流、熔断是否就可以先不实现？</p><h2 id="为什么需要关注自己的基础设施情况（主要是PaaS及中间件）？"><a href="#为什么需要关注自己的基础设施情况（主要是PaaS及中间件）？" class="headerlink" title="为什么需要关注自己的基础设施情况（主要是PaaS及中间件）？"></a>为什么需要关注自己的基础设施情况（主要是PaaS及中间件）？</h2><p>比如基础设施中已提供Kubernetes集群服务，那么毫无疑问的高可用方案，应该选择RC方案。如果没有Kubernetes集群服务，那么高可用就需要考虑别的方案了。</p><blockquote><p>可以发现其实手撕一个api网关，也不是多么难的事情，其中很多点，底层包都已经提供了支持，只是需要支持的功能比较多。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Architecture </tag>
            
            <tag> Gateway </tag>
            
            <tag> Design </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志服务架构设计</title>
      <link href="/log-service-architecture-design.html"/>
      <url>/log-service-architecture-design.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>在满足业务需求的前提下，代码、架构，越简单，越稳定。</p></blockquote><a id="more"></a><p>最近想把之前做过的日志项目及个人的思考梳理一下，于是有了本文。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我们这边应用部署的环境比较复杂，主要有以下几种：</p><ul><li>机器直接部署</li><li>通过原生docker部署</li><li>通过kubernates集群部署</li></ul><p>部署环境不统一，导致查看应用日志很不方便。</p><h1 id="业务需求"><a href="#业务需求" class="headerlink" title="业务需求"></a>业务需求</h1><p>与部署环境对应，对于日志收集需求分为以下几类：</p><ul><li>机器上的文本日志（直接运行在物理机或者虚拟机中的应用日志）</li><li>运行在docker容器中的应用日志</li><li>运行在kubernates集群中的应用日志</li></ul><p>具体业务需求可以拆分为：</p><ul><li>按照项目、应用、实例维度检索日志并支持搜索关键字高亮（因为大家检索日志的时候，肯定是检索某个项目、某个应用、某个实例的日志）</li><li>支持检索出某条想要的日志后，可以查看上下文（查看该日志所在日志文件的日志上下文）</li><li>支持日志下载（目前支持两种场景：搜索结果下载、上下文下载；支持两种方式：在线下载、离线下载）</li><li>支持自动化批量部署、卸载Agent，部署、卸载过程可视化</li><li>单实例支持多elasticsearch集群</li><li>支持文本日志、docker日志、k8s日志并能与将日志与其业务意义对应上。（即不管是哪种日志形式、来源，最终都需要与业务意义上的项目、应用、实例对应起来，因为对于日志的使用者来说，查询日志的出发点肯定是查询某个项目、某个应用（可以不选）、某个实例（可以不选）、某段时间的日志。）</li><li>支持部署到业务自己的集群中</li></ul><p>需求已经明确了，下面看一下业界方案。</p><h1 id="业界日志系统架构"><a href="#业界日志系统架构" class="headerlink" title="业界日志系统架构"></a>业界日志系统架构</h1><p><img alt data-src="/images/log-service-architecture-design/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png"></p><ul><li>Collector的作用是：<ul><li>清洗、汇聚数据，减少对于后端集群的压力。</li><li>安全，不允许Agent直连kafka等内部集群，保证一定的安全性，即使后端发生调整也能保证对于Agent连接、认证方式的稳定。</li></ul></li><li>MQ的作用是削峰填谷、解耦、多次消费。</li></ul><p>上图的架构是业界比较通用的一种架构，对于各种场景都考虑的比较全。</p><p>既然业界的架构已经这么完备，那么我们是否就直接采用呢？</p><p>对于我们而言，有以下几个问题：</p><ul><li>涉及的组件比较多，链路比较长，运维比较麻烦</li><li>这一整套架构，不利于单独部署（比如某个业务应用部署机房网络是隔离的，而且项目又不大，只能提供有限的几台机器，这时候如果需要部署业界这套架构的话，资源就会比较受限，如果想做到即支持业界架构组件的可插拔（比如可灵活的决定是否需要Collector、MQ），那么就需要运维几套配置或代码）</li><li>最关键的就是其中组件提供的功能，我们目前用不到。比如MQ的削峰填谷、多次消费。</li></ul><h1 id="组件选择"><a href="#组件选择" class="headerlink" title="组件选择"></a>组件选择</h1><p>选择组件，我们这边主要是从以下几个方面进行考量的：</p><ol><li>组件对应的开源生态完整、活跃度高</li><li>对应的技术栈是我们所熟悉的，我们这边语言技术栈主要是Java、Go，如果组件语言是C、Ruby，应该就被排除了。</li><li>运维成本</li><li>易部署、性能好</li></ol><h2 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h2><p>一提到日志收集方案，大家第一个想到的肯定是ELK(Elasticsearch、Logstash、Kibana )，但Logstash依赖于JVM不管是性能还是简洁性，都不是日志收集agent的首选。</p><p>个人感觉一个好的agent应该是资源占用少，性能好，不依赖别的组件，可以独立部署。而Logstash明显不符合这几点要求，也许正是基于这些考虑elastic推出了Filebeat。</p><h2 id="Collector、MQ"><a href="#Collector、MQ" class="headerlink" title="Collector、MQ"></a>Collector、MQ</h2><p>Elasticsearch集群在部署的时候，一般都是提前估计好容量、机器、shard等信息，因为Elasticsearch集群运行后，再水平拓展，比较麻烦，而我们这边由于业务及成本限制无法很好的预估容量，所以就结合公司实际要求：使用日志服务的业务方自带机器，也就是业务方会有独立的Elasticsearch集群。</p><p>每个业务方都使用自己的Elasticsearch集群，所以集群压力不会很大，从而Collector、MQ这两个组件对于我们的作用也就很小了。</p><h2 id="ETL"><a href="#ETL" class="headerlink" title="ETL"></a>ETL</h2><p>因为Elasticsearch Ingest Node完全可以满足我们的解析需求，所以就没有必要再引入Logstash等相关组件了。</p><p>到这里，基本可以看出我们的架构如下：<br><img alt data-src="/images/log-service-architecture-design/%E7%B2%BE%E7%AE%80%E6%9E%B6%E6%9E%84.png"></p><blockquote><p>架构设计的几个原则：</p><ul><li>合适优于业界领先 </li><li>简单优于复杂</li><li>演化优于一步到位</li></ul></blockquote><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>基于需求及EFK套件，梳理我们场景中特有的东西：</p><ul><li>docker日志的场景比较单一，都是通过之前一个产品A发布部署的，其docker命名规则比较统一，可以通过截取docker.container.name来获取应用名字；同时在部署的时候，可以知道部署目标机器的ip，这样就可以通过应用+ip来作为实例名称。</li><li>k8s场景也比较统一，都是通过之前一个产品B发布部署的，其pod命名规则比较统一，可以通过截取kubernetes.pod.name来获取应用名字（但需要通过namespaces关联到tenant，再通过tenant与项目一一对应）；k8s中的pod.name就是唯一的，以此来作为实例名称即可。</li><li>文本日志：因为文本日志主要的场景是已经裸机部署的应用，这种场景下，不存在应用自动迁移的情况，所以文本日志的应用名称、实例名称可以在部署的时候打上标签即可。</li></ul><p>具体规则及解析见下图（实例部分处理暂未标注）：<br><img alt data-src="/images/log-service-architecture-design/%E6%94%B6%E9%9B%86%E5%BA%94%E7%94%A8%E6%96%87%E6%9C%AC%E6%97%A5%E5%BF%97.png"></p><blockquote><p>推荐写日志到文本文件中，使用标准输出就好。</p></blockquote><p>到这里可以发现我们选择Filebeat来作为日志的收集端，Elasticsearch来存储日志并提供检索能力。</p><p>那么，日志的清洗在哪里做呢？</p><p>日志的清洗一般有两种方式：</p><ul><li>先把日志收集到kafka，再通过Logstash消费kafka的数据，来清洗数据</li><li>直接通过Elasticsearch的[Ingest Node]来清洗数据，因为Ingest Node也支持Grok表达式</li></ul><p>对于，我们的场景而言，我们需要清洗数据的要求比较简单，主要是应用、实例名称的截取还有文本日志中日志时间的处理（@timestamp重置，时区处理），所以我们选择了方案2。</p><p>在我们的方案中，并没有提供Kibana 的界面直接给用户用，而是我们自己根据公司业务独立开发的。</p><p>前端界面为什么不采用Kibana，而需要自己开发？</p><ol><li>kibana对于业务开发人员有一定的学习成本</li><li>kibana界面没有很好的将日志内容与业务意义关联起来（界面选择总比一次次的输入要好，这也是我们将日志的项目、应用、实例等业务信息解析出来的原因）</li><li><a href="https://github.com/jiankunking/log-search" target="_blank" rel="noopener">log-search</a>支持Query String，因此对于熟悉kibana的开发人员来说，在我们自己开发的前端界面检索效果是一样的。</li></ol><p><a href="https://github.com/jiankunking/log-search" target="_blank" rel="noopener">log-search</a>提供的功能可以参见github：<a href="https://github.com/jiankunking/log-search" target="_blank" rel="noopener">https://github.com/jiankunking/log-search</a></p><blockquote><p>如果日志需要清洗的比较多，可以采用方案1，或者先不清洗，先把数据落到Elasticsearch，然后在查询的时候，进行处理。比如在我们的场景中，可以先把日志落到Elasticsearch中，然后在需要检索应用名称的时候，通过代码来处理并获取app名字。</p></blockquote><h1 id="监控、告警"><a href="#监控、告警" class="headerlink" title="监控、告警"></a>监控、告警</h1><p>其实基于日志可以做很多事情，比如：</p><ul><li>基于日志做监控（Google Dapper）</li><li>基于日志做告警</li><li>基于日志做Machine Learning</li></ul><p>具体思路，可以参见下图：</p><p><img alt data-src="/images/log-service-architecture-design/%E5%9F%BA%E4%BA%8E%E6%97%A5%E5%BF%97%E7%9A%84%E7%9B%91%E6%8E%A7%E3%80%81%E5%91%8A%E8%AD%A6.png"></p><blockquote><p>前提：能要求使用方，按照某种规则打印日志。<br>监控发展：监控基本就是先打通链路trace，然后再在上报信息或者日志信息中，加强业务方面标识，即给监控添加业务维度方面的视角。</p></blockquote><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h2><p>以DaemonSet方式部署Filebeat来收集日志，其实收集也是宿主机/var/lib/docker/containers目录下的日志。<br>Running Filebeat on Kubernetes</p><h2 id="Sidecar"><a href="#Sidecar" class="headerlink" title="Sidecar"></a>Sidecar</h2><p>一个POD中运行一个sidecar的日志agent容器，用于采集该POD主容器产生的日志。</p><p>莫名想起了istio。</p><blockquote><p>Filebeat可以以sidecar模式来进行容器日志的收集，也就是filebeat和具体的服务容器部署在同一个pod内，指定收集日志的路径或文件，&gt; 即可将日志发送到指定位置或Elasticsearch这类的搜索引擎。<br>每个pod内部署filebeat的模式，好处是和具体的应用服务低耦合，可扩展性强，不过需要在yaml进行额外配置。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Architecture </tag>
            
            <tag> Log </tag>
            
            <tag> Elasticsearch </tag>
            
            <tag> Filebeat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异地多活高可用架构设计</title>
      <link href="/multi-live-high-available-architecture-design.html"/>
      <url>/multi-live-high-available-architecture-design.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果构建应用的异地多活？</p></blockquote><a id="more"></a><h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>随着业务的快速发展，对于很多公司来说，构建于单地域的技术体系架构，会面临诸如下面的多种问题：础设施的有限性限制了业务的可扩展性；机房、城市级别的故障灾害，影响服务的可持续性。</p><p>为解决遇到的这些问题，公司可以选择构建异地多活架构，在同城/异地构建多个单元(业务中心)。各个业务单元可以分布在不同的地域，从而有效解决了单地域部署带来的基础设施的扩展限制、服务可持续性。</p><p>异地多活是近几年比较热门的一个话题，那么在实际业务中什么时候需要去做这件事？如何去做？做的时候需要考虑什么？</p><h2 id="何时去做？"><a href="#何时去做？" class="headerlink" title="何时去做？"></a>何时去做？</h2><p>个人感觉取决于以下几个方面：</p><ul><li>业务发展</li><li>基础设施状况</li><li>技术积淀</li></ul><h2 id="如何做？"><a href="#如何做？" class="headerlink" title="如何做？"></a>如何做？</h2><p>目前在网上搜索到的异地多活方案来看，基本都是阿里、饿了么、京东、微博这些互联网大厂的实践，这些大厂的方案有一个共同点就是：大量的自研组件，来做相关的数据同步，业务切分等等，那么，对于很多传统企业或者相对小一些的企业，应该如何来做这件事？</p><ul><li>根据业务特性借助合适的公有云服务</li></ul><h2 id="做的时候，需要注意什么？"><a href="#做的时候，需要注意什么？" class="headerlink" title="做的时候，需要注意什么？"></a>做的时候，需要注意什么？</h2><ul><li>真正需要做异地多活的业务有哪些？</li><li>基础设施如何？</li><li>对于不可用时间的容忍程度是多少？</li></ul><h1 id="业务背景"><a href="#业务背景" class="headerlink" title="业务背景"></a>业务背景</h1><ul><li>在所有的系统中用户中心都是核心业务，因为它是进入其它很多业务前提。</li><li>我们这边IDC不是很稳定，之前发生过几次机房大规模故障，比如机房网络挂了，整个机房对外不可用了。</li></ul><p>以上两点是我们这次要做用户中心异地容灾的出发点，以便在面对机房级别故障时，保证服务可用性。</p><h1 id="业务梳理"><a href="#业务梳理" class="headerlink" title="业务梳理"></a>业务梳理</h1><p>用户中心从整体来看，对外主要提供：注册、登陆、查询用户信息等服务。这些服务又有以下几个特点：</p><ul><li>登陆的优先级最高</li><li>事务性要求低</li></ul><p>涉及的公共组件主要有：</p><ul><li>MySQL：用户数据存储</li><li>Redis：Authorization Code、短信验证码、账号锁定、access token等的存储</li><li>Zookeeper：Dubbo依赖</li></ul><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p>用户中心是通过外包的形式进行开发的，目前已上线并交付给另一个外包商运维，所以在考虑容灾一期方案的时候，需要考虑尽量不动代码。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><h3 id="一期目标"><a href="#一期目标" class="headerlink" title="一期目标"></a>一期目标</h3><p>当北京机房出现故障的时候，可以一定时间内把流量切到青岛机房这边，保证用户中心核心服务的基本可用。</p><h3 id="二期目标"><a href="#二期目标" class="headerlink" title="二期目标"></a>二期目标</h3><p>用户中心通过异地多活，实现高可用（需要集团智能DNS支持）。</p><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><h3 id="一期架构"><a href="#一期架构" class="headerlink" title="一期架构"></a>一期架构</h3><p>当北京机房发生故障的时候，可以把流量快速切换到青岛这边，以保障用户中心核心服务可用。</p><p>具体方案如下：</p><ul><li>通过otter近实时的将北京机房核心业务数据同步到青岛机房。</li><li>青岛机房部署Redis、ZooKeeper等中间件。</li><li>青岛机房部署用户中心的核心应用（实例正常部署、运行，只是平时不会有访问）。</li></ul><p>具体架构如下：<br><img alt data-src="/images/multi-live-high-available-architecture-design/%E4%B8%80%E6%9C%9F%E6%9E%B6%E6%9E%84.png"></p><p>可以达到的效果：</p><ul><li>当北京机房出现故障的时候，可以在一定时间内把流量切到青岛机房这边，保证用户中心核心服务的基本可用，但此时已登录用户需要重新登录。</li><li>一定时间：取决于DNS修改ip时间+DNS TTL时间，目前来看TTL是10分钟，人工修改ip应该很快，所以一定时间是10~20分钟。</li></ul><p>存在的缺点：</p><ul><li>北京机房非故障期间，青岛机房的机器，仅做数据库同步，存在一定的资源浪费。</li><li>当北京机房出现故障，流量切换到青岛机房后，只能保证登陆这一核心服务的可用。对于注册等需要修改数据库的服务，均不支持，如果在此期间访问这类服务，会发生异常。</li></ul><h3 id="二期架构"><a href="#二期架构" class="headerlink" title="二期架构"></a>二期架构</h3><p>二期的目的就是修正一期架构的缺点，通过异地多活，实现高可用。</p><p>二期青岛机房会替换为阿里云机房。</p><p>具体方案如下：</p><ul><li>通过阿里云DTS服务实现两地机房数据库同步，保证北京、阿里云数据的近实时一致性。</li><li>北京、阿里云两地机房均提供在线服务，提高资源利用率。</li><li>梳理服务优先级，修改应用代码，支持服务降级。</li><li>当某个机房（阿里云或者北京）出现故障的时候，通过DNS服务把流量切换到另一个机房。<ul><li>如果两地部署的时候，没有冗余一定硬件资源，则需要实施服务降级。</li><li>目前集团DNS解析，无法提供自动检测服务是否可用的功能，也就无法自动进行切换。<ul><li>服务可用性，可以通过我们这边的多点拨测进行监控，当多点拨测不可用的时候，发送告警通知给相关人员，以便人工介入。</li><li>多点拨测告警，应该会提供两类：1、某个拨测点不通的时候 2、所有拨测点均不可用的时候。</li></ul></li><li>目前集团DNS解析，TTL生效最短时间是10分钟，无法自定义TTL时间。</li></ul></li></ul><p>具体架构如下：<br><img alt data-src="/images/multi-live-high-available-architecture-design/%E4%BA%8C%E6%9C%9F%E6%9E%B6%E6%9E%84%E6%99%BA%E8%83%BDDNS.png"></p><p>可以达到的效果：</p><ul><li><p>如果集团DNS可以提供，类似阿里云云解析的网站监控功能并能灵活设置TTL时间，这时当北京机房或者阿里云机房出现故障后，就可以在很短的时间（部分服务最大异常时间）内自动进行流量切换。</p><blockquote><p>此处只是以阿里云云解析示例，只要能提供类似的服务均可。</p></blockquote></li><li><p>如果集团DNS无法提供类似阿里云云解析的网站监控及灵活设置TTL时间的功能，则部分服务最大异常时间还是取决于DNS修改ip时间+DNS TTL时间。</p></li></ul><h4 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h4><h5 id="什么是网站监控？"><a href="#什么是网站监控？" class="headerlink" title="什么是网站监控？"></a>什么是网站监控？</h5><p>HTTP/HTTPS实时探测域名解析记录，支持自定义端口，实时发现宕机立即告警；<br>全网分布式监控，在中国各个地区模拟用户端真实请求，监控结果真实可靠；<br>支持宕机暂停、容灾切换，最大限度的解决服务中断对您的业务带来的损失；<br>容灾切换支持A记录、CNAME域名，满足各种场景的容灾切换需求；</p><h5 id="什么情况会被网站监控判断为宕机并发送告警通知？"><a href="#什么情况会被网站监控判断为宕机并发送告警通知？" class="headerlink" title="什么情况会被网站监控判断为宕机并发送告警通知？"></a>什么情况会被网站监控判断为宕机并发送告警通知？</h5><p>监控结果中，HTTP/HTTPS的返回码大于500的服务器错误情况，才会报警通知。<br>举例说明：如果设置了四个探测点 北京联通、深圳阿里巴巴、上海电信、重庆联通。<br>场景一：四个探测点中50%的监控点无法收到您服务器的响应，或50%的监控点收到返回码大于等于500时，才会判断您的网站为宕机情况。<br>场景二：四个探测点中有50%以上的探测点探测您的网站返回码是小于500的情况，则不会判断您的网站为宕机。</p><h5 id="云解析DNS“流量管理”"><a href="#云解析DNS“流量管理”" class="headerlink" title="云解析DNS“流量管理”"></a>云解析DNS“流量管理”</h5><p>云解析“流量管理”可以在您设置的每条解析线路下，根据权重比例轮询返回解析结果。当线路下的IP宕机时可以通过监控自动发现，并将宕机IP从当前线路下摘除，直到监控IP正常时会恢复解析。同时，当一条解析线路下的所有IP都宕机时，可以切换至其他正常线路。最大程度保证您的网站服务高可用，减小损失。</p><h5 id="部分服务最大异常时间"><a href="#部分服务最大异常时间" class="headerlink" title="部分服务最大异常时间"></a>部分服务最大异常时间</h5><p>比如北京机房出现异常，这时转发到阿里云机房的流量是可以正常访问，只有转发到北京机房的流量是异常的。</p><p>这时如果使用网站监控或者类似服务，进行监控，并设置拨测间隔为1分钟，TTL生效时间为1秒，那么最多有60+1秒部分服务异常时间，之后DNS会自动把北京机房的ip自动踢掉，流量全部切到阿里云。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ol><li><p>一期、二期方案的实现均强依赖于集团的DNS服务</p></li><li><p>用户中心通过ip暴露的服务，一但出现机房级别的故障，一期、二期方案均无法保证该部分服务可用。</p></li><li><p>其实除了DNS这种方案，还有一种方案就是用类似F5这种设备，作跨机房负载，但必须是gslb，而且两端必须是相同的设备。</p></li></ol><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>对于，非一线互联网大厂的公司而言，是实现异地容灾的时候，借助公有云是很有必要的，比如：</p><ul><li><p>数据跨机房同步，可以使用阿里云的DTS(Data Transmission Service) 服务，目前DTS支持关系型数据库、NoSQL、大数据(OLAP)等数据源间的数据传输。 它是一种集数据迁移、数据订阅及数据实时同步于一体的数据传输服务。<br><img alt data-src="/images/multi-live-high-available-architecture-design/%E9%98%BF%E9%87%8C%E4%BA%91DTS%E6%9C%8D%E5%8A%A1.jpg"></p></li><li><p>跨机房分布式数据库，可以使用OceanBase。金融环境下通常对数据可靠性有更高的要求，OceanBase每一次事务提交，对应日志总是会在多个数据中心实时同步，并持久化。即使是数据中心级别的灾难发生，总是可以在其他的数据中心恢复每一笔已经完成的交易，实现了真正金融级别的可靠性要求。</p></li><li><p>异地多活由于各个公司的业务、基础设施及要解决的问题皆不尽相同，所以选择适合自己的就好。</p></li><li><p>或者直接使用云数据库RDS MySQL 版<br><img alt data-src="/images/multi-live-high-available-architecture-design/%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E7%89%88.png"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Architecture </tag>
            
            <tag> Multi-Live </tag>
            
            <tag> High-Available </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PaaS平台架构设计</title>
      <link href="/pass-platform-architecture-design.html"/>
      <url>/pass-platform-architecture-design.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>构建一个PaaS平台</p></blockquote><a id="more"></a><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>目前在用的PaaS平台是之前购买的一个商业产品，但没有源码，运维期也早就结束了，所以在后期使用过程中会遇到一些各种各样的问题，对于使用、运维都造成一定的困扰。</p><p>老PaaS的架构及基本功能如下：<br><img alt data-src="/images/pass-platform-design/%E8%80%81PaaS%E6%9E%B6%E6%9E%84.png"></p><h1 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h1><p>为什么选择重构PaaS平台而不是全部迁移kubernates集群？<br>kubernates集群的确提供了很多优秀的特性，比如：RC、滚动更新或回滚、资源监控和日志记录、负载均衡等等。</p><p>但在目前我们这边的环境来看，迁移kubernates集群有如下几个问题：</p><ul><li>无法无感知迁移，即迁移到kubernates集群的过程中及迁移到kubernates集群后，不增加用户的使用、学习成本，但应用引入kubernates集群之后，很难保证这一点。因为我们这边的用户大多是我们公司的供应商，供应商其实不太关心，你平台所提供的各种新特性、功能，更不想因为这些新特性、功能增加他们的使用、学习成本。</li><li>我们这边很多项目本身是有硬负载的，比如F5，所以kubernates提供的负载均衡功能，也就显的不那么重要。</li><li>日志部分，我们已经打通各个平台的日志、监控，不再需其他的组件。</li><li>滚动更新或回滚，老PaaS平台木有，重构后新版中准备加入（二期）。</li><li>RC类似功能，目前不打算支持。</li></ul><h2 id="架构及用到组件梳理"><a href="#架构及用到组件梳理" class="headerlink" title="架构及用到组件梳理"></a>架构及用到组件梳理</h2><p><img alt data-src="/images/pass-platform-design/%E6%96%B0PaaS%E6%9E%B6%E6%9E%84%E5%8F%8A%E7%BB%84%E4%BB%B6.png"></p><h2 id="新PaaS功能点梳理"><a href="#新PaaS功能点梳理" class="headerlink" title="新PaaS功能点梳理"></a>新PaaS功能点梳理</h2><p><img alt data-src="/images/pass-platform-design/PaaS%E5%8A%9F%E8%83%BD%E7%82%B9.png"></p><h1 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h1><p>通过无缝迁移，在用户无感知的情况下实现迁移。</p><blockquote><p>为什么要做到无感知迁移？<br>老PaaS中目前的项目数量是：193个，应用数量是：673个<br>总实例数：1485，其中生产环境的实例数：894<br>如果这些项目、应用，因为你的重构都需要改动的话，那么推广难度是很大的，所以需要尽量做到，对于用户来说无感知迁移。</p></blockquote><p>以下迁移部分，都需要在新PaaS上线前完成并在上线一段时间准实时同步过来。<br><img alt data-src="/images/pass-platform-design/%E8%80%81PaaS%E8%BF%81%E7%A7%BB.png"></p>]]></content>
      
      
      <categories>
          
          <category> Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Architecture </tag>
            
            <tag> PaaS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 1.9 Sync Map</title>
      <link href="/go-sync-map.html"/>
      <url>/go-sync-map.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>基于Go 1.9 解析Sync Map</p></blockquote><a id="more"></a><h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><h2 id="Package"><a href="#Package" class="headerlink" title="Package"></a>Package</h2><p><img alt data-src="/images/go-sync-map/package.png"></p><p>本文主要阐述：Load、Store、Delete，更加详细的阐述可以参考源码描述（建议先大体浏览一下Map源码）。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ul><li>空间换时间。 通过冗余的两个数据结构(read、dirty),实现加锁对性能的影响。</li><li>使用只读数据(read)，避免读写冲突。</li><li>动态调整，miss次数多了之后，将dirty数据提升为read。</li><li>double-checking。</li><li>延迟删除。 删除一个键值只是打标记（会将key对应value的pointer置为nil，但read中仍然有这个key:key;value:nil的键值对），只有在提升dirty的时候才清理删除的数据。</li><li>优先从read读取、更新、删除，因为对read的读取不需要锁。</li><li>虽然read和dirty有冗余数据，但这些数据是通过指针指向同一个数据，所以尽管Map的value会很大，但是冗余的空间占用还是有限的。</li></ul><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">// Map is a concurrent map with amortized-constant-time loads, stores, and deletes.</span><br><span class="line">// It is safe for multiple goroutines to call a Map&apos;s methods concurrently.</span><br><span class="line">//</span><br><span class="line">// It is optimized for use in concurrent loops with keys that are</span><br><span class="line">// stable over time, and either few steady-state stores, or stores</span><br><span class="line">// localized to one goroutine per key.</span><br><span class="line">//</span><br><span class="line">// For use cases that do not share these attributes, it will likely have</span><br><span class="line">// comparable or worse performance and worse type safety than an ordinary</span><br><span class="line">// map paired with a read-write mutex.</span><br><span class="line">//</span><br><span class="line">// The zero Map is valid and empty.</span><br><span class="line">//</span><br><span class="line">// A Map must not be copied after first use.</span><br><span class="line"></span><br><span class="line">//该 Map 是线程安全的，读取，插入，删除也都保持着常数级的时间复杂度。</span><br><span class="line">//多个 goroutines 协程同时调用 Map 方法也是线程安全的。该 Map 的零值是有效的，</span><br><span class="line">//并且零值是一个空的 Map 。线程安全的 Map 在第一次使用之后，不允许被拷贝。</span><br><span class="line">type Map struct &#123;</span><br><span class="line">mu Mutex</span><br><span class="line"></span><br><span class="line">// read contains the portion of the map&apos;s contents that are safe for</span><br><span class="line">// concurrent access (with or without mu held).</span><br><span class="line">//</span><br><span class="line">// The read field itself is always safe to load, but must only be stored with</span><br><span class="line">// mu held.</span><br><span class="line">//</span><br><span class="line">// Entries stored in read may be updated concurrently without mu, but updating</span><br><span class="line">// a previously-expunged entry requires that the entry be copied to the dirty</span><br><span class="line">// map and unexpunged with mu held.</span><br><span class="line"></span><br><span class="line"> // 一个只读的数据结构，因为只读，所以不会有读写冲突。</span><br><span class="line">    // 所以从这个数据中读取总是安全的。</span><br><span class="line">    // 实际上，实际也会更新这个数据的entries,如果entry是未删除的(unexpunged), 并不需要加锁。如果entry已经被删除了，需要加锁，以便更新dirty数据。</span><br><span class="line">read atomic.Value // readOnly</span><br><span class="line"></span><br><span class="line">// dirty contains the portion of the map&apos;s contents that require mu to be</span><br><span class="line">// held. To ensure that the dirty map can be promoted to the read map quickly,</span><br><span class="line">// it also includes all of the non-expunged entries in the read map.</span><br><span class="line">//</span><br><span class="line">// Expunged entries are not stored in the dirty map. An expunged entry in the</span><br><span class="line">// clean map must be unexpunged and added to the dirty map before a new value</span><br><span class="line">// can be stored to it.</span><br><span class="line">//</span><br><span class="line">// If the dirty map is nil, the next write to the map will initialize it by</span><br><span class="line">// making a shallow copy of the clean map, omitting stale entries.</span><br><span class="line"></span><br><span class="line">// dirty数据包含当前的map包含的entries,它包含最新的entries(包括read中未删除的数据,虽有冗余，但是提升dirty字段为read的时候非常快，不用一个一个的复制，而是直接将这个数据结构作为read字段的一部分),有些数据还可能没有移动到read字段中。</span><br><span class="line">    // 对于dirty的操作需要加锁，因为对它的操作可能会有读写竞争。</span><br><span class="line">    // 当dirty为空的时候， 比如初始化或者刚提升完，下一次的写操作会复制read字段中未删除的数据到这个数据中。</span><br><span class="line">dirty map[interface&#123;&#125;]*entry</span><br><span class="line"></span><br><span class="line">// misses counts the number of loads since the read map was last updated that</span><br><span class="line">// needed to lock mu to determine whether the key was present.</span><br><span class="line">//</span><br><span class="line">// Once enough misses have occurred to cover the cost of copying the dirty</span><br><span class="line">// map, the dirty map will be promoted to the read map (in the unamended</span><br><span class="line">// state) and the next store to the map will make a new dirty copy.</span><br><span class="line">// 当从Map中读取entry的时候，如果read中不包含这个entry,会尝试从dirty中读取，这个时候会将misses加一，</span><br><span class="line">    // 当misses累积到 dirty的长度的时候， 就会将dirty提升为read,避免从dirty中miss太多次。因为操作dirty需要加锁。</span><br><span class="line">misses int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="readOnly"><a href="#readOnly" class="headerlink" title="readOnly"></a>readOnly</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// readOnly is an immutable struct stored atomically in the Map.read field.</span><br><span class="line">type readOnly struct &#123;</span><br><span class="line">m       map[interface&#123;&#125;]*entry</span><br><span class="line">// true if the dirty map contains some key not in m.</span><br><span class="line">// 如果Map.dirty有些数据不在中的时候，这个值为true</span><br><span class="line">amended bool </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// An entry is a slot in the map corresponding to a particular key.</span><br><span class="line">type entry struct &#123;</span><br><span class="line">// p points to the interface&#123;&#125; value stored for the entry.</span><br><span class="line">//</span><br><span class="line">// If p == nil, the entry has been deleted and m.dirty == nil.</span><br><span class="line">//</span><br><span class="line">// If p == expunged, the entry has been deleted, m.dirty != nil, and the entry</span><br><span class="line">// is missing from m.dirty.</span><br><span class="line">//</span><br><span class="line">// Otherwise, the entry is valid and recorded in m.read.m[key] and, if m.dirty</span><br><span class="line">// != nil, in m.dirty[key].</span><br><span class="line">//</span><br><span class="line">// An entry can be deleted by atomic replacement with nil: when m.dirty is</span><br><span class="line">// next created, it will atomically replace nil with expunged and leave</span><br><span class="line">// m.dirty[key] unset.</span><br><span class="line">//</span><br><span class="line">// An entry&apos;s associated value can be updated by atomic replacement, provided</span><br><span class="line">// p != expunged. If p == expunged, an entry&apos;s associated value can be updated</span><br><span class="line">// only after first setting m.dirty[key] = e so that lookups using the dirty</span><br><span class="line">// map find the entry.</span><br><span class="line"></span><br><span class="line">//p有三种值：</span><br><span class="line">//nil: entry已被删除了，并且m.dirty为nil</span><br><span class="line">//expunged: entry已被删除了，并且m.dirty不为nil，而且这个entry不存在于m.dirty中</span><br><span class="line">//其它： entry是一个正常的值</span><br><span class="line">p unsafe.Pointer // *interface&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Value"><a href="#Value" class="headerlink" title="Value"></a>Value</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// A Value provides an atomic load and store of a consistently typed value.</span><br><span class="line">// Values can be created as part of other data structures.</span><br><span class="line">// The zero value for a Value returns nil from Load.</span><br><span class="line">// Once Store has been called, a Value must not be copied.</span><br><span class="line">//</span><br><span class="line">// A Value must not be copied after first use.</span><br><span class="line">type Value struct &#123;</span><br><span class="line">noCopy noCopy</span><br><span class="line"></span><br><span class="line">v interface&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img alt data-src="/images/go-sync-map/map%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB%E7%A4%BA%E6%84%8F%E5%9B%BE"></p><h1 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h1><p>据指定的key,查找对应的值value,如果不存在，通过ok反映。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">func (m *Map) Load(key interface&#123;&#125;) (value interface&#123;&#125;, ok bool) &#123;</span><br><span class="line">read, _ := m.read.Load().(readOnly)</span><br><span class="line">e, ok := read.m[key]</span><br><span class="line">// 如果没找到，并且m.dirty中有新数据，需要从m.dirty查找，这个时候需要加锁</span><br><span class="line">if !ok &amp;&amp; read.amended &#123;</span><br><span class="line">m.mu.Lock()</span><br><span class="line">// Avoid reporting a spurious miss if m.dirty got promoted while we were</span><br><span class="line">// blocked on m.mu. (If further loads of the same key will not miss, it&apos;s</span><br><span class="line">// not worth copying the dirty map for this key.)</span><br><span class="line">//double check,避免加锁的时候m.dirty提升为m.read,这个时候m.read可能被替换了。</span><br><span class="line">read, _ = m.read.Load().(readOnly)</span><br><span class="line">e, ok = read.m[key]</span><br><span class="line">if !ok &amp;&amp; read.amended &#123;</span><br><span class="line">e, ok = m.dirty[key]</span><br><span class="line">// Regardless of whether the entry was present, record a miss: this key</span><br><span class="line">// will take the slow path until the dirty map is promoted to the read</span><br><span class="line">// map.</span><br><span class="line">m.missLocked()</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">if !ok &#123;</span><br><span class="line">return nil, false</span><br><span class="line">&#125;</span><br><span class="line">return e.load()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *Map) missLocked() &#123;</span><br><span class="line">m.misses++</span><br><span class="line">if m.misses &lt; len(m.dirty) &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">m.read.Store(readOnly&#123;m: m.dirty&#125;)</span><br><span class="line">m.dirty = nil</span><br><span class="line">m.misses = 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img alt data-src="/images/go-sync-map/get%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p><h1 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h1><p>更新或者新增一个entry</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">// Store sets the value for a key.</span><br><span class="line">func (m *Map) Store(key, value interface&#123;&#125;) &#123;</span><br><span class="line">read, _ := m.read.Load().(readOnly)</span><br><span class="line">// 从 read map 中读取 key 成功并且取出的 entry 尝试存储 value 成功，直接返回</span><br><span class="line">if e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m.mu.Lock()</span><br><span class="line">read, _ = m.read.Load().(readOnly)</span><br><span class="line">if e, ok := read.m[key]; ok &#123;</span><br><span class="line">if e.unexpungeLocked() &#123;//确保未被标记成删除，即e 指向的是非 nil 的</span><br><span class="line">// The entry was previously expunged, which implies that there is a</span><br><span class="line">// non-nil dirty map and this entry is not in it.</span><br><span class="line">//m.dirty中不存在这个键，所以加入m.dirty</span><br><span class="line">m.dirty[key] = e</span><br><span class="line">&#125;</span><br><span class="line">e.storeLocked(&amp;value)</span><br><span class="line">&#125; else if e, ok := m.dirty[key]; ok &#123;</span><br><span class="line">e.storeLocked(&amp;value)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">if !read.amended &#123;</span><br><span class="line">// We&apos;re adding the first new key to the dirty map.</span><br><span class="line">// Make sure it is allocated and mark the read-only map as incomplete.</span><br><span class="line">m.dirtyLocked()</span><br><span class="line">m.read.Store(readOnly&#123;m: read.m, amended: true&#125;)</span><br><span class="line">&#125;</span><br><span class="line">m.dirty[key] = newEntry(value)</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// tryStore stores a value if the entry has not been expunged.</span><br><span class="line">//</span><br><span class="line">// If the entry is expunged, tryStore returns false and leaves the entry</span><br><span class="line">// unchanged.</span><br><span class="line">func (e *entry) tryStore(i *interface&#123;&#125;) bool &#123;</span><br><span class="line">p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">if p == expunged &#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line">for &#123;</span><br><span class="line">if atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) &#123;</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">p = atomic.LoadPointer(&amp;e.p)</span><br><span class="line">if p == expunged &#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (m *Map) dirtyLocked() &#123;</span><br><span class="line">if m.dirty != nil &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read, _ := m.read.Load().(readOnly)</span><br><span class="line">m.dirty = make(map[interface&#123;&#125;]*entry, len(read.m))</span><br><span class="line">for k, e := range read.m &#123;</span><br><span class="line">if !e.tryExpungeLocked() &#123;</span><br><span class="line">m.dirty[k] = e</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (e *entry) tryExpungeLocked() (isExpunged bool) &#123;</span><br><span class="line">p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">for p == nil &#123;</span><br><span class="line"> // 将已经删除标记为nil的数据标记为expunged</span><br><span class="line">if atomic.CompareAndSwapPointer(&amp;e.p, nil, expunged) &#123;</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">p = atomic.LoadPointer(&amp;e.p)</span><br><span class="line">&#125;</span><br><span class="line">return p == expunged</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// unexpungeLocked ensures that the entry is not marked as expunged.</span><br><span class="line">// If the entry was previously expunged, it must be added to the dirty map</span><br><span class="line">// before m.mu is unlocked.</span><br><span class="line"></span><br><span class="line">// unexpungeLocked 函数确保了 entry 没有被标记成已被清除。</span><br><span class="line">// 如果 entry 先前被清除过了，那么在 mutex 解锁之前，它一定要被加入到 dirty map 中</span><br><span class="line"></span><br><span class="line">//如果 entry 的 unexpungeLocked 返回为 true，那么就说明 entry </span><br><span class="line">//之前被标记成了 expunged，并经过 CAS 操作成功把它置为 nil。</span><br><span class="line">func (e *entry) unexpungeLocked() (wasExpunged bool) &#123;</span><br><span class="line">return atomic.CompareAndSwapPointer(&amp;e.p, expunged, nil)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img alt data-src="/images/go-sync-map/store%E6%B5%81%E7%A8%8B%E5%9B%BE.bmp"></p><h1 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h1><p>删除一个键值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// Delete deletes the value for a key.</span><br><span class="line">func (m *Map) Delete(key interface&#123;&#125;) &#123;</span><br><span class="line">read, _ := m.read.Load().(readOnly)</span><br><span class="line">e, ok := read.m[key]</span><br><span class="line">if !ok &amp;&amp; read.amended &#123;</span><br><span class="line">m.mu.Lock()</span><br><span class="line">read, _ = m.read.Load().(readOnly)</span><br><span class="line">e, ok = read.m[key]</span><br><span class="line">if !ok &amp;&amp; read.amended &#123;</span><br><span class="line">delete(m.dirty, key)</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">if ok &#123;</span><br><span class="line">e.delete()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (e *entry) delete() (hadValue bool) &#123;</span><br><span class="line">for &#123;</span><br><span class="line">p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">// 已标记为删除</span><br><span class="line">if p == nil || p == expunged &#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line">// 原子操作，e.p标记为nil</span><br><span class="line">if atomic.CompareAndSwapPointer(&amp;e.p, p, nil) &#123;</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img alt data-src="/images/go-sync-map/delete%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><h2 id="已经删除的key-再次Load的时候，会怎么样？"><a href="#已经删除的key-再次Load的时候，会怎么样？" class="headerlink" title="已经删除的key,再次Load的时候，会怎么样？"></a>已经删除的key,再次Load的时候，会怎么样？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func (e *entry) load() (value interface&#123;&#125;, ok bool) &#123;</span><br><span class="line">p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">if p == nil || p == expunged &#123;</span><br><span class="line">return nil, false</span><br><span class="line">&#125;</span><br><span class="line">return *(*interface&#123;&#125;)(p), true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Map Load方法中调用e.load()时，load方法会识别该值是否已被删除</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://studygolang.com/articles/10511" target="_blank" rel="noopener">https://studygolang.com/articles/10511</a><br><a href="http://www.jianshu.com/p/43e66dab535b" target="_blank" rel="noopener">http://www.jianshu.com/p/43e66dab535b</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Sync </tag>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java ForkJoin 解析</title>
      <link href="/java-forkjoin.html"/>
      <url>/java-forkjoin.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要想了解两个地方：如何窃取任务、task如何等待（join）<br>代码基于 OpenJDK 12</p></blockquote><a id="more"></a><h1 id="窃取算法（work-stealing）"><a href="#窃取算法（work-stealing）" class="headerlink" title="窃取算法（work-stealing）"></a>窃取算法（work-stealing）</h1><p>从<a href="/attachments/ForkJoin-Paper-DougLea.pdf" target="_blank">ForkJoin-Paper-DougLea</a>中可以看出:</p><ul><li>每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。</li><li>队列使用的是双端队列，支持LIFO、FIFO。</li><li>子任务会被放到线程（不一定是当前线程）的队列中。</li><li>工作线程按照LIFO的顺序处理自己队列中数据。</li><li>当一个工作线程处理完自己队列中数据的时候，会随机挑选一个工作线程，并“窃取”的该工作线程队列队尾的task。</li></ul><p><img alt data-src="/images/java-forkjoin/steal.png"></p><p>到了这里就可以知道，窃取任务从其他线程队列的尾部窃取的了。</p><h2 id="窃取算法优缺点"><a href="#窃取算法优缺点" class="headerlink" title="窃取算法优缺点"></a>窃取算法优缺点</h2><p>工作窃取算法的优点：充分利用线程进行并行计算，减少了线程间的竞争。<br>工作窃取算法的缺点：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p><h1 id="Task-等待（join）"><a href="#Task-等待（join）" class="headerlink" title="Task 等待（join）"></a>Task 等待（join）</h1><p>Join方法的主要作用是阻塞当前线程并等待获取结果。具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final V join() &#123;</span><br><span class="line">    int s;</span><br><span class="line">    if (((s = doJoin()) &amp; ABNORMAL) != 0)</span><br><span class="line">        reportException(s);</span><br><span class="line">    return getRawResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，它调用了doJoin()方法，通过doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有4种：已完成（NORMAL）、被取消（CANCELLED）、信号（SIGNAL）和出现异常（EXCEPTIONAL）。</p><ul><li>如果任务状态是已完成，则直接返回任务结果。</li><li>如果任务状态是被取消，则直接抛出CancellationException。</li><li>如果任务状态是抛出异常，则直接抛出对应的异常。</li></ul><p>让我们再来分析一下doJoin()方法的实现代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Implementation for join, get, quietlyJoin. Directly handles</span><br><span class="line"> * only cases of already-completed, external wait, and</span><br><span class="line"> * unfork+exec.  Others are relayed to ForkJoinPool.awaitJoin.</span><br><span class="line"> *</span><br><span class="line"> * @return status upon completion</span><br><span class="line"> */</span><br><span class="line">private int doJoin() &#123;</span><br><span class="line">    int s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;</span><br><span class="line">    return </span><br><span class="line">        //已完成,返回status</span><br><span class="line">    (s = status) &lt; 0 ? s :</span><br><span class="line">    //未完成,如果当前线程是ForkJoinWorkerThread,从该线程中取出workQueue,并尝试将</span><br><span class="line">        //当前task出队然后执行,执行的结果是完成则返回状态,否则使用当线程池所在的ForkJoinPool的awaitJoin方法等待</span><br><span class="line">        ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?</span><br><span class="line">        (w = (wt = (ForkJoinWorkerThread)t).workQueue).tryUnpush(this) &amp;&amp; (s = doExec()) &lt; 0 ? s : wt.pool.awaitJoin(w, this, 0L) :</span><br><span class="line">        //当前线程不是ForkJoinWorkerThread,调用externalAwaitDone方法</span><br><span class="line">        //externalAwaitDone: Blocks a non-worker-thread until completion.</span><br><span class="line">        externalAwaitDone();</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * Pops the given task only if it is at the current top.</span><br><span class="line"> */</span><br><span class="line">final boolean tryUnpush(ForkJoinTask&lt;?&gt; task) &#123;</span><br><span class="line">    boolean popped = false;</span><br><span class="line">    int s, cap; ForkJoinTask&lt;?&gt;[] a;</span><br><span class="line">    if ((a = array) != null &amp;&amp; (cap = a.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (s = top) != base &amp;&amp;</span><br><span class="line">        (popped = QA.compareAndSet(a, (cap - 1) &amp; --s, task, null)))</span><br><span class="line">        TOP.setOpaque(this, s);</span><br><span class="line">    return popped;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * Primary execution method for stolen tasks. Unless done, calls</span><br><span class="line"> * exec and records status if completed, but doesn&apos;t wait for</span><br><span class="line"> * completion otherwise.</span><br><span class="line"> *</span><br><span class="line"> * @return status on exit from this method</span><br><span class="line">*/</span><br><span class="line">final int doExec() &#123;</span><br><span class="line">    int s; boolean completed;</span><br><span class="line">    // 仅未完成的任务会运行,其他情况会忽略.</span><br><span class="line">    if ((s = status) &gt;= 0) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //exec是abstract方法</span><br><span class="line">            //调用ForkJoinTask子类中exec</span><br><span class="line">            completed = exec();</span><br><span class="line">        &#125; catch (Throwable rex) &#123;</span><br><span class="line">            completed = false;</span><br><span class="line">            s = setExceptionalCompletion(rex);</span><br><span class="line">        &#125;</span><br><span class="line">        if (completed)</span><br><span class="line">            s = setDone();</span><br><span class="line">        &#125;</span><br><span class="line">        return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在doJoin()方法里，首先通过查看任务的状态，看任务是否已经执行完成，如果执行完成，则直接返回任务状态；如果没有执行完，则从任务队列中取出任务并执行。如果任务顺利执行完成，则设置任务状态为NORMAL，如果出现异常，则记录异常，并将任务状态设置为EXCEPTIONAL。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> Java </tag>
            
            <tag> ForkJoin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 原子操作的实现原理</title>
      <link href="/java-atomic-operation-principle.html"/>
      <url>/java-atomic-operation-principle.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文整理自《Java并发编程的艺术》第二章 作者：方腾飞　魏鹏　程晓明</p></blockquote><a id="more"></a><p>原子（atomic）本意是“不能被进一步分割的最小粒子”，而原子操作（atomic operation）意为“不可被中断的一个或一系列操作”。在多处理器上实现原子操作就变得有点复杂。让我们一起来聊一聊在Intel处理器和Java里是如何实现原子操作的。</p><h1 id="术语定义"><a href="#术语定义" class="headerlink" title="术语定义"></a>术语定义</h1><p>在了解原子操作的实现原理前，先要了解一下相关的术语:</p><style>table th:first-of-type {    width: 100px;}table th:nth-of-type(2) {    width: 150px;}</style><table><thead><tr><th>术语名称</th><th>英文</th><th>解释</th></tr></thead><tbody><tr><td>缓存行</td><td>Cache line</td><td>缓存的最小操作单位</td></tr><tr><td>比较并交换</td><td>Compare and Swap</td><td>CAS操作需要输入两个数值，一个旧值(期望操作前的值)和一个新值，在操作期间先比较旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。</td></tr><tr><td>CPU流水线</td><td>CPU pipeline</td><td>CPU流水线的工作方式就像工业生产上的装配流水线，在CPU中由5~6个不同功能的电路单元组成一条指令处理流水线，然后将一条X86指令分成5~6步后再由这些电路单元分别执行，这样就能实现在一个CPU时钟周期完成一条指令，因此提高CPU的运算速度</td></tr><tr><td>内存顺序冲突</td><td>Memory order violation</td><td>内存顺序冲突一般是由假共享引起的，假共享是指多个CPU同时修改同一个缓存行的不同部分而引起其中一个CPU的操作无效，当出现这个内存顺序冲突时，CPU必须清空流水线</td></tr></tbody></table><h1 id="处理器如何实现原子操作"><a href="#处理器如何实现原子操作" class="headerlink" title="处理器如何实现原子操作"></a>处理器如何实现原子操作</h1><p>32位IA-32处理器使用<font color="DeepPink">基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作</font>。首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。Pentium 6和最新的处理器能自动保证单处理器对同一个缓存行里进行16/32/64位的操作是原子的，但是复杂的内存操作处理器是不能自动保证其原子性的，比如跨总线宽度、跨多个缓存行和跨页表的访问。但是，处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。</p><blockquote><p>在Intel 2019年的文档中，该部分阐述基本不变，具体可以查考文末Intel文档的2957页 8.1 LOCKED ATOMIC OPERATIONS</p></blockquote><h2 id="使用总线锁保证原子性"><a href="#使用总线锁保证原子性" class="headerlink" title="使用总线锁保证原子性"></a>使用总线锁保证原子性</h2><p>第一个机制是通过总线锁保证原子性。如果多个处理器同时对共享变量进行读改写操作（i++就是经典的读改写操作），那么共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子的，操作完之后共享变量的值会和期望的不一致。举个例子，如果i=1，我们进行两次i++操作，我们期望的结果是3，但是有可能结果是2，如图2-3所示。</p><p><img alt data-src="/images/java-atomic-operation-principle/%E5%9B%BE23.png"></p><p>原因可能是多个处理器同时从各自的缓存中读取变量i，分别进行加1操作，然后分别写入系统内存中。那么，想要保证读改写共享变量的操作是原子的，就必须保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。处理器使用总线锁就是来解决这个问题的。<font color="DeepPink">所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。</font></p><blockquote><p>Intel文档的2959页 8.1.2 Bus Locking</p></blockquote><h2 id="使用缓存锁保证原子性"><a href="#使用缓存锁保证原子性" class="headerlink" title="使用缓存锁保证原子性"></a>使用缓存锁保证原子性</h2><p>第二个机制是通过缓存锁定来保证原子性。<font color="DeepPink">在同一时刻，我们只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。</font></p><p>频繁使用的内存会缓存在处理器的L1、L2和L3高速缓存里，那么原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁，在Pentium 6和目前的处理器中可以使用“缓存锁定”的方式来实现复杂的原子性。<font color="DeepPink">所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效</font>，在如图2-3所示的例子中，当CPU1修改缓存行中的i时使用了缓存锁定，那么CPU2就不能同时缓存i的缓存行。</p><p>但是有两种情况下处理器不会使用缓存锁定：</p><ul><li>第一种情况是：<font color="DeepPink">当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line）时，则处理器会调用总线锁定。</font></li><li>第二种情况是：<font color="DeepPink">有些处理器不支持缓存锁定。对于Intel 486和Pentium处理器，就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。</font>针对以上两个机制，我们通过Intel处理器提供了很多Lock前缀的指令来实现。例如，位测试和修改指令：BTS、BTR、BTC；交换指令XADD、CMPXCHG，以及其他一些操作数和逻辑指令（如ADD、OR）等，被这些指令操作的内存区域就会加锁，导致其他处理器不能同时访问它。</li></ul><blockquote><p>Intel文档的2961页 8.1.4 Effects of a LOCK Operation on Internal Processor Caches</p></blockquote><h1 id="Java如何实现原子操作"><a href="#Java如何实现原子操作" class="headerlink" title="Java如何实现原子操作"></a>Java如何实现原子操作</h1><p>在Java中可以通过锁和循环CAS的方式来实现原子操作。</p><h2 id="使用循环CAS实现原子操作"><a href="#使用循环CAS实现原子操作" class="headerlink" title="使用循环CAS实现原子操作"></a>使用循环CAS实现原子操作</h2><p>JVM中的CAS操作正是利用了处理器提供的CMPXCHG(Compare and Exchange)指令实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止，以下代码实现了一个基于CAS线程安全的计数器方法safeCount和一个非线程安全的计数器count。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">private AtomicInteger atomicI = new AtomicInteger(0);</span><br><span class="line">private int i = 0;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    final Counter cas = new Counter();</span><br><span class="line">    List&lt;Thread&gt; ts = new ArrayList&lt;Thread&gt;(600);</span><br><span class="line">    long start = System.currentTimeMillis();</span><br><span class="line">    for (int j = 0; j &lt; 100; j++) &#123;</span><br><span class="line">        Thread t = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">                    cas.count();</span><br><span class="line">                    cas.safeCount();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ts.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">    for (Thread t : ts) &#123;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">    // 等待所有线程执行完成</span><br><span class="line">    for (Thread t : ts) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(cas.i);</span><br><span class="line">    System.out.println(cas.atomicI.get());</span><br><span class="line">    System.out.println(System.currentTimeMillis() - start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 使用CAS实现线程安全计数器</span><br><span class="line"> */</span><br><span class="line">private void safeCount() &#123;</span><br><span class="line">    for (; ; ) &#123;</span><br><span class="line">        int i = atomicI.get();</span><br><span class="line">        boolean suc = atomicI.compareAndSet(i, ++i);</span><br><span class="line">        if (suc) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 非线程安全计数器</span><br><span class="line"> */</span><br><span class="line">private void count() &#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从Java 1.5开始，JDK的并发包里提供了一些类来支持原子操作，如AtomicBoolean（用原子方式更新的boolean值）、AtomicInteger（用原子方式更新的int值）和AtomicLong（用原子方式更新的long值）。这些原子包装类还提供了有用的工具方法，比如以原子的方式将当前值自增1和自减1。</p><h2 id="CAS实现原子操作的三大问题"><a href="#CAS实现原子操作的三大问题" class="headerlink" title="CAS实现原子操作的三大问题"></a>CAS实现原子操作的三大问题</h2><p>在Java并发包中有一些并发框架也使用了自旋CAS的方式来实现原子操作，比如LinkedTransferQueue类的Xfer方法。CAS虽然很高效地解决了原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大，以及只能保证一个共享变量的原子操作。</p><ol><li><font color="DeepPink">ABA问题</font>。因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。<font color="DeepPink">在变量前面追加上版本号，每次变量更新的时候把版本号加1</font>，那么A→B→A就会变成1A→2B→3A。从Java 1.5开始，JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public boolean compareAndSet(</span><br><span class="line">V expectedReference, // 预期引用</span><br><span class="line">V newReference, // 更新后的引用</span><br><span class="line">int expectedStamp, // 预期标志</span><br><span class="line">int newStamp // 更新后的标志</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol start="2"><li><p><font color="DeepPink">循环时间长开销大</font>。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。pause指令有两个作用：第一，它可以延迟流水线执行指令（de-pipeline），使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零；第二，它可以避免在退出循环的时候因内存顺序冲突（Memory Order Violation）而引起CPU流水线被清空（CPU Pipeline Flush），从而提高CPU的执行效率。</p></li><li><p><font color="DeepPink">只能保证一个共享变量的原子操作</font>。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i＝2，j=a，合并一下ij=2a，然后用CAS来操作ij。从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。</p></li></ol><h2 id="使用锁机制实现原子操作"><a href="#使用锁机制实现原子操作" class="headerlink" title="使用锁机制实现原子操作"></a>使用锁机制实现原子操作</h2><p>锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。</p><h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><p><a href="https://github.com/jiankunking/books-recommendation/blob/master/CPU/Intel®%2064%20and%20IA-32%20architectures%20software%20developer’s%20manual.pdf" target="_blank" rel="noopener">Intel® 64 and IA-32 architectures software developer’s manual</a> </p>]]></content>
      
      
      <categories>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
            <tag> Concurrent </tag>
            
            <tag> Atomic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java ThreadLocal</title>
      <link href="/java-threadlocal.html"/>
      <url>/java-threadlocal.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>基于OpenJDK 12</p></blockquote><a id="more"></a><h1 id="引"><a href="#引" class="headerlink" title="引"></a>引</h1><p>本文主要想了解两个地方：</p><ol><li>ThreadLocal实例看起来是在多个线程共享，但实际上是彼此独立的，这个是怎么实现的？</li><li>ThreadLocal使用不当真的会OOM吗？如果会，那么原因是啥？</li></ol><p>先看一下<a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/lang/ThreadLocal.html" target="_blank" rel="noopener">ThreadLocal的官方API</a>解释为：</p><blockquote><p>该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其 get 或 set 方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本[原文：These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable.]。ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。</p></blockquote><p>大概的意思有两点：</p><ul><li><font color="DeepPink">ThreadLocal提供了一种访问某个变量的特殊方式：访问到的变量属于当前线程，即保证每个线程的变量不一样，而同一个线程在任何地方拿到的变量都是一致的，这就是所谓的线程隔离。</font></li><li><font color="DeepPink">如果要使用ThreadLocal，通常定义为private static类型，在我看来最好是定义为private static final类型。</font></li></ul><p>看一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 代码来自：</span><br><span class="line">// http://tutorials.jenkov.com/java-concurrency/threadlocal.html</span><br><span class="line">public class ThreadLocalExample &#123;</span><br><span class="line">    public static class MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            //注意这里 set的值是run函数的内部变量，如果是MyRunnable的全局变量</span><br><span class="line">            //则无法起到线程隔离的作用</span><br><span class="line">            threadLocal.set((int) (Math.random() * 100D));</span><br><span class="line">            try &#123;</span><br><span class="line">                //sleep两秒的作用是让thread2 set操作在thread1的输出之前执行</span><br><span class="line">                //如果线程之间是共用threadLocal，则thread2 set操作会覆盖掉thread1的set操作</span><br><span class="line">                //从而两者的输出都是thread2 set的值</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(threadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        MyRunnable sharedRunnableInstance = new MyRunnable();</span><br><span class="line"></span><br><span class="line">        Thread thread1 = new Thread(sharedRunnableInstance);</span><br><span class="line">        Thread thread2 = new Thread(sharedRunnableInstance);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        thread1.join(); //wait for thread 1 to terminate</span><br><span class="line">        thread2.join(); //wait for thread 2 to terminate</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread1 start</span><br><span class="line">thread2 start</span><br><span class="line">38</span><br><span class="line">thread1 join</span><br><span class="line">78</span><br><span class="line">thread2 join</span><br></pre></td></tr></table></figure><p>MyRunnable run中sleep两秒的作用是让thread2 set操作在thread1的输出之前执行，如果线程之间是共用threadLocal，则thread2 set操作会覆盖掉thread1的set操作，两者的输出都是thread2 set的值，从而输出的应该是同一个值。</p><p>但从代码执行结果来看，thread1、thread2的threadLocal是不同的，也就是实现了线程隔离。</p><h1 id="ThreadLocal实例在线程间是如何独立的？"><a href="#ThreadLocal实例在线程间是如何独立的？" class="headerlink" title="ThreadLocal实例在线程间是如何独立的？"></a>ThreadLocal实例在线程间是如何独立的？</h1><p>看一眼ThreadLocal set方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    //currentThread是个native方法，会返回对当前执行线程对象的引用。</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    //getMap 返回线程自身的threadLocals</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null) &#123;</span><br><span class="line">        //把value set到线程自身的ThreadLocalMap中了</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //线程自身的ThreadLocalMap未初始化，则先初始化，再set</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">    return t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line">//Thread类中</span><br><span class="line">//ThreadLocalMapset的set方法未执行深拷贝，需要注意传递值的类型</span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = null;</span><br></pre></td></tr></table></figure><p>从代码中可以看到，在set的时候，会根据Thread对象的引用来将值添加到各自线程中。但set的值value还是同一个对象,既然传递的是同一个对象，那就涉及到另一个问题：参数值传递、引用传递的问题了。</p><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadLocalExample &#123;</span><br><span class="line">    public static class MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private ThreadLocal&lt;Object&gt; threadLocal = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        // MyRunnable 全局变量</span><br><span class="line">        int random;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            random = (int) (Math.random() * 100D);</span><br><span class="line">            threadLocal.set(random);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(threadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        MyRunnable sharedRunnableInstance = new MyRunnable();</span><br><span class="line"></span><br><span class="line">        Thread thread1 = new Thread(sharedRunnableInstance);</span><br><span class="line">        Thread thread2 = new Thread(sharedRunnableInstance);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        System.out.println(&quot;thread1 start&quot;);</span><br><span class="line">        thread2.start();</span><br><span class="line">        System.out.println(&quot;thread2 start&quot;);</span><br><span class="line"></span><br><span class="line">        thread1.join(); //wait for thread 1 to terminate</span><br><span class="line">        System.out.println(&quot;thread1 join&quot;);</span><br><span class="line">        thread2.join(); //wait for thread 2 to terminate</span><br><span class="line">        System.out.println(&quot;thread2 join&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">thread1 start</span><br><span class="line">thread2 start</span><br><span class="line">//两个值不同</span><br><span class="line">16</span><br><span class="line">thread1 join</span><br><span class="line">75</span><br><span class="line">thread2 join</span><br></pre></td></tr></table></figure><p>从输出可以看出两者隔离了。</p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><h3 id="全局引用"><a href="#全局引用" class="headerlink" title="全局引用"></a>全局引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadLocalExample &#123;</span><br><span class="line">    public static class MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private ThreadLocal&lt;Object&gt; threadLocal = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        // MyRunnable 全局变量</span><br><span class="line">        Obj obj = new Obj();</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            obj.value = (int) (Math.random() * 100D);</span><br><span class="line">            threadLocal.set(obj);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(((Obj) threadLocal.get()).value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        class Obj &#123;</span><br><span class="line">            int value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        MyRunnable sharedRunnableInstance = new MyRunnable();</span><br><span class="line"></span><br><span class="line">        Thread thread1 = new Thread(sharedRunnableInstance);</span><br><span class="line">        Thread thread2 = new Thread(sharedRunnableInstance);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        System.out.println(&quot;thread1 start&quot;);</span><br><span class="line">        thread2.start();</span><br><span class="line">        System.out.println(&quot;thread2 start&quot;);</span><br><span class="line"></span><br><span class="line">        thread1.join(); //wait for thread 1 to terminate</span><br><span class="line">        System.out.println(&quot;thread1 join&quot;);</span><br><span class="line">        thread2.join(); //wait for thread 2 to terminate</span><br><span class="line">        System.out.println(&quot;thread2 join&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">thread1 start</span><br><span class="line">thread2 start</span><br><span class="line">//两个值相同</span><br><span class="line">36</span><br><span class="line">36</span><br><span class="line">thread1 join</span><br><span class="line">thread2 join</span><br></pre></td></tr></table></figure><p>从输出结果来看，当set操作的值是MyRunnable的全局变量，并且是引用类型的时候，无法起到隔离的作用。</p><h3 id="局部引用"><a href="#局部引用" class="headerlink" title="局部引用"></a>局部引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadLocalExample &#123;</span><br><span class="line">    public static class MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private ThreadLocal&lt;Object&gt; threadLocal = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        //Obj obj = new Obj();</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            Obj obj = new Obj();</span><br><span class="line">            obj.value = (int) (Math.random() * 100D);</span><br><span class="line">            threadLocal.set(obj);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(((Obj) threadLocal.get()).value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        class Obj &#123;</span><br><span class="line">            int value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        MyRunnable sharedRunnableInstance = new MyRunnable();</span><br><span class="line"></span><br><span class="line">        Thread thread1 = new Thread(sharedRunnableInstance);</span><br><span class="line">        Thread thread2 = new Thread(sharedRunnableInstance);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        System.out.println(&quot;thread1 start&quot;);</span><br><span class="line">        thread2.start();</span><br><span class="line">        System.out.println(&quot;thread2 start&quot;);</span><br><span class="line"></span><br><span class="line">        thread1.join(); //wait for thread 1 to terminate</span><br><span class="line">        System.out.println(&quot;thread1 join&quot;);</span><br><span class="line">        thread2.join(); //wait for thread 2 to terminate</span><br><span class="line">        System.out.println(&quot;thread2 join&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">thread1 start</span><br><span class="line">thread2 start</span><br><span class="line">//两个值不同</span><br><span class="line">12</span><br><span class="line">19</span><br><span class="line">thread1 join</span><br><span class="line">thread2 join</span><br></pre></td></tr></table></figure><p>从输出结果看，局部引用，可以相互隔离。</p><p><font color="DeepPink">到这里可以看出ThreadLocal，只是把set值或引用绑定到了当前线程，但却没有进行相应的深拷贝，所以ThreadLocal要想做的线程隔离，必须是基本类型或者run的局部变量。</font></p><h1 id="ThreadLocal-OOM-？"><a href="#ThreadLocal-OOM-？" class="headerlink" title="ThreadLocal OOM ？"></a>ThreadLocal OOM ？</h1><p>看一下ThreadLocalMap内部Entry：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    /** The value associated with this ThreadLocal. */</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        super(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中看到，Entry继承了WeakReference，并将ThreadLocal设置为了WeakReference，value设置为强引用。也就是：当没有强引用指向ThreadLocal变量时，它可被回收。</p><p>但是，还有一个问题：<font color="DeepPink">ThreadLocalMap维护ThreadLocal变量与具体实例的映射，当ThreadLocal变量被回收后，该映射的key变为 null，而该Entry还是在ThreadLocalMap中，从而这些无法清理的Entry，会造成内存泄漏。</font></p><blockquote><p>ThreadLocal自带的remove、set方法，都无法处理ThreadLocal自身为null的情况，因为代码中都直接取ThreadLocal的threadLocalHashCode属性了，所以如果ThreadLocal自身已经是null，这时调用remove、set会报空指针异常（java.lang.NullPointerException）的。</p></blockquote><p>所以，在使用ThreadLocal的时候，在使用完毕记得remove（remove方法会将Entry的value及Entry自身设置为null并进行清理）。</p><p>JDK 12 ThreadLocal代码地址：<br><a href="https://github.com/jiankunking/openjdk12/blob/master/src/java.base/share/classes/java/lang/ThreadLocal.java" target="_blank" rel="noopener">https://github.com/jiankunking/openjdk12/blob/master/src/java.base/share/classes/java/lang/ThreadLocal.java</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>译 Java Concurrent Atomic Package详解</title>
      <link href="/java-concurrent-atomic-package.html"/>
      <url>/java-concurrent-atomic-package.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>翻译自：Package java.util.concurrent.atomic</p></blockquote><a id="more"></a><blockquote><p>地址：<br><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/package-summary.html#package.description" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/package-summary.html#package.description</a><br>翻译JDK8而不是12的原因是JDK8对与内存语义部分讲解更加详细。</p></blockquote><p><strong>Package java.util.concurrent.atomic 对于单个变量支持无锁、线程安全操作的工具类。</strong></p><p>类摘要：</p><table><thead><tr><th>类名</th><th>描述</th></tr></thead><tbody><tr><td>AtomicBoolean</td><td>可以原子性更新的boolean值。</td></tr><tr><td>AtomicInteger</td><td>可以原子性更新的int值。</td></tr><tr><td>AtomicIntegerArray</td><td>一个int数组，其中的元素可以原子性更新。</td></tr><tr><td>AtomicIntegerFieldUpdater<t></t></td><td>基于反射，可以对指定类的指定 volatile int 字段进行原子更新。</td></tr><tr><td>AtomicLong</td><td>可以原子性更新的long值。</td></tr><tr><td>AtomicLongArray</td><td>一个long数组，其中的元素可以原子性更新。</td></tr><tr><td>AtomicLongFieldUpdater<t></t></td><td>基于反射，可以对指定类的指定 volatile long 字段进行原子更新。</td></tr><tr><td>AtomicMarkableReference<v></v></td><td>维护带有标记位的对象引用，可以原子方式对其进行更新。</td></tr><tr><td>AtomicReference<v></v></td><td>可以原子性更新的对象引用</td></tr><tr><td>AtomicReferenceArray<e></e></td><td>一个对象引用数组，其中的元素可以原子性更新。</td></tr><tr><td>AtomicReferenceFieldUpdater&lt;T,V&gt;</td><td>基于反射，可以对指定类的指定 volatile reference 字段进行原子更新。</td></tr><tr><td>AtomicStampedReference<v></v></td><td>维护带有整数版本标志的对象引用，可以原子方式对其进行更新。</td></tr><tr><td>DoubleAccumulator</td><td>One or more variables that together maintain a running double value updated using a supplied function.</td></tr><tr><td>DoubleAdder</td><td>One or more variables that together maintain an initially zero double sum.</td></tr><tr><td>LongAccumulator</td><td>One or more variables that together maintain a running long value updated using a supplied function.</td></tr><tr><td>LongAdder</td><td>One or more variables that together maintain an initially zero long sum.</td></tr></tbody></table><blockquote><p>DoubleAccumulator、DoubleAdder、LongAccumulator、LongAdder 均是Striped64的子类，内部维护的是一个数组，当并发更新时，每个线程操作的是数组中的元素，从而降低锁的粒度。</p></blockquote><p>本质上，该package下的类扩展了volatile值、字段、数组元素的概念，提供以下形式的原子更新操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean compareAndSet(expectedValue, updateValue);</span><br></pre></td></tr></table></figure><p>该方法（在不同类中的参数类型不同）原子地将变量设置为updateValue，如果它当前持有expectedValue，更新成功返回true。该包中的类还包含获取和无条件设置（set）值的方法。</p><p>这些方法的规范使实现能够采用当代处理器上可用的高效机器级原子指令。 然而，<font color="DeepPink">在某些平台上，支持可能需要某种形式的内部锁定。因此，这些方法不是严格保证是非阻塞的（线程可能在执行操作之前暂时阻塞）。</font></p><p>AtomicBoolean、AtomicInteger、AtomicLong和AtomicReference类的实例都提供对对应类型的单个变量的访问和更新。每个类还提供了适用于该类型的实用方法。例如，类AtomicLong和AtomicInteger提供原子增量方法。 一个应用是生成序列号，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Sequencer &#123;</span><br><span class="line">  private final AtomicLong sequenceNumber = new AtomicLong(0);</span><br><span class="line">  public long next() &#123;</span><br><span class="line">    return sequenceNumber.getAndIncrement();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原子性访问和更新内存效果，与volatiles遵循同样的规则，如<a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4" target="_blank" rel="noopener">The Java Language Specification (17.4 Memory Model)</a>所述：</p><ul><li>get与volatile读效果一样</li><li>set与volatile写效果一样</li><li>lazySet与写入(分配)volatile变量的效果一样【写操作不会与之前的任何写操作重新排序】，但它可能被后续操作重排【也就是，<font color="DeepPink">在volatile写或者同步操作之前，可能对于其它线程不可见</font>】。</li><li>compareAndSet和所有其他读取和更新操作(如getAndIncrement)一样，与volatile变量读取和写入具有相同的内存效果。</li></ul><blockquote><p>lazySet是使用Unsafe.putOrderedObject方法，这个方法在对低延迟代码是很有用的，它能够实现非阻塞的写入，这些写入不会被Java的JIT重新排序指令(instruction reordering)，这样它使用快速的存储-存储(store-store) barrier, 而不是较慢的存储-加载(store-load) barrier, 后者总是用在volatile的写操作上，这种性能提升是有代价的，虽然便宜，也就是写后结果并不会被其他线程看到，甚至是自己的线程，通常是几纳秒后被其他线程看到，这个时间比较短，所以代价可以忍受。<br>设想如下场景: 设置一个 volatile 变量为 null，让这个对象被 GC 掉，volatile write 是消耗比较大（store-load 屏障）的，但是 putOrderedInt 只会加 store-store 屏障，损耗会小一些。</p></blockquote><p>添加lazySet方法的原因:<a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6275329" target="_blank" rel="noopener">https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6275329</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">As probably the last little JSR166 follow-up for Mustang,</span><br><span class="line">we added a &quot;lazySet&quot; method to the Atomic classes</span><br><span class="line">(AtomicInteger, AtomicReference, etc). This is a niche</span><br><span class="line">method that is sometimes useful when fine-tuning code using</span><br><span class="line">non-blocking data structures. The semantics are</span><br><span class="line">that the write is guaranteed not to be re-ordered with any</span><br><span class="line">previous write, but may be reordered with subsequent operations</span><br><span class="line">(or equivalently, might not be visible to other threads) until</span><br><span class="line">some other volatile write or synchronizing action occurs).</span><br><span class="line"></span><br><span class="line">The main use case is for nulling out fields of nodes in</span><br><span class="line">non-blocking data structures solely for the sake of avoiding</span><br><span class="line">long-term garbage retention; it applies when it is harmless</span><br><span class="line">if other threads see non-null values for a while, but you&apos;d</span><br><span class="line">like to ensure that structures are eventually GCable. In such</span><br><span class="line">cases, you can get better performance by avoiding</span><br><span class="line">the costs of the null volatile-write. There are a few</span><br><span class="line">other use cases along these lines for non-reference-based</span><br><span class="line">atomics as well, so the method is supported across all of the</span><br><span class="line">AtomicX classes.</span><br><span class="line"></span><br><span class="line">For people who like to think of these operations in terms of</span><br><span class="line">machine-level barriers on common multiprocessors, lazySet</span><br><span class="line">provides a preceeding store-store barrier (which is either</span><br><span class="line">a no-op or very cheap on current platforms), but no</span><br><span class="line">store-load barrier (which is usually the expensive part</span><br><span class="line">of a volatile-write).</span><br></pre></td></tr></table></figure><blockquote><p>weakCompareAndSet JDK 9之后Deprecated，本文已跳过。</p></blockquote><p>除了表示单个值的类之外，package中还包含Updater类，可用于在类的volatile字段上执行compareAndSet操作。 AtomicReferenceFieldUpdater、AtomicIntegerFieldUpdater和AtomicLongFieldUpdater是基于反射的，可提供对相关字段类型的访问。这些主要用于原子数据结构，同一节点的几个volatile字段（例如，树节点的链接）独立地原子更新。<strong>这些类在如何以及何时使用原子更新方面提供了更大的灵活性，但代价是更加笨拙的基于反射的设置、更不方便的使用和更弱的保证。</strong></p><p>AtomicIntegerArray、AtomicLongArray和AtomicReferenceArray类进一步将原子操作支持扩展到这些类型的数组。这些类还<strong>提供了数组元素的volatile访问语义，这是普通数组不支持的。</strong></p><p>AtomicMarkableReference类将单个布尔值与引用相关联。 例如，该位可能在数据结构中使用，表示被引用的对象在逻辑上已被删除。 AtomicStampedReference类将整数值与引用相关联。 例如，这可以用于表示与一系列更新相对应的版本号。</p><p>原子类主要设计为用于实现非阻塞数据结构和相关基础结构类的构建。 compareAndSet方法不是锁定的一般替代方法。 仅当对象的关键更新仅限于单个变量时，它才适用。</p><p>原子类不是java.lang.Integer和相关类的通用替换。它们没有定义equals，hashCode和compareTo等方法（由于原子变量预期会发生变化，所以它们不适合作为哈希表键）。</p><blockquote><p>后续会出文章解析：AtomicLong、Striped64、LongAdder<br>本文的目的主要是从大体上了解atomic及其内存语义</p></blockquote><blockquote><p>JDK 12<br><a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/concurrent/atomic/package-summary.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/concurrent/atomic/package-summary.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
            <tag> Concurrent </tag>
            
            <tag> Atomic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java JUC Atomic AtomicLong</title>
      <link href="/java-juc-atomic-atomiclong.html"/>
      <url>/java-juc-atomic-atomiclong.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>基于OpenJDK 12<br>本文的目的是为后续文章解析LongAdder做一个引子，以便两者对比。</p></blockquote><a id="more"></a><p><a href="http://www.jiankunking.com/译-Java-Concurrent-Atomic-Package-详解.html" target="_blank" rel="noopener">Atomic Package解析参考（比如lazySet原理解析）</a></p><p>AtomicLong的常用方法如下：</p><ul><li>long addAndGet(long delta)：以原子方式将输入的数值与实例中的值（AtomicLong里的<br>value）相加，并返回结果。</li><li>compareAndSet(long expectedValue, long newValue)：如果输入的数值等于预期值，则以原子方<br>式将该值设置为输入的值。</li><li>long getAndIncrement()：以原子方式将当前值加1，注意，这里返回的是自增前的值。</li><li>void lazySet(long newValue)：最终会设置成newValue，<font color="DeepPink">使用lazySet设置值后，可能导致其他<br>线程在之后的一小段时间内还是可以读到旧的值</font>。</li><li>long getAndSet(long newValue)：以原子方式设置为newValue的值，并返回旧值。</li></ul><p>AtomicLong示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicLongTest &#123;</span><br><span class="line">    static AtomicLong ai = new AtomicLong(1);</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(ai.getAndIncrement());</span><br><span class="line">        System.out.println(ai.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>那么getAndIncrement是如何实现原子操作的呢？让我们一起分析其实现原理，getAndIncrement的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public final long getAndIncrement() &#123;</span><br><span class="line">   return U.getAndAddLong(this, VALUE, 1L);</span><br><span class="line">&#125;</span><br><span class="line">@HotSpotIntrinsicCandidate</span><br><span class="line">public final long getAndAddLong(Object o, long offset, long delta) &#123;</span><br><span class="line">    long v;</span><br><span class="line">    do &#123;</span><br><span class="line">        v = getLongVolatile(o, offset);</span><br><span class="line">    &#125; while (!weakCompareAndSetLong(o, offset, v, v + delta));</span><br><span class="line">    return v;</span><br><span class="line">&#125;</span><br><span class="line">/** Volatile version of &#123;@link #getLong(Object, long)&#125;  */</span><br><span class="line">@HotSpotIntrinsicCandidate</span><br><span class="line">public native long getLongVolatile(Object o, long offset);</span><br><span class="line"></span><br><span class="line">@HotSpotIntrinsicCandidate</span><br><span class="line">public final boolean weakCompareAndSetLong(Object o, long offset,</span><br><span class="line">                                           long expected,</span><br><span class="line">                                           ong x) &#123;</span><br><span class="line">    return compareAndSetLong(o, offset, expected, x);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * Atomically updates Java variable to &#123;@code x&#125; if it is currently</span><br><span class="line"> * holding &#123;@code expected&#125;.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This operation has memory semantics of a &#123;@code volatile&#125; read</span><br><span class="line"> * and write.  Corresponds to C11 atomic_compare_exchange_strong.</span><br><span class="line"> *</span><br><span class="line"> * @return &#123;@code true&#125; if successful</span><br><span class="line"> */</span><br><span class="line">@HotSpotIntrinsicCandidate</span><br><span class="line">public final native boolean compareAndSetLong(Object o, long offset,</span><br><span class="line">                                              long expected,</span><br><span class="line">                                              long x);</span><br></pre></td></tr></table></figure><blockquote><p>@HotSpotIntrinsicCandidate JDK的源码中，被@HotSpotIntrinsicCandidate标注的方法，在HotSpot中都有一套高效的实现，该高效实现基于CPU指令，运行时，HotSpot维护的高效实现会替代JDK的源码实现，从而获得更高的效率。</p></blockquote><p>源码getAndAddLong(Object o, long offset, long delta)中do while循环体是实现的关键所在，其逻辑是：<br>第一步先取得AtomicLong里存储的数值，<br>第二步对AtomicLong的当前数值进行加1操作，<br>第三步调用weakCompareAndSetLong方法来进行原子更新操作，该方法先检查当前数值是否等于v，等于意味着AtomicLong的值没有被其他线程修改过，则将weakCompareAndSetLong的当前数值更新成v+delta的值，如果不等于v，weakCompareAndSetLong方法会返回false，<font color="DeepPink">程序会进入do while循环重新进行</font>weakCompareAndSetLong操作。</p><p><font color="DeepPink">这里隐含了一个问题，当对于共享变量（假设变量名字是a）的竞争非常激烈的时候，在当前线程读取a、改变a之间，a的值会被别的线程改变，从而导致当前线程一直重试（自旋），一直占用CPU。</font></p><p><font color="DeepPink">这就引出另一个问题，对于锁抢占很激烈的时候，串行是最好的解决办法。比如使用synchronized。</font></p><blockquote><p>java.util.concurrent.atomic中的原子操作基本是基于Unsafe或者VarHandle实现的。</p></blockquote><p><a href="https://github.com/jiankunking/openjdk12/blob/master/src/java.base/share/classes/java/util/concurrent/atomic/AtomicLong.java" target="_blank" rel="noopener">AtomicLong源码</a></p><blockquote><p>本文参考 《Java并发编程的艺术》 作者：方腾飞　魏鹏　程晓明</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
            <tag> Concurrent </tag>
            
            <tag> Atomic </tag>
            
            <tag> AtomicLong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java JUC Atomic LongAdder</title>
      <link href="/java-juc-atomic-longadder.html"/>
      <url>/java-juc-atomic-longadder.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>基于OpenJDK 12</p></blockquote><a id="more"></a><p>阅读本文前，推荐先阅读以下两篇文章，以便能更好的对比理解：</p><ul><li><a href="https://jiankunking.com/%E8%AF%91-Java-Concurrent-Atomic-Package-%E8%AF%A6%E8%A7%A3.html">译-Java-Concurrent-Atomic-Package-详解</a></li><li><a href="https://jiankunking.com/Java-JUC-Atomic-AtomicLong.html">Java-JUC-Atomic-AtomicLong</a></li></ul><p>LongAdder是JDK 1.8 新增的原子类，基于Striped64实现。 从官方文档看，LongAdder在高并发的场景下会比AtomicLong 具有更好的性能，代价是消耗更多的内存空间：</p><blockquote><p>This class is usually preferable to AtomicLong when multiple threads update a common sum that is used for purposes such as collecting statistics, not for fine-grained synchronization control. <font color="DeepPink">Under low update contention, the two classes have similar characteristics. But under high contention, expected throughput of this class is significantly higher, at the expense of higher space consumption.</font></p></blockquote><p>那么LongAdder是怎么实现的？</p><p>先看一下LongAdder的类图：<br><img alt data-src="/images/java-juc-atomic-longadder/LongAdder%E7%B1%BB%E5%9B%BE.png"></p><p>基类Number，Number是一个抽象类其中没有任何逻辑，该类是byte、double、float、int、long、short的基类。</p><h1 id="Striped64"><a href="#Striped64" class="headerlink" title="Striped64"></a>Striped64</h1><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p>该部分翻译自Striped64源码注释，可以略过，概括起来就是：</p><blockquote><p>分散热点，将value值分散到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。如果要获取真正的long值，只要将各个槽中的变量值累加返回。</p></blockquote><hr><p>从Striped64类注释可以看到：</p><blockquote><p>Striped64是package内使用的，对于在64位元素上动态分片提供统一实现（感觉有点像：AbstractQueuedSynchronizer）<br>Striped64继承了Number类，这也就是说具体实现的子类也必须实现相关的内容</p></blockquote><p>该类维护一个原子更新变量的延迟初始化表，以及一个额外的“base”字段。表的大小是2的幂。索引使用掩码下的每个线程的hash code。这个类中的几乎所有声明都是package私有的，由子类直接访问。</p><p>表格内的元素是Cell类，Cell类是一个为了减少缓存争用而填充的AtomicLong的变种。填充对于大多数原子来说是多余的，因为它们通常不规则地分散在内存中，因此彼此之间不会有太多的干扰。但是，驻留在数组中的原子对象往往是彼此相邻的，因此在没有这种预防措施的情况下，最常见的情况是共享高速缓存线(这对性能有很大的负面影响)。</p><p>在某种程度上，因为Cell类相对较大，只有他们真正被需要的时候，我们才创建。<font color="DeepPink">如果没有竞争，那么所有的更新操作将对base字段实现。当发生第一次争用（也就是说如果第一次对base字段的CAS操作失败），初始化为大小是2的表格。当进一步的争用发生的时候,表的大小会加倍，直到达到等于大于cpu的数量。表在未使用之前一直为null。</font></p><p>利用一个自旋锁（cellsBusy）来初始化和调整表的大小，以及用新Cells填充slots。这个地方没有必要使用阻塞锁，如果锁不可达，线程可以尝试其他的slots，或者尝试base字段。在这些重试期间，竞争加剧，但是降低了局部性，这仍然比阻塞锁来得好。</p><p>通过ThreadLocalRandom维护的Thread.probe字段用作每个线程的哈希码。我们让它们保持未初始化（为零）(如果它们以这种方式出现)，直到它们在插槽0竞争。出现竞争后初始化为通常不会和其他的的值冲突的值，比如线程的哈希码。在执行更新时发生CAS操作失败意味着出现了争用或者表碰撞，或两者都有。在发生冲突时，如果表的大小小于容量，那么它的大小将加倍，除非其他线程持有锁。如果哈希后的slot为空，并且锁可用，则创建一个新单元格。如果存在了那么会进行CAS尝试。通过双重哈希进行重试，利用一个辅助哈希（Marsaglia XorShift随机数算法）来尝试寻找一个空闲的slot。</p><p><font color="DeepPink">表的大小是有上限的，因为当线程多于CPU时，假设每个线程都绑定到一个CPU，就会有一个完美的散列函数将线程映射到插槽，从而消除冲突。当我们达到容量时，我们通过随机改变冲突线程的哈希代码来搜索这个映射。因为搜索是随机的，冲突只有通过CAS失败才知道，收敛可能会很慢，而且因为线程通常不会永远绑定到CPU，所以根本不会发生。然而，尽管有这些限制，在这些情况下观察到的竞争率通常很低。</font></p><p><font color="DeepPink">Cell可能会出现不可用的情况，包括进行哈希的线程终止，或者由于table扩容导致线程哈希不正确。我们不尝试检测或删除这样的单元格，假设对于长时间运行的实例，争用会再次发生，因此最终将再次需要这些单元格;而对于短时间运行的实例，花费时间去销毁又没有什么必要。</font></p><hr><h2 id="Cell类"><a href="#Cell类" class="headerlink" title="Cell类"></a>Cell类</h2><p>Atomiclong的变体，仅支持原始访问和CAS。</p><blockquote><p>Cell类被注解@jdk.internal.vm.annotation.Contended修饰。<br>Contended的作用（详细信息参见：<a href="http://openjdk.java.net/jeps/142" target="_blank" rel="noopener">JEP 142</a>）：<br>Define a way to specify that one or more fields in an object are likely to be highly contended across processor cores so that the VM can arrange for them not to share cache lines with other fields, or other objects, that are likely to be independently accessed.</p></blockquote><h2 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h2><p><img alt data-src="/images/java-juc-atomic-longadder/%E7%83%AD%E7%82%B9%E5%88%86%E7%A6%BB%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>Striped64的核心方法是longAccumulate、doubleAccumulate，两者类似，下面主要看一下longAccumulate，<strong>对于这种代码，个人建议是理解思路即可，毕竟咱们又不是过来修改JDK的，如果真的要修改了或者有类似的需求了，再回来细看即可。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">//x  元素</span><br><span class="line">//fn  更新函数，如果是add可以为null（这个约定避免了longadder中定义额外的变量或者函数）</span><br><span class="line">//wasUncontended 如果CAS在调用之前失败了，这个值为false</span><br><span class="line">final void longAccumulate(long x, LongBinaryOperator fn,</span><br><span class="line">                          boolean wasUncontended) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    //获取当前线程的probe值，如果为0，则需要初始化该线程的probe值</span><br><span class="line">    if ((h = getProbe()) == 0) &#123;</span><br><span class="line">    ThreadLocalRandom.current(); // force initialization</span><br><span class="line">        h = getProbe();</span><br><span class="line">        wasUncontended = true;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean collide = false;  // True if last slot nonempty</span><br><span class="line">    done: for (;;) &#123;</span><br><span class="line">        Cell[] cs; Cell c; int n; long v;</span><br><span class="line">        //Cells不为空，进行操作</span><br><span class="line">        if ((cs = cells) != null &amp;&amp; (n = cs.length) &gt; 0) &#123;</span><br><span class="line">            //通过（hashCode &amp; (length - 1)）这种算法来实现取模 有种看到HashMap代码的感觉</span><br><span class="line">            //如果当前位置为null说明需要初始化</span><br><span class="line">            if ((c = cs[(n - 1) &amp; h]) == null) &#123;</span><br><span class="line">                //判断锁状态</span><br><span class="line">                if (cellsBusy == 0) &#123;       // Try to attach new Cell</span><br><span class="line">                    Cell r = new Cell(x);   // Optimistically create</span><br><span class="line">                    //再次判断锁状态，同时获取锁</span><br><span class="line">                    if (cellsBusy == 0 &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                        try &#123;               // Recheck under lock</span><br><span class="line">                            Cell[] rs; int m, j;</span><br><span class="line">                            if ((rs = cells) != null &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; 0 &amp;&amp;</span><br><span class="line">                                rs[j = (m - 1) &amp; h] == null) &#123;</span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                //创建成功跳出</span><br><span class="line">                                break done;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; finally &#123;</span><br><span class="line">                            //释放锁</span><br><span class="line">                            cellsBusy = 0;</span><br><span class="line">                        &#125;</span><br><span class="line">                        continue;           // Slot is now non-empty</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = false;</span><br><span class="line">            &#125;</span><br><span class="line">            //运行到此说明cell的对应位置上已经有相应的Cell了，</span><br><span class="line">            //不需要初始化了</span><br><span class="line">            //CAS操作已经失败了，出现了竞争</span><br><span class="line">            else if (!wasUncontended)       // CAS already known to fail</span><br><span class="line">                wasUncontended = true;      // Continue after rehash</span><br><span class="line">            //这里尝试将x值加到a的value上 </span><br><span class="line">            else if (c.cas(v = c.value,</span><br><span class="line">                           (fn == null) ? v + x : fn.applyAsLong(v, x)))</span><br><span class="line">                //如果尝试成功，跳出循环，方法退出</span><br><span class="line">                break;</span><br><span class="line">            //cell数组最大为cpu的数量，</span><br><span class="line">            //cells != as表明cells数组已经被更新了 </span><br><span class="line">            //标记为最大状态或者说是过期状态</span><br><span class="line">            else if (n &gt;= NCPU || cells != cs)</span><br><span class="line">                collide = false;            // At max size or stale</span><br><span class="line">            else if (!collide)</span><br><span class="line">                collide = true;</span><br><span class="line">            //扩容 当前容量 * 2</span><br><span class="line">            else if (cellsBusy == 0 &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (cells == cs)        // Expand table unless stale</span><br><span class="line">                        cells = Arrays.copyOf(cs, n &lt;&lt; 1);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    cellsBusy = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = false;</span><br><span class="line">                continue;                   // Retry with expanded table</span><br><span class="line">            &#125;</span><br><span class="line">            h = advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">        //尝试获取锁之后扩大Cells</span><br><span class="line">        else if (cellsBusy == 0 &amp;&amp; cells == cs &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">            try &#123;                           // Initialize table</span><br><span class="line">                if (cells == cs) &#123;</span><br><span class="line">                    //初始化cell表，初始容量为2。 </span><br><span class="line">                    Cell[] rs = new Cell[2];</span><br><span class="line">                    rs[h &amp; 1] = new Cell(x);</span><br><span class="line">                    cells = rs;</span><br><span class="line">                    break done;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                //释放cellsBusy锁</span><br><span class="line">                cellsBusy = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果创建cell表由于竞争导致失败，尝试将x累加到base上</span><br><span class="line">        // Fall back on using base</span><br><span class="line">        else if (casBase(v = base,</span><br><span class="line">                         (fn == null) ? v + x : fn.applyAsLong(v, x)))</span><br><span class="line">            break done;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * CASes the cellsBusy field from 0 to 1 to acquire lock.</span><br><span class="line"> */</span><br><span class="line">final boolean casCellsBusy() &#123;</span><br><span class="line">    return CELLSBUSY.compareAndSet(this, 0, 1);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * CASes the base field.</span><br><span class="line"> */</span><br><span class="line">final boolean casBase(long cmp, long val) &#123;</span><br><span class="line">    return BASE.compareAndSet(this, cmp, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段的核心是这样的：</p><ul><li>longAccumulate会根据当前线程来计算一个哈希值，然后根据(hashCode &amp; (length - 1))取模，以定位到该线程被分散到的Cell数组中的位置</li><li>如果Cell数组还没有被创建，那么就去获取cellBusy这个锁（相当于锁，但是更为轻量级），如果获取成功，则初始化Cell数组，初始容量为2，初始化完成之后将x包装成一个Cell，哈希计算之后分散到相应的index上。如果获取cellBusy失败，那么会试图将x累计到base上，更新失败会重新尝试直到成功。</li><li>如果Cell数组已经被初始化过了，那么就根据线程的哈希值分散到一个Cell数组元素上，获取这个位置上的Cell并且赋值给变量a，如果a为null，说明该位置还没有被初始化，那么就初始化，当然在初始化之前需要竞争cellBusy变量。</li><li>如果Cell数组的大小已经最大了（大于等于CPU的数量），那么就需要重新计算哈希，来重新分散当前线程到另外一个Cell位置上再走一遍该方法的逻辑，否则就需要对Cell数组进行扩容，然后将原来的计数内容迁移过去。由于Cell里面保存的是计数值，所以扩容后没有必要做其他处理，直接根据index将旧的Cell数组内容复制到新的Cell数组中。</li></ul><h1 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h1><blockquote><p>LongAdder的基本思路就是分散热点，将value值分散到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。如果要获取真正的long值，只要将各个槽中的变量值累加返回。</p></blockquote><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>保持一个或者多个变量，初始值设置为零用于求和。当更新出现多个线程竞争时，变量集合动态增长以减少争用。最后当需要求和的时候或者说需要这个Long型的值时，可以通过把当前这些变量求和，合并后得出最终的和。</p><p><font color="DeepPink">LongAdder在一些高并发场景下表现要比AtomicLong好，比如多个线程同时更新一个求和的变量，比如统计集合的数量，但是不能用于细粒度同步控制，换句话说这个是可能有误差的（因为更新与读取是并行的）。在低并发场景场景下LongAdder和AtomicLong的性能表现没什么差别，但是当高并发竞争的时候，这个类将具备更好的吞吐性能，但是相应的也会耗费相当的空间。</font></p><p>LongAdder继承了Number抽象类，但是并没有实现一些方法例如: equals、hashCode、compareTo，因为LongAdder实例的预期用途是进行一些比较频繁的变化，所以也不适合作为集合的key。</p><h2 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h2><p>看一下LongAdder有哪些方法：<br><img alt data-src="/images/java-juc-atomic-longadder/LongAdder%E5%87%BD%E6%95%B0%E5%88%97%E8%A1%A8.png"></p><p>下面主要解析LongAdder increment、sum方法，先看一下源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Equivalent to &#123;@code add(1)&#125;.</span><br><span class="line"> */</span><br><span class="line">public void increment() &#123;</span><br><span class="line">add(1L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Adds the given value.</span><br><span class="line">*</span><br><span class="line">* @param x the value to add</span><br><span class="line">*/</span><br><span class="line">public void add(long x) &#123;</span><br><span class="line">    Cell[] cs; long b, v; int m; Cell c;</span><br><span class="line">    if ((cs = cells) != null || !casBase(b = base, b + x)) &#123;</span><br><span class="line">    //到了这里 表明cs不为null or 线程有并发冲突，导致caseBase失败</span><br><span class="line">        boolean uncontended = true;</span><br><span class="line">        if (cs == null || // cells 为null</span><br><span class="line">            (m = cs.length - 1) &lt; 0 || // cells 不为null 但只有一个元素</span><br><span class="line">            (c = cs[getProbe() &amp; m]) == null || //哈希取模 对应位置元素为null</span><br><span class="line">            !(uncontended = c.cas(v = c.value, v + x))) //cas 替换失败（并发竞争）</span><br><span class="line">            longAccumulate(x, null, uncontended);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* CASes the base field (Striped64类中的方法)</span><br><span class="line">*/</span><br><span class="line">final boolean casBase(long cmp, long val) &#123;</span><br><span class="line">    return BASE.compareAndSet(this, cmp, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//当在sum的过程中，有可能别的线程正在操作cells（因为没有加锁）</span><br><span class="line">//sum取的值，不一定准确</span><br><span class="line">public long sum() &#123;</span><br><span class="line">     Cell[] cs = cells;</span><br><span class="line">     long sum = base;</span><br><span class="line">     if (cs != null) &#123;</span><br><span class="line">        for (Cell c : cs)</span><br><span class="line">            if (c != null)</span><br><span class="line">                sum += c.value;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LongAdder-vs-AtomicLong-Performance"><a href="#LongAdder-vs-AtomicLong-Performance" class="headerlink" title="LongAdder vs AtomicLong Performance"></a>LongAdder vs AtomicLong Performance</h2><p><a href="http://blog.palominolabs.com/2014/02/10/java-8-performance-improvements-longadder-vs-atomiclong/" target="_blank" rel="noopener">Java 8 Performance Improvements: LongAdder vs AtomicLong</a></p><h1 id="对比LongAccumulator"><a href="#对比LongAccumulator" class="headerlink" title="对比LongAccumulator"></a>对比LongAccumulator</h1><p>LongAdder类可以看做是LongAccumulator的一个特例，LongAccumulator提供了比LongAdder更强大、灵活的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Creates a new instance using the given accumulator function</span><br><span class="line"> * and identity element.</span><br><span class="line"> * @param accumulatorFunction a side-effect-free function of two arguments</span><br><span class="line"> * @param identity identity (initial value) for the accumulator function</span><br><span class="line">*/</span><br><span class="line">public LongAccumulator(LongBinaryOperator accumulatorFunction,</span><br><span class="line">                           long identity) &#123;</span><br><span class="line">    this.function = accumulatorFunction;</span><br><span class="line">    base = this.identity = identity;</span><br><span class="line">&#125;</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface LongBinaryOperator &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Applies this operator to the given operands.</span><br><span class="line"> *</span><br><span class="line"> * @param left the first operand</span><br><span class="line"> * @param right the second operand</span><br><span class="line"> * @return the operator result</span><br><span class="line">*/</span><br><span class="line">long applyAsLong(long left, long right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数其中accumulatorFunction一个双目运算接口，根据输入的两个参数返回一个计算值，identity则是LongAccumulator累加器的初始值。</p><p>accumulatorFunction主要用于Striped64 longAccumulate中使用，如果fn==null，则默认是相加，否则会调用fn.applyAsLong(v, x)</p><blockquote><p>LongAccumulator相比于LongAdder，可以为累加器提供非0的初始值，而LongAdder只能提供默认的0值。<br>另外，LongAccumulator还可以指定累加规则，比如累加或者相乘，只需要在构造LongAccumulator时，传入自定义的双目运算器即可，后者则内置累加规则。</p></blockquote><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://github.com/jiankunking/openjdk12/blob/master/src/java.base/share/classes/java/util/concurrent/atomic/LongAdder.java" target="_blank" rel="noopener">https://github.com/jiankunking/openjdk12/blob/master/src/java.base/share/classes/java/util/concurrent/atomic/LongAdder.java</a></p><p><a href="https://github.com/jiankunking/openjdk12/blob/master/src/java.base/share/classes/jdk/internal/vm/annotation/Contended.java" target="_blank" rel="noopener">https://github.com/jiankunking/openjdk12/blob/master/src/java.base/share/classes/jdk/internal/vm/annotation/Contended.java</a></p><p><a href="https://www.jianshu.com/p/9a7de5644dd4" target="_blank" rel="noopener">https://www.jianshu.com/p/9a7de5644dd4</a></p><p><a href="http://openjdk.java.net/jeps/142" target="_blank" rel="noopener">http://openjdk.java.net/jeps/142</a></p><p><a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-November/007309.html" target="_blank" rel="noopener">http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-November/007309.html</a></p>]]></content>
      
      
      <categories>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
            <tag> Concurrent </tag>
            
            <tag> Atomic </tag>
            
            <tag> LongAdder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JRockit权威指南深入理解JVM 笔记</title>
      <link href="/java-jrockit-note.html"/>
      <url>/java-jrockit-note.html</url>
      
        <content type="html"><![CDATA[<p>本文整理自：《JRockit权威指南深入理解JVM》 作者：Marcus Hirt , Marcus Lagergren</p><p>出版时间：2018-12-10</p><a id="more"></a><h1 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h1><h2 id="将应用程序迁移到JRockit"><a href="#将应用程序迁移到JRockit" class="headerlink" title="将应用程序迁移到JRockit"></a>将应用程序迁移到JRockit</h2><h3 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h3><p>在 JRockit JVM中,主要有3类命令行选项,分别是系统属性、标准选项(以-X开头)和非标准选项(以-XX开头)</p><p>1、系统属性</p><p>设置JVM启动参数的方式有多种。以-D开头的参数会作为系统属性使用,这些属性可以为Java类库(如RMI等)提供相关的配置信息。例如,在启动的时候,如果设置了-Dcom.Rockin.mc.debug=true参数,则JRockit Mission Control会打印出调试信息。不过,R28之后的JRockit JVM版本废弃了很多之前使用过的系统属性,转而采用非标准选项和类似 HotSpot中虚拟机标志(VM flag)的方式设置相关选项</p><p>2、标准选项</p><p>以-X开头的选项是大部分JVM厂商都支持的通用设置。例如,用于设置堆大小最大值的选项-Xmx在包括 JRockit在内的大部分JVM中都是相同的。当然,也存在例外,如JRockit中的选项-Xverbose会打印出可选的子模块日志信息,而在 HotSpot中,类似的(但实际上有更多的限制)选项是-verbose</p><p>3、非标准选项</p><p>以-XX开头的命令行选项是各个JVM厂商自己定制的。这些选项可能会在将来的某个版本中被废弃或修改。如果JVM的参数配置中包含了以-XX开头的命令行选项,则在将Java应用程序从一种JVM迁移到另一种时,应该在启动M之前去除这些非标准选项确定了新的VM选项后才可以启动Java应用程序。</p><h1 id="自适应代码生成"><a href="#自适应代码生成" class="headerlink" title="自适应代码生成"></a>自适应代码生成</h1><h2 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h2><h3 id="字节码格式"><a href="#字节码格式" class="headerlink" title="字节码格式"></a>字节码格式</h3><p><a href="https://github.com/jiankunking/jvm-opcode" target="_blank" rel="noopener">Opcodes for the Java Virtual Machine</a></p><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>程序,包含数据和代码两部分,其中数据作为操作数使用。对于字节码程序来说,如果操作数非常小或者很常用(如常量0),则这些操作数是直接内嵌在字节码指令中的。</p><p>较大块的数据,例如常量字符串或比较大的数字,是存储在class文件开始部分的常量池(constant pool)中的。当使用这类数据作为操作数时,使用的是常量池中数据的索引位置,而不是实际数据本身。以字符串数据aVeryLong FunctionName为例,如果在编译方法时每次都要重新编码这个字符串的话,那字节码就谈不上压缩存储了。</p><p>此外,Java程序中的方法、属性和类的元数据等也作为clas文件的组成部分,存储在常量池中。</p><h2 id="自适应代码生成-1"><a href="#自适应代码生成-1" class="headerlink" title="自适应代码生成"></a>自适应代码生成</h2><h3 id="优化动态程序"><a href="#优化动态程序" class="headerlink" title="优化动态程序"></a>优化动态程序</h3><p>在汇编代码中,方法调用是通过call指令完成的。不同平台上call指令的具体形式不尽相同,不同类型的call指令,其具体格式也不尽相同。</p><p>在面向对象的语言中,虚拟方法分派通常被编译为对分派表(dispatch table)中地址的间接调用(indirect call,即需要从内存中读取真正的调用地址)。这是因为,根据不同的类继承结构分派虚拟调用时可能会有多个接收者。每个类中都有一个分派表,其中包含了其虚拟调用的接收者信息。静态方法和确知只有一个接收者的虚拟方法可以被编译为对固定调用地址的直接调用(direct call)。一般来说,这可以大大加快执行速度。<br><img alt data-src="/images/java-jrockit-note/%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8%E8%99%9A%E6%8B%9F%E8%B0%83%E7%94%A8.png"></p><p>假设应用程序是使用C++开发的,对代码生成器来说,在编译时已经可以获取到程序的所有结构性信息。例如,由于在程序运行过程中,代码不会发生变化,所以在编译时就可以从代码中判断出,某个虚拟方法是否只有一种实现。正因如此,编译器不仅不需要因为废弃代码而记录额外的信息,还可以将那些只有一种实现的虚拟方法转化为静态调用。</p><p>假如应用程序是使用Java开发的,起初某个虚拟方法可能只有一种实现,但Java允许在程序运行过程中修改方法实现。当JIT编译器需要编译某个虚拟方法时,更喜欢的是那些永远只存在一种实现的,这样编译器就可以像前面提到的C+编译器一样做很多优化,例如将虚拟调用转化为直接调用。但是,由于Java允许在程序运行期间修改代码,如果某个方法没有声明fina1修饰符,那它就有可能在运行期间被修改,即使它看起来几乎不可能有其他实现,编译器也不能将之优化为直接调用。</p><p>在Java世界中,有一些场景现在看起来一切正常,编译器可以大力优化代码,但是如果某天程序发生了改变的话,就需要将相关的优化全部撤销。对于Java来说,为了能够媲美C++程序的执行速度,就需要一些特殊的优化措施。</p><p>JVM使用的策略就是“赌”。JVM代码生成策略的假设条件是,正在运行的代码永远不变。事实上,大部分时间里确实如此。但如果正在运行的代码发生了变化,违反了代码优化的假设条件,就会触发其簿记系统(bookkeeping system)的回调功能。此时,基于原先假设条件生成的代码就需要被废弃掉,重新生成,例如为已经转化为直接调用的虚拟调用重新生成相关代码。因此,“赌输”的代价是很大的,但如果“赌赢”的概率非常高,则从中获得的性能提升就会非常大,值得一试。</p><p>一般来说,JM和JT编译器所做的典型假设包括以下几点：</p><ul><li>虚拟方法不会被覆盖。由于某个虚拟方法只存在一种实现,就可以将之优化为一个直接调用。</li><li>浮点数的值永远不会是NaN。大部分情况下,可以使用硬件指令来替换对本地浮点数函数库的调用。</li><li>某些try语句块中几乎不会抛出异常。因此,可以将catch语句块中的代码作为冷方法对待。</li><li>对于大多数三角函数来说,硬件指令fsin都能够达到精度要求。如果真的达不到,就抛出异常,调用本地浮点数函数库完成计算。</li><li>锁竞争并不会太激烈,初期可以使用自旋锁(spinlock)替代。</li><li>锁可能会周期性地被同一个线程获取和释放,所以,可以将对锁的重复获取操作和重复释放操作直接省略掉。</li></ul><h2 id="深入JIT编译器"><a href="#深入JIT编译器" class="headerlink" title="深入JIT编译器"></a>深入JIT编译器</h2><h3 id="优化字节码"><a href="#优化字节码" class="headerlink" title="优化字节码"></a>优化字节码</h3><blockquote><p>有些时候,对Java源代码做优化会适得其反。绝大部分写出可读性很差的代码的人都声称是为了优化性能,其实就是照着一些基准测试报告的结论写代码,而这些性能测试往往只涉及了字节码解释执行,没有经过JT编译器优化,所以并不能代表应用程序在运行时的真实表现。例如,某个服务器端应用程序中包含了大量对数组元素的迭代访问操作,程序员参考了那些报告中的结论,没有设置循环条件,而是写一个无限for循环,置于try语句块中,并在catch语句块中捕获ArrayIndexOutOfBoundsException异常。这种糟糕的写法不仅使代码可读性极差,而且一旦运行时对之优化编译的话,其执行效率反而比普通循环方式低得多。原因在于,JVM的基本假设之一就是“异常是很少发生的”。基于这种假设,JM会做一些相关优化,所以当真的发生异常时,处理成本就很高。</p></blockquote><h2 id="代码流水线"><a href="#代码流水线" class="headerlink" title="代码流水线"></a>代码流水线</h2><h3 id="代码生成概述"><a href="#代码生成概述" class="headerlink" title="代码生成概述"></a>代码生成概述</h3><blockquote><p>在生成优化代码时,如何分配寄存器非常重要。编译器教材上都将寄存器分配问题作为图的着色问题处理,这是因为同时用到的两个变量不能共享同一个寄存器,从这点上讲,与着色问题相同。同时使用的多个变量可以用图中相连接的节点来表示,这样,寄存器分配问题就可以被抽象为“如何为图中的节点着色,5能使相连节点有不同的颜色”。这里可用颜色的数量等于指定平台上可用寄存器的数量。不过,遗憾的是,从计算复杂性上讲,着色问题是NP-hard的,也就是说现在还没有一个高效的算法(指可以在多项式时间内完成计算)能解决这个问题。但是,着色问题可以在线性对数时间内给出近似解,因此大多数编译器都使用着色算法的某个变种来处理寄存器分配问题。</p></blockquote><h1 id="自适应内存管理"><a href="#自适应内存管理" class="headerlink" title="自适应内存管理"></a>自适应内存管理</h1><h2 id="堆管理基础"><a href="#堆管理基础" class="headerlink" title="堆管理基础"></a>堆管理基础</h2><h3 id="对象的分配与释放"><a href="#对象的分配与释放" class="headerlink" title="对象的分配与释放"></a>对象的分配与释放</h3><p><font color="DeepPink">一般来说,为对象分配内存时,并不会直接在堆上划分内存,而是先在线程局部缓冲(thread local buffer)或其他类似的结构中找地方放置对象,然后随着应用程序的运行、新对象的不断分配,垃圾回收逐次执行,这些对象可能最终会被提升到堆中保存,也有可能会当作垃圾被释放掉。</font></p><p>为了能够在堆中给新创建的对象找一个合适的位置,内存管理系统必须知道堆中有哪些地方是空闲的,即还没有存活对象占用。内存管理系统使用空闲列表(free list)—串联起内存中可用内存块的链表,来管理内存中可用的空闲区域,并按照某个维度的优先级排序。</p><p>在空闲列表中搜索足够存储新对象的空闲块时,可以选择大小最适合的空闲块,也可以选择第一个放得下的空闲块。这其中会用到几种不同的算法去实现,各有优劣,后文会详细讨论。</p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p><font color="DeepPink">在后文中,根集合(root set)专指上述搜索算法的初始输入集合,即开始执行引用跟踪时的存活对象集合。一般情况下,根集合中包括了因为执行垃圾回收而暂停的应用程序的当前栈帧中所有的对象,包含了可以从当前线程上下文的用户栈和寄存器中能得到的所有信息。此外,根集合中还包含全局数据,例如类的静态属性。简单来说就是,根集合中包含了所有无须跟踪引用就可以得到的对象。</font></p><p>Java使用的是准确式垃圾回收器(exact garbage collector),可以将对象指针类型数据和其他类型的数据区分开,只需要将元数据信息告知垃圾回收器即可,这些元数据信息,一般可以从Java方法的代码中得到。</p><p>近些年,使用信号来暂停线程的方式受到颇多争议。实践发现,在某些操作系统上,尤以Linux为例,应用程序对信号的使用和测试很不到位,还有一些第三方的本地库不遵守信号约定,导致信号冲突等事件的发生。因此,与信号相关的外部依赖已经不再可靠。</p><h3 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h3><p>事实上,将堆划分为两个或多个称为代(generation)的空间,并分别存放具有不同长度生命周期的对象,可以提升垃圾回收的执行效率。<font color="DeepPink">在JRockit中,新创建(young)的对象存放在称为新生代(nursery)的空间中,一般来说,它的大小会比老年代(old collections)小很多,随着垃圾回收的重复执行,生命周期较长的对象会被提升(promote)到老年代中。</font>因此,新生代垃圾回收和老年代垃圾回收两种不同的垃圾回收方式应运而生,分别用于对各自空间中的对象执行垃圾回收。</p><p>新生代垃圾回收的速度比老年代快几个数量级,即使新生代垃圾回收的频率更高,执行效率也仍然比老年代垃圾回收强,这是因为大多数对象的生命周期都很短,根本无须提升到老年代。理想情况下,新生代垃圾回收可以大大提升系统的吞吐量,并消除潜在的内存碎片。</p><h4 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h4><p>在实现分代式垃圾回收时,大部分JVM都是用名为写屏障(write barrier)的技术来记录执行垃圾回收时需要遍历堆的哪些部分。当对象A指向对象B时,即对象B成为对象A的属性的值时,就会触发写屏障,在完成属性域赋值后执行一些辅助操作。</p><p>写屏障的传统实现方式是将堆划分成多个小的连续空间(例如每块512字节),每块空间称为卡片(card),于是,堆被映射为一个粗粒度的卡表(card table)。当Java应用程序将某个对象赋值给对象引用时,会通过写屏障设置脏标志位(dirty bit),将该对象所在的卡片标记为脏。</p><p>这样,遍历从老年代指向新生代的引用时间得以缩短,垃圾回收器在做新生代垃圾回收时只需要检查老年代中被标记为脏的卡片所对应的内存区域即可。</p><h3 id="JRockit中的垃圾回收"><a href="#JRockit中的垃圾回收" class="headerlink" title="JRockit中的垃圾回收"></a>JRockit中的垃圾回收</h3><h4 id="老年代垃圾回收"><a href="#老年代垃圾回收" class="headerlink" title="老年代垃圾回收"></a>老年代垃圾回收</h4><p>JRockit不仅将卡表应用于分代式垃圾回收,还用在并发标记阶段结束时的清理工作,避免搜索整个存活对象图。这是因为JRockit需要找出在执行并发标记操作时,应用程序又创建了哪些对象。修改引用关系时通过写屏障可以更新卡表,存活对象图中的每个区域使用卡表中的一个卡片表示,卡片的状态可以是干净或者脏,有新对象创建或者对象引用关系修改了的卡片会被标记为脏。在并发标记阶段结束时,垃圾回收器只需要检查那些标记为脏的卡片所对应的堆中区域即可,这样就可以找到在并发标记期间新创建的和被更新过引用关系的对象</p><h2 id="性能与伸缩性"><a href="#性能与伸缩性" class="headerlink" title="性能与伸缩性"></a>性能与伸缩性</h2><h3 id="线程局部分配"><a href="#线程局部分配" class="headerlink" title="线程局部分配"></a>线程局部分配</h3><p><font color="DeepPink">在JRockit中,使用了名为线程局部分配(thread local allocation)的技术来大幅加速对象的分配过程。正常情况下,在线程内的缓冲区中为对象分配内存要比直接在需要同步操作的堆上分配内存快得多。垃圾回收器在堆上直接分配内存时是需要对整个堆加锁的,对于多线程竞争激烈的应用程序来说,这将会是一场灾难。</font>因此,如果每个Java线程能够有一块局部对象缓冲区那么绝大部分的对象分配操作只需要移动一下指针即可完成,在大多数硬件平台上,只需要一条汇编指令就行了。这块转为分配对象而保留的区域,就称为线程局部缓冲区(thread local area,TLA)。</p><p>为了更好地利用缓存,达到更高的性能,一般情况下,TLA的大小介于16KB到128KB之间,当然,也可以通过命令行参数显式指定。<font color="DeepPink">当TLA被填满时,垃圾回收器会将TLA中的内容提升到堆中。因此,可以将TLA看作是线程中的新生代内存空间</font>。</p><p>当Java源代码中有new操作符,并且JT编译器对内存分配执行高级优化之后,内存分配的伪代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">object allocateNewobject(Class objectclass)&#123;</span><br><span class="line">Thread current getcurrentThread():</span><br><span class="line">int objectSize=alignedSize(objectclass)</span><br><span class="line">if(current.nextTLAOffset+objectSize&gt; TLA_SIZE)&#123;</span><br><span class="line">current.promoteTLAToHeap();//慢,而且是同步操作</span><br><span class="line">current.nextTLAOffset=0;</span><br><span class="line">&#125;</span><br><span class="line">Object ptr= current.TLAStart+current.nextTLAOffset:</span><br><span class="line">current.nextTLAOffset + objectSize;</span><br><span class="line">return ptr:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为了说明内存分配问題,在上面的伪代码中省略了很多其他关联操作。例如如果待分配的对象非常大,超过了某个阈值,或对象太大导致无法存放在TLA中,则会直接在堆中为对象分配内存。</p></blockquote><h3 id="NUMA架构"><a href="#NUMA架构" class="headerlink" title="NUMA架构"></a>NUMA架构</h3><p>NUMA(non-uniform memory access,非统一内存访问模型)架构的出现为垃圾回收带来了更多挑战。<font color="DeepPink">在NUMA架构下,不同的处理器核心通常访问各自的内存地址空间,这是为了避免因多个CPU核心访问同一内存地址造成的总线延迟。</font>每个CPU核心都配有专用的内存和总线因此CPU核心在访问其专有内存时速度很快,而要访问相邻CPU核心的内存时就会相对慢些,CPU核心相距越远,访问速度越慢(也依赖于具体配置)传统上,多核CPU是按照UMA(uniform memory access,统一内存访问模型)架构运行的,所有的CPU核心按照统一的模式无差别地访问所有内存。</p><p>为了更好地利用NUMA架构,垃圾回收器线程的组织结构应该做相应的调整。如果某个CPU核心正在运行标记线程,那么该线程所要访问的那部分堆内存最好能够放置在该CPU的专有内存中,这样才能发挥NUMA架构的最大威力。在最坏情况下,如果标记线程所要访问的对象位于其他NUMA节点的专有内存中,这时垃圾回收器通常需要一个启发式对象移动算法。这是为了保证使用时间上相近的对象在存储位置上也能相近,如果这个算法能够正确工作,还是可以带来不小的性能提升的。这里所面临的主要问题是如何避免对象在不同NUMA节点的专有内存中重复移动。理论上,自适应运行时系统应该可以很好地处理这个问题。</p><h3 id="大内存页"><a href="#大内存页" class="headerlink" title="大内存页"></a>大内存页</h3><p>内存分配是通过操作系统及其所使用的页表完成的。操作系统将物理内存划分成多个页来管理,从操作系统层面讲,页是实际分配内存的最小单位。传统上,页的大小是以4KB为基本单位划分的,页操作对进程来说是透明的,进程所使用的是虚拟地址空间,并非真正的物理地址。为了便于将虚拟页面转换为实际的物理内存地址,可使用名为旁路转换缓冲(translation lookaside buffer,TLB)的缓存来加速地址的转换操作。从实现上看,如果页面的容量非常小的话,会导致频繁出现旁路转换缓冲丢失的情况。</p><p>修复这个问题的一种方法就是将页面的容量调大几个数量级,例如以MB为基本单位。现代操作系统普遍倾向于支持这种大内存页机制。</p><p>很明显,当多个进程分别在各自的寻址空间中分配内存,而页面的容量又比较大时,随着使用的页面数量越来越多,碎片化的问题就愈发严重,像进程要分配的内存比页面容量稍微大一点的情况,就会浪费很多存储空间。对于在进程内自己管理内存分配回收、并有大量内存空间可用的运行时来说,这不算什么问题,因为运行时可以通过抽象出不同大小的虚拟页面来解决。</p><blockquote><p>通常情况下,对于那些内存分配和回收频繁的应用程序来说,使用大内存页可以使系统的整体性能至少提升10%。 J Rockit对大内存页有很好的支持。</p></blockquote><h2 id="近实时垃圾回收"><a href="#近实时垃圾回收" class="headerlink" title="近实时垃圾回收"></a>近实时垃圾回收</h2><h3 id="JRockit-Real-Time"><a href="#JRockit-Real-Time" class="headerlink" title="JRockit Real Time"></a>JRockit Real Time</h3><p><font color="DeepPink">低延迟的代价是垃圾回收整体时间的延长</font>。相比于并行垃圾回收,在程序运行的同时并发垃圾回收的难度更大,而频繁中断垃圾回收则可能带来更多的麻烦。事实上,这并非什么大问题,因为大多数使用JRockit Real Time的<font color="DeepPink">用户更关心系统的可预测性,而不是减少垃圾回收的总体时间。大多数用户认为暂停时间的突然增长比垃圾回收总体时间的延长更具危害性</font>。</p><h4 id="软实时的有效性"><a href="#软实时的有效性" class="headerlink" title="软实时的有效性"></a>软实时的有效性</h4><p>软实时是JRockit Real Time的核心机制。但<font color="DeepPink">非确定性系统如何提供指定程度的确定性,例如像垃圾回收器这样的系统如何保证应用程序的暂停时间不会超过某个阈值?严格来说,无法提供这样的保证</font>,但由于这样的极端案例很少,所以也就无关紧要了。</p><p>当然,没有什么万全之策,确实存在无法保证暂停时间的场景。但实践证明,对于那些堆中存活对象约占30%-50%的应用程序来说, JRockit Real Time的表现可以满足服务需要,而且随着JRockit Real Time各个版本的发行,30%-50%这个阈值在不断提升,可支持的暂停时间阈值则不断降低。</p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul><li>高效的并行执行</li><li>细分垃圾回收过程,将之变成几个可回滚、可中断的子任务(work packet)</li><li>高效的启发式算法</li></ul><p><font color="DeepPink">事实上,实现低延迟的关键仍是尽可能多让Java应用程序运行,保持堆的使用率和碎片化程度在一个较低的水平</font>。在这一点上, JRockit Real Time使用的是贪心策略,即尽可能推迟STW式的垃圾回收操作,希望问题能够由应用程序自身解决,或者能够减少不得不执行STW式操作的情况,最好在具体执行的时候需要处理的对象也尽可能少一些。</p><p>JRockit Real Time中,垃圾回收器的工作被划分为几个子任务。如果在执行其中某个子任务时(例如整理堆中的某一部分内存),应用程序的暂停时间超过了阈值,那么就放弃该子任务恢复应用程序的执行。用户根据业务需要指定可用于完成垃圾回收的总体时间,有些时候,某些子任务已经完成,但没有足够的时间完成整个垃圾回收工作,这时为了保证应用程序的运行,不得不废弃还未完成的子任务,待到下次垃圾回收的时候再重新执行,指定的响应时间越短,则废弃的子任务可能越多。</p><p>前面介绍过的标记阶段的工作比较容易调整,可以与应用程序并发执行。但清理和整理阶段则需要暂停应用程序线程(STW)。幸运的是,标记阶段会占到垃圾回收总体时间的90%。如果暂停应用程序的时间过长,则不得不终止当前垃圾回收任务,重新并发执行,期望问题可以自动解决。之所以将垃圾回收划分为几个子任务就是为了便于这一目标的实现。</p><h2 id="内存操作相关API"><a href="#内存操作相关API" class="headerlink" title="内存操作相关API"></a>内存操作相关API</h2><h3 id="析构方法"><a href="#析构方法" class="headerlink" title="析构方法"></a>析构方法</h3><blockquote><p>Java中的析构函数的设计就是一个失误,应避免使用。</p></blockquote><p>这不仅仅是我们的意见,也是Java社区的一致意见。</p><h3 id="JVM的行为差异"><a href="#JVM的行为差异" class="headerlink" title="JVM的行为差异"></a>JVM的行为差异</h3><p>对于JVM来说,一定谨记,编程语言只能提醒垃圾回收器工作。就Java而言,在设计上它本身并不能精确控制内存系统。例如,假设两个ⅣM厂商所实现软引用在缓存中具有相同的存活时间,这本就是不切实际的。</p><p>另外一个问题就是大量用户对System.gc()方法的错误使用。<font color="DeepPink">System.gc()方法仅仅是提醒运行时“现在可以做垃圾回收了”。在某些JVM实现中,频繁调用该方法导致了频繁的垃圾回收操作,而在某些JVM实现中,大部分时间忽略了该调用。</font></p><p>我过去任职为性能顾问期间,多次看到该方法被滥用。很多时候,只是去掉对 System.gc方法的几次调用就可以大幅提升性能,这也是 JRock中会有命令行参数-xx:A11owSystemGC=Fa1se来禁用System,gc方法的原因。</p><h2 id="陷阱与伪优化"><a href="#陷阱与伪优化" class="headerlink" title="陷阱与伪优化"></a>陷阱与伪优化</h2><p>部分开发人员在写代码时,有时会写一些“经过优化的”的代码,期望可以帮助完成垃圾回收的工作,但实际上,这只是他们的错觉。记住,过早优化是万恶之源。就Java来说,很难在语言层面控制垃圾回收的行为。这里的主要问题时,开发人员误以为垃圾回收器有固定的运行模式,并妄图去控制它。</p><p>除了垃圾回收外,对象池(object poc)也是Java中常见的伪优化(false optimization)。有人认为,保留一个存活对象池来重新使用已创建的对象可以提升垃圾回收的性能,但实际上,对象池不仅增加了应用程序的复杂度,还很容易出错。对于现代垃圾收集器来说,使用java.1ang.ref.Reference系列类实现缓存,或者直接将无用对象的引用置为nu11就好了,不用多操心。</p><p>事实上,基于现代VM,如果能够合理利用书本上的技巧,例如正确使用java.1ang.ref.Reference系列类,注意Java的动态特性,完全可以写出运行良好的应用程序。<font color="DeepPink">如果应用程序真的有实时性要求,那么一开始就不该用Java编写,而应该使用那些由程序员手动控制内存的静态编程语言来实现应用程序。</font></p><h2 id="JRockit中的内存管理"><a href="#JRockit中的内存管理" class="headerlink" title="JRockit中的内存管理"></a>JRockit中的内存管理</h2><p><font color="DeepPink">需要注意的是,花大力气鼓捣JVM参数并不一定会使应用程序性能有多么大的提升,而且反而可能会干扰JM的正常运行。</font></p><h1 id="线程与同步"><a href="#线程与同步" class="headerlink" title="线程与同步"></a>线程与同步</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>每个对象都持有与同步操作相关的信息,例如当前对象是否作为锁使用,以及锁的具体实现等。一般情况下,为了便于快速访问,这些信息被保存在每个对象的对象头的锁字(lock word)中。JRockit使用锁字中的一些位来存储垃圾回收状态信息,虽然其中包含了垃圾回收信息,但是本书还是称之为锁字。</p><p>对象头还包含了指向类型信息的指针,在 JRockit中,这称为类块(class block)下图是 JRockit中Java对象在不同的CPU平台上的内存布局。为了节省内存,并加速解引用操作,对象头中所有字的长度是32位。类块是一个32位的指针,指向另一个外部结构,该结构包含了当前对象的类型信息和虚分派表(virtual dispatch table)等信息。</p><p><img alt data-src="/images/java-jrockit-note/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E5%B8%83%E5%B1%80.png"><br>就目前来看,在绝大部分JVM(包括JRockit)中,对象头是使用两个32位长的字来表示的。在JRockit中,偏移为0的对象指针指向当前对象的类型信息,接下来是4字节的锁字。在SPARC平台上,对象头的布局刚好反过来,因为在使用原子指令操作指针时,如果没有偏移的话,效率会更高。与锁字不同,类块并不为原子操作所使用,因此在SPARC平台上,类块被放在锁字后面。</p><blockquote><p>原子操作(atomic operation)是指全部执行或全部不执行的本地指令。当原子指令全部执行时,其操作结果需要对所有潜在访问者可见。</p></blockquote><p><font color="DeepPink">原子操作用于读写锁字,具有排他性,这是实现JVM中同步块的基础。</font></p><h3 id="难以调试"><a href="#难以调试" class="headerlink" title="难以调试"></a>难以调试</h3><blockquote><p>死锁是指两个线程都在等待对方释放自己所需的资源,结果导致两个线程都进入休眠状态。很明显,它们再也醒不过来了。活锁的概念与死锁类似,区别在于线程在竟争时会采取主动操作,但无法获取锁。这就像两个人面对面前进,在一个很窄的走廊相遇,为了能继续前进,他们都向侧面移动,但由于移动的方向相反导致还是无法前进。</p></blockquote><h2 id="Java-API"><a href="#Java-API" class="headerlink" title="Java API"></a>Java API</h2><h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3><p>在Java中,关键字synchronized用于定义一个临界区,既可以是一段代码块,也可以是个完整的方法,如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void setGadget(Gadget g)&#123;</span><br><span class="line">this.gadget = g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法定义中包含synchronized关键字,因此每次只能有一个线程修改给定对象的gadget域。</p><p><font color="DeepPink">在同步方法中,监视器对象是隐式的,即当前对象this,而对静态同步方法来说,监视器对象是当前对象的类对象。</font>上面的示例代码与下面的代码是等效的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void setGadget(Gadget g)&#123;</span><br><span class="line">synchronized(this)&#123;</span><br><span class="line">this.gadget = g;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="java-lang-Thread类"><a href="#java-lang-Thread类" class="headerlink" title="java.lang.Thread类"></a>java.lang.Thread类</h3><p>Java中的线程也有优先级概念,但是否真的起作用取决于JVM的具体实现。setPriority方法用于设置线程的优先级,提示JVM该线程更加重要或不怎么重要。当然,对于大多数JM来说,显式地修改线程优先级没什么大帮助。当运行时“有更好的方案”时, JRockit JVM甚至会忽略Java线程的优先级。</p><p>正在运行的线程可以通过调用yield方法主动放弃剩余的时间片,以便其他线程运行,自身休眠(调用wait方法)或等待其他线程结束再运行(调用join方法)。</p><h3 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h3><p>在多线程环境下,对某个属性域或内存地址进行写操作后,其他正在运行的线程未必能立即看到这个结果。在某些场景中,要求所有线程在执行时需要得知某个属性最新的值,为此,Java提供了关键字volatile来解决此问题。</p><p>使用volatile修饰属性后,可以保证对该属性域的写操作会直接作用到内存中。原本,数据操作仅仅将数据写到CPU缓存中,过一会再写到内存中,正因如此,在同一个属性域上,不同的线程可能看到不同的值。目前,JVM在实现volatile关键字时,是通过J在写属性操作后插入内存屏障代码来实现的,只不过这种方法有一点性能损耗。</p><p>人们常常难以理解“为什么不同的线程会在同一个属性域上看到不同的值”。<font color="DeepPink">一般来说,目前的机器的内存模型已经足够强,或者应用程序的本身结构就不容易使非volatile属性出现这个问题。但是,考虑到JIT优化编译器可能会对程序做较大改动,如果开发人员不留心的话,还是会出现问题的。</font>下面的示例代码解释了在Java程序中,为什么内存语义如此重要,尤其是当问题还没表现出来的时候。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class My Thread extends Thread&#123;</span><br><span class="line">private volatile boolean finished;</span><br><span class="line">public void run()&#123;</span><br><span class="line">while(!finished)&#123;</span><br><span class="line">   //</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public void signalDone()&#123;</span><br><span class="line">this.finished = true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果定义变量finished时没有加上volatile关键字,那么在理论上,JIT编译器在优化时,可能会将之修改为只在循环开始前加载一次finished的值,但这就改变了代码原本的含义如果finished的值是false,那么程序就会陷入无限循环,即使其他线程调用了signalDone方法也没用。<font color="DeepPink">Java语言规范指明,如果编译器认为合适的话,可以为非 volatile变量在线程内创建副本以便后续使用。</font></p><blockquote><p>由于一般会使用内存屏障来实现vo1ati1e关键字的语义,会导致CPU缓存失效,降低应用程序整体性能,使用的时候要谨慎。</p></blockquote><h2 id="Java中线程与同步机制的实现"><a href="#Java中线程与同步机制的实现" class="headerlink" title="Java中线程与同步机制的实现"></a>Java中线程与同步机制的实现</h2><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>现在CPU架构中,普遍使用了数据缓存机制以大幅提升CPU对数据的读写速度,减轻处理器总线的竞争程度。正如所有的缓存系统一样,这里也存在一致性问题,对于多处理器系统来说尤其重要,因为多个处理器有可能同时访问内存中同一位置的数据内存模型定义了不同的CPU,在同时访问内存中同一位置时,是否会看到相同的值的情况。</p><p>强内存模型(例如x86平台)是指,当某个CPU修改了某个内存位置的值后,其他的CPU几乎自动就可以看到这个刚刚保存的值。在这种内存模型之下,内存写操作的执行顺序与代码中的排列顺序相同。弱内存模型(例如IA-64平台)是指,当某个CPU修改了某个内存位置的值后其他的CPU不一定可以看到这个刚刚保存的值(除非CPU在执行写操作时附有特殊的内存屏障类指令),更普遍低说,所有由Java程序引起的内存访问都应该对其他所有CPU可见,但事实上却不能保证立即可见。</p><h3 id="同步的实现"><a href="#同步的实现" class="headerlink" title="同步的实现"></a>同步的实现</h3><h4 id="原生机制"><a href="#原生机制" class="headerlink" title="原生机制"></a>原生机制</h4><p>从计算机最底层CPU结构来说,同步是使用原子指令实现的,各个平台的具体实现可能有所不同。以x86平台为例,它使用了专门的锁前缀(lock prefix)来实现多处理器环境中指令的原子性。</p><p>在大多数CPU架构中,标准指令(例如加法和减法指令)都可以实现为原子指令。</p><p>在微架构( micro- architecture)层面,原子指令的执行方式在各个平台上不尽相同。一般情况下,它会暂停CPU流水线的指令分派,直到所有已有的指令都完成执行,并将操作结果刷入到内存中。此外,该CPU还会阻止其他CPU对相关缓存行的访问,直到该原子指令结束执行。在现代x86硬件平台上,如果屏障指令(fence instruction)中断了比较复杂的指令执行,则该原子指令可能需要等上很多个时钟周期才能完成执行。因此,不仅是过多的临界区会影响系统性能锁的具体实现也会影响性能,当频繁对较小的临界区执行加锁、解锁操作时,性能损耗更是巨大。</p><h3 id="同步在字节码中的实现"><a href="#同步在字节码中的实现" class="headerlink" title="同步在字节码中的实现"></a>同步在字节码中的实现</h3><p>Java字节码中有两条用于实现同步的指令,分别是monitorenter和monitorexit,它们都会从执行栈中弹出一个对象作为其操作数。使用javac编译源代码时,若遇到显式使用监视器对象的同步代码,则为之生成相应的monitorenter指令和monitorexit指令。</p><h2 id="对于线程与同步的优化"><a href="#对于线程与同步的优化" class="headerlink" title="对于线程与同步的优化"></a>对于线程与同步的优化</h2><h3 id="锁膨胀与锁收缩"><a href="#锁膨胀与锁收缩" class="headerlink" title="锁膨胀与锁收缩"></a>锁膨胀与锁收缩</h3><blockquote><p>默认情况下, JRockit使用一个小的自旋锁来实现刚膨胀的胖锁,只持续很短的时间。乍看之下,这不太符合常理,但这么做确实是很有益处的。如果锁的竟争确实非常激烈,而导致线程长时间自旋的话,可以使用命令行参数-XX:UseFatSpin=false禁用此方式。作为胖锁的一部分,自旋锁也可以利用自适应运行时获取到的反馈信息,这部分功能默认是禁用的,可以使用命令行参数-XX:UseAdaptiveFatSpin=true来开启。</p></blockquote><h3 id="延迟解锁"><a href="#延迟解锁" class="headerlink" title="延迟解锁"></a>延迟解锁</h3><p>如何分析很多线程局部的解锁,以及重新加锁的操作只会降低程序执行效率?这是否是程序运行的常态?运行时是否可以假设每个单独的解锁操作实际上都是不必要的?</p><p>如果某个锁每次被释放后又立刻都被同一个线程获取,则运行时可以做上述假设。但只要有另外某个线程试图获取这个看起来像是未被加锁的监视器对象(这种情况是符合语义的),这种假设就不再成立了。这时为了使这个监视器对象看起来像是一切正常,原本持有该监视器对象的线程需要强行释放该锁。这种实现方式称为延迟解锁,在某些描述中也称为偏向锁(biased locking)。</p><p>即使某个锁完全没有竞争,执行加锁和解锁操作的开销仍旧比什么都不做要大。而使用原子指令会使该指令周围的Java代码都产生额外的执行开销。</p><p>从以上可以看出,假设大部分锁都只在线程局部起作用而不会出现竞争情况,是有道理的。在这种情况下,使用延迟解锁的优化方式可以提升系统性能。当然,天下没有免费的午餐,如果某个线程试图获取某个已经延迟解锁优化的监视器对象,这时的执行开销会被直接获取普通监视器对象大得多,因为这个看似未加锁的监视器对象必须要先被强行释放掉因此,不能一直假设解锁操作是不必要的,需要对不同的运行时行为做针对性的优化。</p><p>1.实现</p><p>实现延迟解锁的语义其实很简单。</p><p>实现 monitorenter指令。</p><ul><li>如果对象是未锁定的,则加锁成功的线程将继续持有该锁,并标记该对象为延迟加锁的。</li><li>如果对象已经被标记为延迟加锁的：<ul><li>如果对象是被同一个线程加锁的,则什么也不做(大体上是一个递归锁)</li><li>如果对象是被另一个线程加锁的,则暂停该线程对锁的持有状态,检查该对象真实的加锁状态,即是已加锁的还是未加锁的,这一步操作代价高昂,需要遍历调用栈。如果对象是已加锁的,则将该锁转换为瘦锁,否则强制释放该锁,以便可以被新线程获取到。</li></ul></li></ul><p>实现monitorexit指令:如果是延迟加锁的对象,则什么也不做,保留其已加锁状态,即执行延迟解锁。</p><p>为了能解除线程对锁的持有状态,必须要先暂停该线程的执行,这个操作有不小的开销。在释放锁之后,锁的实际状态会通过检查线程栈中的锁符号来确定,这种处理方式与之前介绍的处</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> GC </tag>
            
            <tag> JVM </tag>
            
            <tag> JRockit </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库索引设计与优化 笔记</title>
      <link href="/relational-database-index-design-and-the-optimizers-note.html"/>
      <url>/relational-database-index-design-and-the-optimizers-note.html</url>
      
        <content type="html"><![CDATA[<p>本文整理自：《数据库索引设计与优化》 作者：Tapio Lahdenmaki，Michael Leach</p><p>出版时间：2015-06-01</p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="索引误区"><a href="#索引误区" class="headerlink" title="索引误区"></a>索引误区</h2><h3 id="误区1：索引层级不要超过5层"><a href="#误区1：索引层级不要超过5层" class="headerlink" title="误区1：索引层级不要超过5层"></a>误区1：索引层级不要超过5层</h3><p>由于非叶子页通常都会留在内存或者读缓存中，所以通常索引任意一个叶子页的时间为10ms~20ms，这是固定的。所以，对索引层数的限制是没有什么意义的。</p><h3 id="误区2：单表的索引数不要超过6个"><a href="#误区2：单表的索引数不要超过6个" class="headerlink" title="误区2：单表的索引数不要超过6个"></a>误区2：单表的索引数不要超过6个</h3><p>我建议不要给表的索引数目设置上限。</p><p>保证所有的SQL语句都能够流畅运行是设计的底线。我们总能找到一种方法来达到这一点。如果为了达到这一点需要在表上创建10个索引，那么你就应该在表上建立10个索引。</p><h3 id="误区3：不应该索引不稳定的列"><a href="#误区3：不应该索引不稳定的列" class="headerlink" title="误区3：不应该索引不稳定的列"></a>误区3：不应该索引不稳定的列</h3><p><font color="DeepPink">索引行是按索引键的顺序存储的，所以当索引键中存一列被更新时，DBMS可能不得不把相应的行从旧的索引位置移到新的位置来保持这一顺序。这个新的位迓可能与旧的位晋位于相同的叶子贞上，在这种情况下，只有一个页会受到影响。然而，如果被修改的键是第一列或唯一的列，那么新的索引行可能必须被迁移到一个不同的叶子页上，即DBMS必须更新两个叶子页。三十年前，如果这个索引为一个4层索引，这也许需要6次磁盘随机读取：3次常规读取，即2次非叶子页读取和1次叶子页读取，加上新的位置所涉及的3次随机读取。当一次随机读取耗时30ms 时，迁移一个索引行可能会给该更新操作额外增加6 x 30ms =180ms 的响应时间。因此，不稳定的列很少被索引就不足为奇了。</font></p><p><font color="DeepPink">现在，当四层索引中三个层级的非叶子页保留在内存中时，一次磁盘随机读取需要 l0 ms ，响应的时间变成了 2 x 10ms = 20ms 。此外，许多索引为多列索引，也称作复合或组合索引，它通常包含多列，以使得索引键值唯一。当不稳定的列为复合索引的尾列更新这个不稳定的列绝不会导致其迁移到新的叶子页。因此，在当前的磁盘条件下，更新一个不稳定的列只会对该更新操作增加10ms的响应时间。</font></p><p>在当前磁盘条件下，只有在更新频率多于10次/秒的情况下，不稳定列才可能成为问题。（2015年）</p><blockquote><p>创建索引的目的应该是在硬件容量限制的前提下保证所有的数据库调用运行的足够快。</p></blockquote><h2 id="系统化的索引设计"><a href="#系统化的索引设计" class="headerlink" title="系统化的索引设计"></a>系统化的索引设计</h2><ul><li>找到由于索引不合适而导致运行<strong>太慢</strong>的查询语句<br>  最差输入：导致执行时间最长的变量值</li><li>设计索引，使所有查询语句都运行的足够快<br>  表的维护（插入、更新、删除）也必须足够快</li></ul><h1 id="表和索引结构"><a href="#表和索引结构" class="headerlink" title="表和索引结构"></a>表和索引结构</h1><p>DBMS 会意识到多个索引或表页需要被顺序地读取，且能识別出那些不在缓冲池中的页。随后，它将发出多页I/O请求，每次请求的页的数量由DBMS决定。<font color="DeepPink">只有那些不在缓冲池中的页会被从磁盘服务器上读取，因为那些已经在缓冲池中的页中可能包含了尚未被写人磁盘的更新数据。</font></p><h1 id="SQL处理过程"><a href="#SQL处理过程" class="headerlink" title="SQL处理过程"></a>SQL处理过程</h1><h2 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h2><p>WHERE子句由一个或者多个<font color="DeepPink">谓词（搜索参数）</font>组成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># SQL 3.1</span><br><span class="line">WHERE SEX = &apos;M&apos;</span><br><span class="line">      AND</span><br><span class="line">      (WEIGHT &gt; 90</span><br><span class="line">      OR</span><br><span class="line">      HEIGHT &gt; 190)</span><br></pre></td></tr></table></figure><p>SQL 3.1中有三个简单谓词，它们是：</p><ul><li>SEX = ‘M’</li><li>WEIGHT &gt; 90</li><li>HEIGHT &gt; 190</li></ul><p>同样，它们也可以被认为是两个组合谓词：</p><ul><li>WEIGHT &gt; 90 OR HEIGHT &gt; 190</li><li>SEX = ‘M’ AND  ( WEIGHT &gt; 90 OR HEIGHT &gt; 190 )</li></ul><p>谓词表达式是索引设计的主要入手点。如果一个索引能够满足SELECT查询语句的所有谓词表达式，那么优化器就很有可能建立起一个高效的访问路径。</p><p>核实确认访问路径（执行计划）<br><img alt data-src="/images/database-index-design-optimizers/%E4%BC%98%E5%8C%96%E5%99%A8%E4%BD%95%E6%97%B6%E9%80%89%E6%8B%A9%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84.png"></p><h1 id="为SELETE语句创建理想的索引【重点】"><a href="#为SELETE语句创建理想的索引【重点】" class="headerlink" title="为SELETE语句创建理想的索引【重点】"></a>为SELETE语句创建理想的索引【重点】</h1><blockquote><p>很多调优人员（尽管没经验）认为，如果一个SQL语句使用了索引，那这个 SQL就是被很好地优化过的，我对此感到很惊讶。你应该总是问自己，”这是不是可用的最好的索引？” 或 “再添加另外一个索引能否提升<br>响应性能？”，又或者 “全表扫描会不会更快地返回结果？”</p></blockquote><h2 id="三星索引"><a href="#三星索引" class="headerlink" title="三星索引"></a>三星索引</h2><blockquote><p>三星索引：查询语句的理想索引。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DECLARE CURSOR41 CURSOR FOR</span><br><span class="line">SELECT    CNO, FNAME</span><br><span class="line">FROM      CUST</span><br><span class="line">WHERE     LNAME = :LNAME</span><br><span class="line">          AND</span><br><span class="line">          CITY  = :CITY</span><br><span class="line">ORDER BY  FNAME</span><br></pre></td></tr></table></figure><p><img alt data-src="/images/database-index-design-optimizers/%E5%9B%BE4.2.png"></p><h2 id="星级是如何给定的"><a href="#星级是如何给定的" class="headerlink" title="星级是如何给定的"></a>星级是如何给定的</h2><p>如果与一个查询相关的索引行是相邻的，或者至少相距足够靠近的话，那这个索引就可以被标记上第一颗星。这<font color="DeepPink">最小化</font>了必须扫描的索引片的宽度。 </p><p>如果索引行的顺序与查询语句的需求一致，则索引可以被标记上第二颗星。这<font color="DeepPink">排除了排序操作</font>。 </p><p>如果索引行包含的查询语句中的所有列，那么索引就可以被标记上第三颗星。这避免了访问表的操作：<font color="DeepPink">仅访问索引就可以了</font>。 </p><p><font color="DeepPink">对于这三颗星，第三颗通常是最重要的。将一个列排除在索引之外可能会导致许多速度较慢的磁盘随机读。</font>我们把一个至少包含第三颗星的索引称为对应查询语句的宽索引。</p><blockquote><p>宽索引：宽索引是指一个至少满足第三颗星的索引。该索引包含了SELECT语句所涉及的所有列，因而能够使得查询只需访问索引而无需访问表。</p></blockquote><p><strong>为了满足第一颗星</strong><br>首先取出所有等值谓词的列（WHERE COL=…）。把这些列作为索引最开头的列——以任意顺序都可以。对于CURSOR41来说，三星索引可以以LNAME、CITY或者以CITY、LNAME开头。在这两种情况下，必须扫描的索引片宽度将被缩减至最窄。</p><p><strong>为了满足第二颗星</strong><br>将ORDER BY列加入到索引中。不要改变这些列的顺序，但是忽略那些在第一步中已经加入索引的列。例如，如果CURSOR41在ORDER BY 中有重复的列，如ORDER BY LNAME、FNAME或者是ORDER BY FNAME、CITY，只有FNAME需要在这步中被加入到索引中去。当FNAME是索引的第三列时，结果集中的记录无须排序就已经是以正确的顺序排列的了。第一次读取操作将返回FNAME值最小的那一行。</p><p><strong>为了满足第三颗星</strong><br>将查询语句中剩余的列加到索引中去，列在索引中添加的顺序对查询语句的性能没有影响，但是将易变的列放在最后能降低更新的成本。现在，索引已包含了满足无须回表的访问路径所需的所有列。</p><p>最终三星索引将会是：(LNAME, CITY, FNAME, CNO) 或 (CITY, LNAME, FNAME, CNO)</p><p>CURSOR41在以下方面是最为挑剔的：</p><ul><li>WHERE 条件不包含范围谓词（BETWEEN、&gt;、&gt;=等）</li><li>FROM 语句只涉及单表</li><li>所有谓词对于优化器来说都足够简单</li></ul><h2 id="范围谓词与三星索引"><a href="#范围谓词与三星索引" class="headerlink" title="范围谓词与三星索引"></a>范围谓词与三星索引</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DECLARE CURSOR43 CURSOR FOR</span><br><span class="line">SELECT    CNO, FNAME</span><br><span class="line">FROM      CUST</span><br><span class="line">WHERE     LNAME BETWEEN :LNAME1 AND :LNAME2</span><br><span class="line">          AND</span><br><span class="line">          CITY  = :CITY</span><br><span class="line">          ORDER BY  FNAME</span><br></pre></td></tr></table></figure><p>让我们尝试为这个 CURSOR 设计一个三星索引。大部分的推论与 CURSOR41 相同，但是“BETWEEN 谓词”将“=谓词”替代后将会有很大的影响。我们将会以相反的顺序依次考虑三颗星，按理说，这代表了理解的难度。</p><p>首先是最简单的星（虽然非常重要），第三颗星。按照先前所述，<strong>确保查询语句中的所有列都在索引中就能满足第三颗星。这样不需要访问表，那么同步读也就不会造成问题。</strong></p><p>添加 ORDER BY 列能使索引满足第二颗星，但是这个仅在将其放在 BETWEEN 谓词列 LNAME 之前的情况下才成立，如索引 (CITY, FNAME, LNAME)。由于 CITY 的值只有一个（=谓词），所以使用这个索引可以使结果集以 FNAME 的顺序排列，而不需要额外的排序。但是如果 ORDER BY 字段加在 BETWEEN 谓词列 LNAME 后面，如索引 (CITY, LNAME, FNAME)，那么索引行不是按 FNAME 顺序排列的，因而就需要进行排序操作。因此，为了满足第二颗星，FNAME 必须在 BETWEEN 谓词列 LNAME 前面，如索引 (FNAME, …) 或索引 (CITY, FNAME, …)。</p><p>再考虑第一颗星，如果 CITY 是索引的第一个列，那我们将会有一个相对较窄的索引片需要扫描（MC=1），这取决于 CITY 的过滤因子。但是如果用索引 (CITY, LNAME, …) 的话，索引片会更窄，这样在有两个匹配列的情况下我们只需要访问真正需要的索引行。但是，为了做到这样，并从一个很窄的索引片中获益，其他列（如 FNAME）就不能放在这两列之间。</p><blockquote><p>MC:match column（匹配列）</p></blockquote><p>所以我们的理想索引会有几颗星呢？首先它一定能有第三颗星，但是，正如我们刚才所说，我们只能有第一颗星或者第二颗星，而不能同时拥有两者！换句话说，我们只能二选一：</p><ul><li>避免排序 — 拥有第二颗星</li><li>拥有可能的最窄索引片，不仅将需要处理的索引行数降至最低，而且将后续处理量，特别是表中数据行的同步读，减少到最少 — 拥有第一颗星</li></ul><p>在这个例子中，BETWEEN 谓词或者任何其他范围谓词的出现，意味着我们不能同时拥有第一颗星和第二颗星。也就是说我们不能拥有一个三星索引。这就意味着我们需要在第一颗星和第二颗星中做出选择。通常这不是一个困难的选择，<strong>因为第一颗星一般比第二颗星更重要，虽然并不总是这样</strong>。</p><h2 id="为查询语句设计最佳索引的算法"><a href="#为查询语句设计最佳索引的算法" class="headerlink" title="为查询语句设计最佳索引的算法"></a>为查询语句设计最佳索引的算法</h2><p><font color="DeepPink">根据以上的讨论，理想的索引是一个三星索引。然而，正如我们所见，当存在范围谓词时，这是不可能实现的。我们（也许）不得不牺牲第二颗星来满足一个更窄的索引片（第一颗星），这样，最佳索引就只拥有两颗星。这也就是为什么我们需要仔细区分理想和最佳。</font>在这个例子中理想索引是不可能实现的。将这层因素考虑在内，我们可以对所有情况下创建最佳索引（也许不是理想索引）的过程公式化。创建出的索引将拥有三颗星或者两颗星。</p><p><strong>首先设计一个索引片尽可能窄（第一颗星）的宽索引（第三颗星）。如果查询使用这个索引时不需要排序（第二颗星），那这个索引就是三星索引。否则这个索引只能是二星索引，牺牲第二颗星。或者采用另一种选择，避免排序，牺牲第一颗星保留第二颗星。这种二星索引中的一个将会是相应查询语句的最佳索引。</strong></p><h3 id="为查询语句创建最佳索引的算法"><a href="#为查询语句创建最佳索引的算法" class="headerlink" title="为查询语句创建最佳索引的算法"></a>为查询语句创建最佳索引的算法</h3><h4 id="候选-A"><a href="#候选-A" class="headerlink" title="候选 A"></a>候选 A</h4><ol><li>取出对于优化器来说不过分复杂的等值谓词列。将这些列作为索引的前导列(以任意顺序皆可)。</li><li>将选择性最好的范围谓词作为索引的下一个列，如果存在的话。最好的选择性是指对于最差的输入值有最低的过滤因子。只考虑对于优化器来说不过分复杂的范围谓词。</li><li>以正确的顺序添加ORDER BY语列，忽略在第一步或者第二步已添加的列。</li><li>以任意顺序将 SELECT 语句中其余的列添加至索引中（但是需要以不易变的列开始）。</li></ol><p>举例：CURSOR43</p><p>候选 A 为 (CITY, LNAME, FNAME, NCNO)。</p><p>由于 FNAME 在范围谓词列 LNAME 的后面，候选 A 引起了 CURSOR43 的一次排序操作。</p><h4 id="候选-B"><a href="#候选-B" class="headerlink" title="候选 B"></a>候选 B</h4><p>如果候选 A 引起了所给查询语句的一次排序操作，那么还可以设计候选 B。根据定义，对于候选 B 来说第二颗星比第一颗星更重要。</p><ol><li>取出对于优化器来说不过分复杂的等值谓词列。将这些列作为索引的前导列(以任意顺序皆可)。</li><li>以正确顺序添加 ORDER BY 列（如果 ORDER BY 列有 DESC 的话，加上 DESC）。忽略在第1步中已经添加的列。</li><li>以任意顺序将 SELECT 语句中其余的列添加至索引中（但是需要以不易变的列开始）。</li></ol><p>举例：CURSOR43</p><p>候选 B 为 (CITY, FNAME, LNAME, CNO)。</p><blockquote><p>需要注意的是，到目前为止，我们所做的只是设计理想索引或是最佳索引。但是这是否是实际可行的，我们在这个阶段还不好说。</p></blockquote><h1 id="前瞻性的索引设计"><a href="#前瞻性的索引设计" class="headerlink" title="前瞻性的索引设计"></a>前瞻性的索引设计</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>根据定义，DBMS读取一个索引行或一个表行的成本称为一次访问 : 索引访问或表访问。如果DBMS扫描索引或表的一个片段(被读取的行在物理上是彼此相邻的)，那么第一行的读取即为一次随机访问。对于后续行的读取，每行都是一次顺序访问。在当前的硬件条件下，顺序访问的成本比随机访问的成本低得多。一次索引访问的成本与一次表访问的成本基本上是相同的。</p><h3 id="读取一组连续的索引行"><a href="#读取一组连续的索引行" class="headerlink" title="读取一组连续的索引行"></a>读取一组连续的索引行</h3><p>物理上彼此相邻是什么意思?</p><p>索引上的所有行都通过指针链接在一起，链接的先后顺序由索引的键值严格定义。当几个索引行的键值相同时，就根据索引行存储的指针值进行链接。在传统的索引设计(从某个角度看，是理想化的)中，链表从LP1(叶子页1)开始，随后链接LP2，以此类推。这样(假设每个磁道可以放12个叶子页，当前的硬件通常可以容纳更多)，叶子页就组成了一个连续的文件，LP1至LP12存储在磁盘柱面的第一个磁道，LP13至LP24存储在下一个磁道，如此继续，当第一个柱面存满后，下一组LP就会被存储在下一个柱面的首个磁道上。换句话说，就是叶子页之间没有其他页。</p><p>现在，读取一个连续的索引行(即一个索引片，或者包含了单个键值或者一个范围的键值所对应的索引行)就非常快了。一次磁盘旋转会将多个叶子页读取进内存中，而且只有在磁盘指针移到下一个柱面时才需要进行一次短暂的寻址、</p><p>不过，这个完美的顺序还是会被打破的，至少有以下三个影响因素 :</p><ol><li>如果一个叶子页没有足够的空间存储新插入的索引行，那么叶子页就必须被分裂。之后链表仍会按照正确的顺序链接索引行，但是这与底层的物理存储顺序就不再一致了，一些按道理应该是顺序的访问就变成随机访问了。不过索引的充足可以再次恢复最理想的顺序。</li><li>意向不到的数据增长可能会填满原本连续的空间(区或类似的概念)。操作系统于是就会寻找另外有一个连续的空间，并将它连接到原来空间的后面。这时候从第一个区跨到第二个区访问就会产生一次随机访问，不过这种情况影响不大。</li><li>RAID 5条带会将前几个叶子页存储在一个驱动器上，将后面的叶子页存放在另外的驱动器上。这就会产生额外的随机读，但实际上条带的积极作用要大过随机读带来的性能恶化，一个智能的磁盘服务器可以将后续的叶子页并行的从多个驱动器上读取至磁盘缓存中，从而大大降低了单个叶子页的I/O时间。此外，在RAID 5条带策略下，一个被频繁访问的索引的不太可能导致某一个磁盘负载过高，因为I/O请求会被均匀低分布到RAID 5阵列内的多个磁盘驱动器。</li></ol><p>忽略上述情况，我们仍然假设，如果两个索引行在链表上彼此相邻(或者在唯一索引中，相同键值的行指针意味着彼此相邻)，那么我们就认为这两行在物理上也相邻。这就意味着QUBE认为所有的索引都有最理想的顺序。</p><h3 id="读取一组连续的表行"><a href="#读取一组连续的表行" class="headerlink" title="读取一组连续的表行"></a>读取一组连续的表行</h3><p>读取一组连续的表行有如下两种情况：</p><ol><li>全表扫描<br>从TP1(表页1)开始，读取该页上所有的记录，然后再访问TP2，一次类推。按照记录在表页中存储的顺序进行读取，没有其他特殊的顺序。</li><li>聚簇索引扫描<br>读取索引片上第一个索引行，然后获取相应的表行，再访问第二个索引行，以此类推。如果索引行与对应的表行记录顺序完全一致(聚簇率为100%)，那么除了第一次之外的所有表访问就都是顺序访问。表记录的链接方式跟索引不一样。单个表页中记录的顺序无关紧要，只要访问的下一个表记录在同一个表页或者相邻的下一个表页内就可以了。</li></ol><p>同索引一样，存储表的传统方式也是将所有表页保留在一个连续的空间内。引起顺序杂乱或碎片化的因素也和索引中的相似，但又两个地方不同：</p><ol><li>如果往表中插入的记录在聚簇索引所定义的主页中装不下，则通常不会移动现有的行，而是会将新插入的记录存储到离主页尽可能近的表页中。对第二个页的随机I/O会使聚簇索引扫描变得更慢，但是如果这条记录离主页很近，这些额外的开销就可以被避免，因为顺预读功能会一次性将多个表页装载到数据库缓存中。即使顺序预读功能没有使用，也只有当该页在数据库缓存被覆盖的情况下才会发生额外的随机I/O。</li><li>一条记录被更新后，可能因为表行过长导致其无法再存储于当前的表页中。这是DBMA就必须将该行记录迁移至另外一个表页中，同时在原有的表页中存储指向新表页的指针。当该行被访问时，会引入额外的随机访问。<br>表可以通过重组来还原行记录的顺序，从而减少不必要的随机访问。</li></ol><h2 id="计算访问次数"><a href="#计算访问次数" class="headerlink" title="计算访问次数"></a>计算访问次数</h2><h3 id="随机访问"><a href="#随机访问" class="headerlink" title="随机访问"></a>随机访问</h3><p>我们首先思考一下磁盘读与访问的区别。<strong>一次磁盘读所访问的对象是一个页，而一次访问的访问对象则是一行。</strong>一次随机磁盘读会将一整页(通常会包含很多行)读取至数据库的缓冲池中，但是根据定义，前后两次随机读不太可能会访问到同一个页。</p><h2 id="使用满足需求的成本最低的索引还是所能达到的最有索引"><a href="#使用满足需求的成本最低的索引还是所能达到的最有索引" class="headerlink" title="使用满足需求的成本最低的索引还是所能达到的最有索引"></a>使用满足需求的成本最低的索引还是所能达到的最有索引</h2><p><font color="DeepPink">当有多个等值谓词作为匹配列时，我们需要考虑这些列在索引上的先后顺序。经常变化的列应当尽可能的排在后面。</font></p><blockquote><p>更改现有索引列的顺序和在现有索引列之间添加新列同样危险。在这两种情况下，现有的select的执行速度都可能会急剧下降，因为匹配列减少了，或者引入了排序(导致过早产生结果集)</p></blockquote><h2 id="半宽索引-最大化索引过滤"><a href="#半宽索引-最大化索引过滤" class="headerlink" title="半宽索引(最大化索引过滤)"></a>半宽索引(最大化索引过滤)</h2><p>在现有索引的末端添加缺少的谓词列可以消除大量的随机访问，因为这样能引入索引过滤过程。</p><h1 id="影响索引设计过程的因素"><a href="#影响索引设计过程的因素" class="headerlink" title="影响索引设计过程的因素"></a>影响索引设计过程的因素</h1><p>I/O时间估算:</p><ul><li>随机读取 10ms(页的大小为4KB或8KB)</li><li>顺序读取 40MB/s</li></ul><p>这些数据是假定系统使用当前硬件并在一个合理的负载下运行时的值。一些系统可能运行的更慢或处理超负荷状态。</p><h2 id="困难谓词"><a href="#困难谓词" class="headerlink" title="困难谓词"></a>困难谓词</h2><p>大体上，假设一个谓词的判定结果为false，而这时如果不检查其他谓词就不能确定地将一行记录排除在外，那么这类谓词对优化器而言就是太过困难的。</p><h2 id="过滤因子隐患"><a href="#过滤因子隐患" class="headerlink" title="过滤因子隐患"></a>过滤因子隐患</h2><p>当以下三个条件同时满足时，这种过滤因子隐患可能会产生 :</p><ul><li>访问路径中没有排序</li><li>第一屏结果一建立就回应</li><li>不是所有的谓词字段都参与定义带扫描的索引片–换句话说就是，不是所有的字段都是匹配字段。</li></ul><h1 id="被动式索引设计"><a href="#被动式索引设计" class="headerlink" title="被动式索引设计"></a>被动式索引设计</h1><blockquote><p>被动式的方法与莱特兄弟创造守架飞机的经历非常相似。本质上就是把查询放在一起，推下悬崖，然后看他能否起飞。换句话说，就是为应用设计一个没有索引的原型，然后开始运行一些查询。又或者，创建原始索引集，然后通过运行应用来看那些索引被用到，那些没有被用到。即使是一个小型的数据库系统，运行速度慢的查询也会被很快凸显出来。</p><p>被动式调优的方法也被用来理解和调优一个性能没有满足预期的已有应用。</p></blockquote><h2 id="对结果集排序"><a href="#对结果集排序" class="headerlink" title="对结果集排序"></a>对结果集排序</h2><p>除了全表扫描和全索引扫描，结果集的排序就是最有用的警示信号了。引起排序的原因可能有以下两种:</p><ul><li>没有可使查询语句避免排序的索引。</li><li>优化器所选择的访问路径包含了一次多余的排序。</li></ul><blockquote><p>有很多数据库顾问将排序视为敌人。我们认为，哪些强调随机I/O带来致命影响的顾问更值得信任。</p></blockquote><h2 id="成本估算"><a href="#成本估算" class="headerlink" title="成本估算"></a>成本估算</h2><p>一些数据库管理系统的EXPLAIN功能显示了优化器对所选访问路径的本地响应时间的估算，或至少显示了对CPU时间的估算。</p><p>不幸的是，以下两个严重问题限制了使用成本估算方法的价值:</p><ul><li>优化器所做出的的本地响应时间估算可能与实际相差很大</li><li>当谓词使用绑定变量时(显然这是很普遍的)，优化器对过滤因子的估算是基于平均输入值的，或更差情况下，基于默认值。为了获取更有价值的最差情况估值，EXPLAIN中的绑定变量必须用最差情况下的输入值来代替。这是一个需要应用知识的累人操作。</li></ul><h1 id="为表连接设计索引"><a href="#为表连接设计索引" class="headerlink" title="为表连接设计索引"></a>为表连接设计索引</h1><h2 id="预测表的访问顺序"><a href="#预测表的访问顺序" class="headerlink" title="预测表的访问顺序"></a>预测表的访问顺序</h2><p>在大部分情况下，可以使用以下经验法则来预测最佳的表访问顺序 : 将包含<strong>最低数量本地行</strong>的表作为外层表。</p><blockquote><p>本地行的数量是指最大过滤因子过滤本地谓词之后所剩余的行数。</p></blockquote><p>经验法则忽略了以下因素:</p><ol><li>排序。</li><li>很小的表。<font color="DeepPink">非常小的表及其索引可能长期存在于数据库的缓冲池中</font>，至少在一个连接查询中，没有页会被读取多次。在这样的表和索引上进行随机读取所耗费的时间小于0.1ms，至少在页被第一次读取之后是这样的。所以，当这样的表不是外层表时，对其大量的随机读取也不会称为问题。</li><li>聚簇比例。索引中行的顺序和表中行的顺序的关联性(对于聚簇索引而言，该关联性在表重组后为100%)，可能会影响对最佳访问顺序的选择，当然，除非索引是宽索引。</li></ol><p>最好的基于成本的优化器在进行路径选择时会把这些因素考虑进来。因此，他找出的访问顺序可能比我们基于本地行的数量的经验所得出的结果更优。</p><h2 id="合并扫描连接和哈希连接"><a href="#合并扫描连接和哈希连接" class="headerlink" title="合并扫描连接和哈希连接"></a>合并扫描连接和哈希连接</h2><h3 id="合并扫描连接"><a href="#合并扫描连接" class="headerlink" title="合并扫描连接"></a>合并扫描连接</h3><p>执行过程如下</p><ul><li>执行表或索引扫描以找出满足本地谓词的所有行。</li><li>随后可能会进行排序，如果这些扫描未按所要求的顺序提供结果集。</li><li>对前两者生成的临时表进行合并。</li></ul><p>在以下情况下，合并扫描会比嵌套循环快。</p><ol><li>用于连接的字段上没有可用的索引。在这种情况下，若使用嵌套循环，那么内层表可能需要被扫描很多次。在实际情况中，用于连接的列上面没有索引的情况很少见，因为大部分连接谓词都是基于“主键等于外键”这一条件的。</li><li>结果表很大。在这种情况下，若使用嵌套循环连接，可能会导致相同的页被不断的重复访问。</li><li>连接查询中不止一张表的过滤因子很低。如我们所见，嵌套循环可能导致对内层表(或者内层表索引)的大量随机访问。</li></ol><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DECLARE CURSOR81 CURSOR FOR</span><br><span class="line">SELECT CNAME, CTYPE, INO, IEUR</span><br><span class="line">FROM CUST, INVOICE</span><br><span class="line">WHERE CUST.CTYPE = :CTYPE</span><br><span class="line">      AND</span><br><span class="line">      IDATE &gt; :IDATE</span><br><span class="line">      AND</span><br><span class="line">      CUST.CNO = INVOICE.CNO</span><br></pre></td></tr></table></figure><h3 id="哈希连接"><a href="#哈希连接" class="headerlink" title="哈希连接"></a>哈希连接</h3><p>哈希连接本质上是用哈希算法代替排序算法的合并扫描连接。首先，对较小的结果集用哈希算法计算其连接字段，并将其保存在一个临时表中；然后，再扫描其他的表(或索引片)，并通过(计算得到的)哈希值将满足本地谓词条件的每一行记录与临时表中相应的行进行匹配。</p><p>若结果行集已在索引中满足了所要求的顺序，那么合并扫描的速度将更快。若合并扫描需要进行排序，那么哈希连接的速度可能更快，尤其是当其中一个行集能够全部留在内存中时(对一个哈希表进行一次随机访问所花费的CPU时间，通常会比排序和合并一行所花费的时间少)。如果两个行集很大，那么哈希表会根据可用内存的大小对哈希表进行分区(同一时间内存中只有一个分区)，而另外一个行集会被扫描多次。</p><h2 id="为什么连接的性能表现较差"><a href="#为什么连接的性能表现较差" class="headerlink" title="为什么连接的性能表现较差"></a>为什么连接的性能表现较差</h2><h3 id="模糊的索引设计"><a href="#模糊的索引设计" class="headerlink" title="模糊的索引设计"></a>模糊的索引设计</h3><p>“在连接字段上建索引”是最古老的索引建议之一。事实上，这是基于建议的一个扩展 : “<strong>为主键创建一个索引，并且为每一个外键创建一个由此外键作为前导列的索引</strong>”。在连接谓词上建索引使得嵌套循环称为一个可行的方案，但包含连接谓词列并不一定能够提供完全可接受的响应时间。连接谓词列上的索引和本地谓词上的索引通常都需要是宽索引。而且，不同的表访问顺序可能导致完全不同的索引需求。</p><h2 id="为子查询设计索引"><a href="#为子查询设计索引" class="headerlink" title="为子查询设计索引"></a>为子查询设计索引</h2><p>从性能的角度看，子查询与连接十分相似。<strong>实际上，现今的优化器通常会在进行访问路径的选择之前，先将子查询重写为一个连接。</strong>若优化器没有进行重写，那么子查询的类型本身可能就决定了表访问顺序。内外层无关联的子查询通常会从最内层的SELECT开始执行。结果集被保存在一张临时表中，等待下一个SELECT的访问。内外层有关联的子查询通常会从最内层的SELECT开始执行。无论是何种情况，同连接一样，应当基于能够形成最快访问路径的表访问顺序进行索引设计。若最佳的表访问顺序未被选中，那么程序开发人员可能需要对语句进行重写，在某些情况下还可能要使用连接。</p><h2 id="为UNION语句设计索引"><a href="#为UNION语句设计索引" class="headerlink" title="为UNION语句设计索引"></a>为UNION语句设计索引</h2><p>通过UNION或UNION ALL连接的SELECT语句是逐个分别进行优化和指向的。因此，应该为每个独立的SELECT设计合适的索引。需要注意一点，带ORDER BY的UNION可能会导致提前物化。</p><h2 id="对于表设计的思考"><a href="#对于表设计的思考" class="headerlink" title="对于表设计的思考"></a>对于表设计的思考</h2><h3 id="冗余数据"><a href="#冗余数据" class="headerlink" title="冗余数据"></a>冗余数据</h3><p>有两种通过冗余数据优化连接速度的方法：</p><ol><li>将某列拷贝至依赖表(向下反范式法)。</li><li>将汇总数据添加至父表(向上反范式法)。</li></ol><h3 id="向下反范式化"><a href="#向下反范式化" class="headerlink" title="向下反范式化"></a>向下反范式化</h3><p>不过，总体而言，当我们考虑引入向下反范式化时，需要预测一下冗余字段更新时可能会导致最差情况下的索引随机访问次数。</p><h3 id="反范式化的成本"><a href="#反范式化的成本" class="headerlink" title="反范式化的成本"></a>反范式化的成本</h3><p>考虑性能时最令人关注的通常是，为了更新表及索引上的冗余字段锁带来的I/O时间。在向下反范式化中，这可能需要移动大量的索引行，从而导致一个简单的UPDATE运行的很慢。向上反范式化不太可能因为一次简单的更新操作而引发I/O剧增。不过INSERT，UPDATE和DELETE可能导致父表及其索引上的一些额外I/O。在极端情况下，如每秒10次以上的INSERT或UPDATE，由这些I/O带来的磁盘负载可能会成为问题。</p><h2 id="嵌套循环连接和合并扫描连接-哈希连接-VS-反范式化"><a href="#嵌套循环连接和合并扫描连接-哈希连接-VS-反范式化" class="headerlink" title="嵌套循环连接和合并扫描连接/哈希连接 VS 反范式化"></a>嵌套循环连接和合并扫描连接/哈希连接 VS 反范式化</h2><p>许多数据库专家不愿意将冗余列添加至事务型表上，这是可以理解的。反范式化不仅仅是查询速度和更新速度之间的一个权衡，在某种程度上，他还是性能和数据完整性之间的一个权衡，即使在使用触发器来维护冗余数据的情况下。然而，当嵌套循环引入了过多的随机访问，且MS/HJ耗费了过多的CPU时间时，反范式化可能成为唯一的选择。尽管如此，在决定采用这一极端的方案之前，我们必须确保所有能够避免这一方案的方法都已经考虑过了。</p><h2 id="无意识的表设计"><a href="#无意识的表设计" class="headerlink" title="无意识的表设计"></a>无意识的表设计</h2><p>从性能的角度看，我们非常难以理解为何有那么多的数据库中存在具有1 : 1或1: C(C = 有条件的;即0或1)关系的表。</p><p>为何要建四张表而非只建一张CUST表？只要关系永远不会变成1 : M，那么灵活性就不会成为问题。在本例中，客户要么是公司，要么是个人，且不会有客户死亡两次!</p><p>将这四张表合成一张部分字段为空的表(对于每一行，要么公司相关的字段为空，要么个人相关的字段为空；同样，所有活着的客户的死亡相关的字段为空)，这是存储空间和性能(随机访问的次数)之间的权衡。为空的数据并不违反范式。</p><p>在不考虑硬件性能的情况下设计表可能会有如下问题 :</p><ul><li>即便是在最佳索引条件下，随机访问的次数仍可能会很高。</li><li>复杂连接可能使得索引设计变得非常困难。</li><li>优化器可能对复杂连接做出错误的访问路径选择。</li></ul><h1 id="星型连接"><a href="#星型连接" class="headerlink" title="星型连接"></a>星型连接</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>星型连接与普通连接的差别主要有两个方面：</p><ol><li>如下图所示，位于星型结构中心位置的表称为<strong>事实表</strong>，它的数据量远大于它周围的表—<strong>维度表</strong>。</li><li>最佳的访问路径通常是包含维度表的<strong>笛卡尔积</strong>，这意味着他们<strong>没有相同的冗余列</strong>，满足本地谓词的维度表数据行都会参与连接。</li></ol><p><img alt data-src="/images/database-index-design-optimizers/%E6%98%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.png"></p><p>SALES 销售记录<br>STORE 出售的店铺<br>ITEM  出售的商品<br>DATE  出售的时间<br>CUST  出售的客户</p><p>在星型连接中，事实表的数据量通过都比较大。在这种情况下，至少依据经验法则，事实表应该作为嵌套循环连接方式中最内层的表。一般情况下未读表都没有共同的列，所以这种链接顺序意味着是笛卡尔连接。</p><h2 id="事实表的索引"><a href="#事实表的索引" class="headerlink" title="事实表的索引"></a>事实表的索引</h2><p>事实上，宽索引通常比事实表还大，原因有两个 :</p><ol><li>表通常都进行了压缩处理，而索引没有。</li><li>新增一条记录通常都追加到表的尾部，因此事实表并不需要分散的空闲空间。但插入到索引(除了聚簇索引)上的位置是随机的。为了避免频繁的索引重组，在当前硬件条件下，通常10亿行的表将花费几个小时，大多数的索引在叶子节点上都需要留出足够的空闲空间，可能为30% ~ 40%。</li></ol><h2 id="汇总表"><a href="#汇总表" class="headerlink" title="汇总表"></a>汇总表</h2><p>即使是在理想索引的情况下，一些针对10亿条记录的事实表进行的查询也会导致大量的I/O访问。提高这类查询的性能的唯一方式就是使用汇总表(查询表)。这类表是反范式化的事实表。如果表不是特别大(比如只包含几百万行数据)，那么这是一个比较可行的方案，因为反模式化查询只需针对汇总表，而不需要多表关联。</p><p>如果频繁查询每周的销售情况，那么可以针对每周的消费记录建立一张汇总表。比较好的汇总表设计是根据周，商品，商店汇总一条记录。汇总表根据周和商品进行汇总后，数据量可以大幅度减少。在这种情况下，查询的响应时间可能降低到不到1秒钟。</p><p>汇总表上的索引通常会比较小，他唯一的显示因素就是刷新此表所需的时间。如同所有新鲜事物一样，汇总表的方案也会带来新的问题。</p><ol><li>如果用户的查询需求多样，汇总表的设计会比索引的设计更困难，不过，已经有一些工具基于查询日志来协助汇总表的设计。</li><li>如果优化器不能选择正确的汇总表，那么汇总表的意义就不大；我们不能指望用户来指定查询使用某个合适的汇总表。最好的优化器已经在试着访问合适的表了，虽然SELECT语句实际上查询的是事实表。如果优化器不具备这个能力，或者它的正确率不够高，那么可能就不得不强制指定每个用户只能访问一个汇总表。用户不得不自己选择要使用的汇总表。优化器能自动识别的汇总表通常被称为自动汇总表或物化视图。</li></ol><h1 id="多索引访问"><a href="#多索引访问" class="headerlink" title="多索引访问"></a>多索引访问</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>许多数据库管理系统支持从一张表的多个索引处收集制作，或是从单个索引的几个索引片收集，然后比较这些指针集并访问满足WHERE语句中所有谓词条件的数据行。这一能力被称为多索引访问，或被称为索引与(索引交集)和索引或(索引并集)。</p><blockquote><p>多索引访问的思想是：对表中数据分别使用各个索引，最后将满足条件的进行交集或并集操作。</p></blockquote><h1 id="索引和索引重组"><a href="#索引和索引重组" class="headerlink" title="索引和索引重组"></a>索引和索引重组</h1><h2 id="DBMS如何查找索引行"><a href="#DBMS如何查找索引行" class="headerlink" title="DBMS如何查找索引行"></a>DBMS如何查找索引行</h2><p><font color="DeepPink">在当前的硬件条件下，非叶子页很可能已经被缓存在数据库缓冲池中，或者至少在磁盘的读缓存中，因为它们经常被频繁的访问。</font></p><h2 id="插入一行会发生什么？"><a href="#插入一行会发生什么？" class="headerlink" title="插入一行会发生什么？"></a>插入一行会发生什么？</h2><p>如果一张表有一个聚簇索引，那么DBMS会根据聚簇索引的键值尝试将插入的记录放在它所属的表页(主页)中。如果这行记录在主页里放不下，或者当前页被锁住，那么DBMS将会检查邻近的页。在最坏的情况下，新的行会被插入到标的最坏一页。<font color="DeepPink">依赖于DBMS和表的类型，已经插入的行通常都不会被移动，否则这将意味着更新表上已经建立的所有索引上的相关指针。</font>当有许多表行未能存在在主页中时，如果表行的顺序很重要，则需要对这个表进行重组—对于那些涉及多张大表的大规模批处理任务而言，通常需要这么做。</p><p>当往表中插入一条记录时，DBMS会尝试将索引行添加至其索引建所属的叶子页上，但是该索引页可能没有足够的空闲空间来存放这个索引行，在这种情况下，DBMS将会分裂该叶子页。其中一半的行将被移动到一个新的叶子页上，并尽可能地靠近被分裂的页，但是在最坏的情况下，这个索引页可能会被放置在索引的末尾。除了在每个叶子页上预留部分比例的空闲空间外，也许可以在索引被创建或重组时，每n个页面预留一个空页—当索引分裂无法避免时，这会是一个不错的办法。</p><p><font color="DeepPink">当一个索引有一个不断增长的键值时，新行将被添加到索引页的最后，索引页可能永远也不会进行分裂,这样的索引可能不需要任何空闲空间。</font></p><h2 id="叶子页的分裂严重吗？"><a href="#叶子页的分裂严重吗？" class="headerlink" title="叶子页的分裂严重吗？"></a>叶子页的分裂严重吗？</h2><p>分裂一个索引页只需一次额外的同步读，约10ms。除了两个叶子页以外，DBMS通常还必须更新一个非叶子页，而它很可能已经在内存或者读缓存中了。</p><p>在叶子页分裂后，查询任何一条索引行的速度很可能同之前一样快。在最坏情况下，一次分裂会创建一个新的索引层级，但是如果不是从磁盘读取非叶子页的话，这只会增加很少的CPU时间。</p><p>然而，叶子页的分裂会导致一个索引片变得更慢。目前为止，我们在所有的场景中都假设串联索引行的链指针总是指向同一页或者下一页，这些页可能已被DBMS预读取。在索引被创建或者重组后，这种假设是接近真实情况的，但是索引片上的每处叶子页分裂都可能会增加额外的两次随机访问—一次是为了查找索引行被移动至的索引页，一次是为了返回到扫描的原始位置。其中第一次随机访问很可能会导致一次磁盘的随机读取(10ms)。</p><h2 id="什么时候应该对索引进行重组？"><a href="#什么时候应该对索引进行重组？" class="headerlink" title="什么时候应该对索引进行重组？"></a>什么时候应该对索引进行重组？</h2><h3 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h3><p>索引重组是为了恢复索引行正确的物理位置，他对于索引片扫描和全索引扫描的性能而言很重要。因为插入模式的不同，增加的索引行可能会以无序的方式来创建。我们需要记住，更新一个列意味着需要删除旧的索引行，并增加一个新的索引行，新索引行的位置由新的索引键值来确定。</p><p>下文对三种基本插入模式的讨论基于如下假设</p><ol><li>索引是唯一索引。</li><li>被删除的索引行锁腾出的空间在重组之前可以被新的索引行重用。</li></ol><h3 id="新索引行被添加至索引的尾部-永远递增的键"><a href="#新索引行被添加至索引的尾部-永远递增的键" class="headerlink" title="新索引行被添加至索引的尾部(永远递增的键)"></a>新索引行被添加至索引的尾部(永远递增的键)</h3><p>假设插入了一个索引行，其索引键值比任何已经存在的索引键值都要大，则DBMS就不会分类最后的叶子页，那么就不需要空闲的空间或者进行索引重组了。然而，如果在索引前面的索引行被定期地删除，那么为了回收空闲的空间，索引可能不得不进行重组(一个“爬行”的索引)。</p><h3 id="随机插入模式"><a href="#随机插入模式" class="headerlink" title="随机插入模式"></a>随机插入模式</h3><p>我们稍后将会看到，尽管考虑了空闲空间和重组，对于不同的索引行长度(短，中，长)的处理也是不同的。越长的索引行越难处理，越短的越好处理。</p><p>有一个重要的例外场景 : 如果索引行是变长的，那么就需要有空闲的空间去适应任何索引行的增长。</p><h2 id="索引重组的代价"><a href="#索引重组的代价" class="headerlink" title="索引重组的代价"></a>索引重组的代价</h2><p>一个索引可以以多种方式进行重组：</p><ol><li>全索引扫描（随机访问且无须排序，或者顺序访问并排序）。</li><li>全表扫描（类似 CREATE INDEX; 顺序访问及一次排序）。</li></ol><p>由索引重组产生的锁等待依赖于具体的数据库和选项。如果使用的是简易的工具,那么当表或者索引正在被扫描吋，整个表可能被加上一个S锁(更新操作会被阻塞）。如果工具能在扫描期间将更新操作保存下来，并在排序前将它们应用到数据行上，那么锁等待的时间将会缩短很多。</p><p>有些时候，大的索引可能不得不在不合适的时间被重组。在最坏情况下，锁的问题可能会导致频繁的重组无法实现。在这种情况下 ， 一些易变的索引可能必需被强制缓存在内存中（将其固定在内存中）。</p><h1 id="数据库管理系统相关的索引限制"><a href="#数据库管理系统相关的索引限制" class="headerlink" title="数据库管理系统相关的索引限制"></a>数据库管理系统相关的索引限制</h1><h2 id="索引列的数量"><a href="#索引列的数量" class="headerlink" title="索引列的数量"></a>索引列的数量</h2><p>能够复制到索引上的列的个数上限在16至64之间。并非每个人都将这视为一个问题。 Gulutzan 和 Pelzer提出了一个出人意料的<br>建议，如下:</p><blockquote><p>针对所有数据库管理系统的总体建议为：在一个复合索引中最多使用5列。虽然你能够确定数据库管理系统至少能够支持16列，但是5列是一些专家所认为的合理上限。</p></blockquote><h2 id="索引列的总长度"><a href="#索引列的总长度" class="headerlink" title="索引列的总长度"></a>索引列的总长度</h2><p>复制到索引的列的总长度存在一个上限，该上限的值取决于数据库管理系统。随着宽索引变得越来越流行，这一上限在数据库筲理系统的新版本中在变大。</p><h2 id="单表索引数量上限"><a href="#单表索引数量上限" class="headerlink" title="单表索引数量上限"></a>单表索引数量上限</h2><p>在单表索引数量限制方面，许多数据库产品要么没有上限，要么上限太高以至于无关紧要。</p><h2 id="索引大小上限"><a href="#索引大小上限" class="headerlink" title="索引大小上限"></a>索引大小上限</h2><p>典型的索引大小上限为几GB,而且这一上限正在持续增大。就像大表一样，大索引通常是分区的，这样能够使执行维护程序的成本最小化，并且能将索引分散到多个磁盘驱动器或RAID组上。</p><h2 id="索引锁定"><a href="#索引锁定" class="headerlink" title="索引锁定"></a>索引锁定</h2><p>从更新的时间点到提交的时间点内，如果数据库管理系统给一个索引页或者一个索引页的一部分（如一个子页）加了锁，那么该索引页或子页很能会成为瓶颈，因为插入操作将会变为顺序的。例如，SQL Server 2000就是这样做的，但如果上锁的粒度仅为一行，那么这不可能会成一个问题。</p><p>在DB2数据库的z/OS版本中，使用闩锁来保证索引页的物理完幣性。当用闩锁对一个缓冲池中的页加锁时，实际上是在数据库缓冲池中进行了一次置位操作，当释放闩锁时再进行重置。一个页只有在读取或修改时才会被加上闩锁，在当前的处理器条件下耗费时间不到一微秒。而数据完幣性是通过对索引行所指向的表页或表行加上普通锁来保证的（仅对数据上锁）。当程序修改一个表行或表页。这些锁一直不会释放，直至修改被提交。</p><h1 id="数据库索引选项"><a href="#数据库索引选项" class="headerlink" title="数据库索引选项"></a>数据库索引选项</h1><p>索引键决定了这一索引行在索引结构中的位置。当索引键被修改后,DBMS会删除原来的索引行，并将其插入到新的位置上。在最差情况下，索引行会被移动到其他的叶子页上。</p><h1 id="其他评估事项"><a href="#其他评估事项" class="headerlink" title="其他评估事项"></a>其他评估事项</h1><h2 id="宽索引还是理想索引"><a href="#宽索引还是理想索引" class="headerlink" title="宽索引还是理想索引"></a>宽索引还是理想索引</h2><p>单纯从响应时间来看，理想的索引并非具有完全的优势，我们给出了如下结论 :</p><blockquote><p>虽然三星索引有一定的优势，尤其是在结果集为空的情况下，但是这个优势并不也别明显，而且会带来与新增索引相关的额外开销。</p></blockquote><h1 id="组织索引设计过程"><a href="#组织索引设计过程" class="headerlink" title="组织索引设计过程"></a>组织索引设计过程</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>在大公司里，一个合理的折中方案是聘用50/50的专家，他们会将50%的时间用来应用程序开发，另外50%的时间用于协助同事进行索引评估及其他性能问题的处理（比如根据EXPLAIN的输出内容解决某个优化器问题）。经验显示，为每5至10位应用开发者配一名50/50专家的方式效果很好。</p><p>索引设计需要同事掌握技术技能以及应用系统知识。相比让数据库专家熟悉应用系统的细节而言，教会开发人员索引技能是更容易的。</p><hr><p>PDF书籍下载地址：<a href="https://github.com/jiankunking/books-recommendation/tree/master/Database" target="_blank" rel="noopener">https://github.com/jiankunking/books-recommendation/tree/master/Database</a></p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Design </tag>
            
            <tag> 读书笔记 </tag>
            
            <tag> Database </tag>
            
            <tag> MySQL </tag>
            
            <tag> Oracle </tag>
            
            <tag> SQL Server </tag>
            
            <tag> DB2 </tag>
            
            <tag> Index </tag>
            
            <tag> Optimizers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java性能优化权威指南 笔记</title>
      <link href="/java-performance-note.html"/>
      <url>/java-performance-note.html</url>
      
        <content type="html"><![CDATA[<p>本文整理自：《Java性能优化权威指南》 作者：Charlie Hunt / Binu John </p><p>出版时间：2014-03</p><a id="more"></a><h1 id="操作系统性能监控"><a href="#操作系统性能监控" class="headerlink" title="操作系统性能监控"></a>操作系统性能监控</h1><h2 id="CPU使用率"><a href="#CPU使用率" class="headerlink" title="CPU使用率"></a>CPU使用率</h2><p>大多数的操作系统的CPU使用率分为用户态CPU使用率和系统态CPU使用率。</p><p>用户态CPU使用率是指执行应用程序代码的时间占总CPU时间的百分比。</p><p>系统态CPU使用率是指应用执行操作系统调用的时间占总CPU时间的百分比。<font color="DeepPink">系统态CPU使用率高意味着共享资源有竞争或者I/O设备之间有大量的交互。</font></p><p>既然原本用于执行操作系统内核调用的CPU周期也可以用来执行应用代码，所以理想情况下，应用达到最高性能和扩展性时，它的系统态CPU使用率为0%，所以提高应用性能和扩展性的一个目标是尽可能降低系统态CPU使用率。</p><p>对于计算密集型应用来说，不仅要监控用户态和系统态CPU使用率，还要进一步监控每时钟指令数（Instructions Per Clock，IPC）或每指令时钟周期（Cycles Per Instruction，CPI）等指标。这两个指标对于计算密集型应用来说很重要，因为现代操作系统自带的CPU使用率监控工具只能报告CPU使用率，而没有CPU执行指令占用CPU时钟周期的百分比，<font color="DeepPink">这意味着，即便CPU在等待着内存中的数据，操作系统工具仍然会报告CPU繁忙。这种情况通常被称为停滞。当CPU执行指令所用的操作数据不在寄存器或者缓存中时，就会发生停滞，由于指令执行前必须等待数据从内存中装入CPU寄存器，所以一旦发生停滞，就会浪费时钟周期。</font>CPU停滞通常会等待好几百个时钟周期，因此提高计算密集型应用性能的策略就是减少停滞或者改善CPU高速缓存使用率，从而减少CPU在等待内存数据时浪费的时钟周期。</p><h2 id="CPU调度程序运行队列"><a href="#CPU调度程序运行队列" class="headerlink" title="CPU调度程序运行队列"></a>CPU调度程序运行队列</h2><p>监控CPU调度程序运行队列对于分辨系统是否满负荷也有重要意义。<font color="DeepPink">运行队列中就是那些已准备好运行、正等待可用CPU的轻量级进程。如果准备运行的轻量级进程数超过系统所能处理的上限，运行队列就会很长。</font>运行队列长表明系统负载可能饱和。系统运行队列长度等于虚拟机处理器的个数时，用户不会明显感觉到性能下降。此处虚拟处理器的个数就是系统硬件线程的个数，也是Java API Runtime.availableProcessors()的返回值。当运行队列长度达到虚拟处理的4倍或者更多时，系统的响应就非常迟缓了。</p><p>一般性的指导原则是：如果在很长一段时间里，运行队列的长度一直都超过虚拟处理器个数的1倍，就需要关注了，只是暂时还不需要立刻采取行动。如果在很长一段时间里，运行队列长度达到虚拟处理器个数的3~4倍或更高，则需要立刻引起注意和采取行动。</p><h2 id="内存使用率"><a href="#内存使用率" class="headerlink" title="内存使用率"></a>内存使用率</h2><p>系统在进行页面交换或者使用虚拟内存时，Java应用或JVM会表现出明显的性能问题。当应用运行所需的内存超过可用物理内存时，就会发生页面交换。为了应对这种可能出现的情况，通常要为系统配置swap空间。swap空间一般会在一个独立的磁盘分区上。当应用耗尽内存时，操作系统会将应用的一部分置换到磁盘上的swap空间。通常是应用中最少运行的部分，以免影响整个应用或者应用最忙的那部分。当访问应用中被置换出去的部分时，就必须将它从磁盘置换进内存，而这种置换活动会对应用的响应性和吞吐量造成很大影响。</p><p><font color="DeepPink">JVM垃圾收集器在系统页面交换时的性能也很差，这是由于垃圾收集器为了回收不可达对象所占用的空间，需要访问大量的内存。如果Java堆得一部分被置换出去，就必须先置换进内存以便垃圾收集器扫描存活对象，这会增加垃圾收集的持续时间。</font>垃圾收集是一种Stop-The-World操作，即停止所有正在运行的应用线程，如果此时系统正在进行页面交换，则会引起JVM长时间的停顿。</p><h3 id="监控抢占式上下文切换"><a href="#监控抢占式上下文切换" class="headerlink" title="监控抢占式上下文切换"></a>监控抢占式上下文切换</h3><p>让步式上下文切换时指执行线程主动释放CPU，抢占式上下文切换时指线程因为分配的时间片用尽而被迫放弃CPU或者被其他优先级更高的线程锁抢占。pidstat的输出结果中cswch/s是每秒的让步式上下文切换，nvccswch/s是抢占式上下文切换。</p><h3 id="监控线程迁移"><a href="#监控线程迁移" class="headerlink" title="监控线程迁移"></a>监控线程迁移</h3><p>我们发现，待运行线程在处理器之前的迁移也会导致性能的下降。大多数操作系统的CPU调度程序会将待运行线程分配给上次运行它的虚拟处理器。如果这个虚拟处理器忙，调度程序就会将待处理线程迁移到其他可用的虚拟处理器。<font color="DeepPink">线程迁移会对应用性能造成影响，这是因为新的虚拟处理器缓存中可能没有待运行线程所需的数据或状态信息。</font>多核系统上运行Java应用可能会发生大量的线程迁移，减少迁移的策略是创建处理器组并将应用分配给这些处理器组。一般性准则是，如果横跨多核或虚拟处理器的Java应用每秒迁移超过500此将Java应用绑定在处理器组上就有好处。</p><h2 id="网络I-O使用率"><a href="#网络I-O使用率" class="headerlink" title="网络I/O使用率"></a>网络I/O使用率</h2><h3 id="应用性能改进的考虑"><a href="#应用性能改进的考虑" class="headerlink" title="应用性能改进的考虑"></a>应用性能改进的考虑</h3><p>单次读写数据量小而网络读写量大的应用会消耗大量的系统态CPU，产生大量的系统调用。对于这类应用，减少系统态CPU的策略是减少网络读写的系统调用。此外，使用非阻塞的Java NIO而不是阻塞的java.net.Socket，减少处理请求和发送相应的线程数，也可以改善应用性能。</p><p>从非阻塞Socket中读取数据的策略是，应用在每次读请求时尽可能多地读取数据。同样，当往Socket中写数据时，每个写调用应该尽可能多地写。</p><h1 id="JVM概览"><a href="#JVM概览" class="headerlink" title="JVM概览"></a>JVM概览</h1><h2 id="HotSpot-运行时"><a href="#HotSpot-运行时" class="headerlink" title="HotSpot 运行时"></a>HotSpot 运行时</h2><h3 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h3><p>HotSpot VM 命令行选项有3类：</p><ul><li>标准选项（Standard option）：标准选项是 Java virtual Machine Specification 要求所有java JVM 都必须实现的选项。</li><li>非标准选项（NonStandard option）：非标准选项(以 –X 为前缀)，不保证也不强制所有JVM实现都必须支持。</li><li>非稳定选项（Developer option）：非稳定选项(以-XX为前缀),通常为了特定需要而对JVM的运行进行矫正。选项名称前+代表 true启用，-代表false关闭。</li></ul><h3 id="VM生命周期"><a href="#VM生命周期" class="headerlink" title="VM生命周期"></a>VM生命周期</h3><p>启动器启动HotSpot VM时会执行一系列操作。步骤概述如下：</p><ol><li>解析命令行选项</li><li>设置堆的大小和JIT编译器<br>如果命令行没有明确设置堆的大小和JIT编译器，启动器则通过自动优化进行设置。</li><li>设定环境变量如：LD_LIBRARY_PATH和CLASSPATH</li><li>如果命令行有-jar选项，启动器则从指定JAR的manifest中查找Main-Class，否则从命令行读取Main-Class</li><li>使用标准Java本地接口（Java Native Interface，JNI）方法JNI_CreateJavaVM在新创建的线程中创建HotSpot VM</li><li>一旦创建并初始化号HotSpot VM，就会加载Java Main-Class，启动器也会从Java Main-Class中取得Java main方法的参数</li><li>HotSpot VM通过JNI方法CallStartVoidMethod调用Java main方法，并将命令行选项传给它</li></ol><h3 id="VM类加载阶段"><a href="#VM类加载阶段" class="headerlink" title="VM类加载阶段"></a>VM类加载阶段</h3><h4 id="类加载阶段"><a href="#类加载阶段" class="headerlink" title="类加载阶段"></a>类加载阶段</h4><p>对于给定的Java类或接口，类加载时会依据它的名字找到Java类的二进制类文件，定义Java类，然后创建代表这个类或者接口的java.lang.Class对象。如果没有找到Java类或接口的二进制表示就会抛出NoClassDefFound。此外，类加载阶段会对类的格式进行语法检查，如果有错，则会抛出ClassFormatError或UnsupportedClassVersionError。Java类加载前，HotSpot VM必须先加载它的所有超类和超接口，如果类的继承层次有错，例如Java类是它自己的超类或超接口（类层次递归）,HotSpot VM则会抛之l}ClassCircularityError。如果所引用的直接超接口本身并不是接口，或者直接超类实际上是接口，HotSpot VM则会抛出VM会抛出IncompatibleClassChangeError。</p><p>链接的第一步是验证，检查类文件的语义、常量池符号以及类型。如果检查有错，就会抛出VerifyError。链接的下一步是准备，它会创建静态字段，初始化为标准默认值，以及分配方法表、请注意，此时还没有执行任何Java代码。接下来解析符号引用，这一步是可选的。然后初始化类，运行类构造器。这是迄今为止，类中运行的第一段Java代码。值得注意的是，<font color="DeepPink">初始化类需要首先初始化超类（不会初始化超接口）</font>。</p><blockquote><p>如：int的标准默认值为0；public static int alue=123，准备阶段将其初始化为0而不是123，value=123的赋值操作在内构造器<clinit>()中。<br>public static final int value=123，编译时会为value在字段属性表中生成ConstantValue，从而在准备阶段就被初始化成123。</clinit></p></blockquote><p>Java Virtual Machine Specification规定首次使用类时进行类初始化，而Java Language Specification则允许在链接阶段符号解析时灵活处理，只要保持语言的语义不变，JVM依次执行加载、链接和初始化，保证及时抛出错误即叮。出于性能优化的考虑，通常直到类初始化时HotspotVM才会加载和链接类。<font color="DeepPink">这意味着．类A引用类B。加载A不一定导致加载B（除非B需要验证）。执行B的第一条指令会导致初始化B，从而加载和链接B。</font></p><h4 id="类加载器委派"><a href="#类加载器委派" class="headerlink" title="类加载器委派"></a>类加载器委派</h4><p>当请求类加载器查找和加载某个类时，该类加载器可以转而请求别的类加载器来加载。这被称为类加载器委派。类的首个类加找器称为初始类加载器（Initiating ClassLoader)，最终定义类的类加载器称为定义类加载器（Defining ClassLoader）。<font color="DeepPink">就字节码解析而言，某个类的初始类加载器是指对该类进行常量池符号解析的类加载器。</font></p><p>类加载器之间是层级化关系，每个类加载器都可以委派给上一级类加载器。这种委派关系定义了二进制类的查找顺序。Java SE类加载器的层级查找顺序为启动类加载器、扩展类加载器及系统类加载器。系统类加载器是默认的应用程序类加载器，它加载Java类的main方法并从classpath上加载类。应用程序类加载器可以是Java SE系统自带的类加载器，或者由应用程序开发人员提供。扩展类加载器则JavaSE系统实现，它负责从JRE(Java Runtime Environment,Java运行环境）的lib/ext目录下加载类。</p><h4 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h4><p>启动类加载器是由HotSpot VM实现的，负责加载BOOTCLASSPATH路径中的类，如包含Java SE类库的rt.jar。为了加快启动速度，Client模式的HotSpot VM可以通过称为类教据共享（Class Data Sharing）的特性使用已经预加载的类。这个特性默认为开启，可由HotSpot VM命令行开关-Xshare:on开启，-Xshare:off关闭。到本书编写时为止，Server模式的HotSpot VM还不支持类数据共享，而且即便是Client模式，也只有使用Serial收集器时才支持该机制。</p><h4 id="类型安全"><a href="#类型安全" class="headerlink" title="类型安全"></a>类型安全</h4><p>Java类或接口的名字为全限定名（包括包名）。Java的类型由全限定名和类加载器唯一确定。</p><h4 id="HotSpot类元数据"><a href="#HotSpot类元数据" class="headerlink" title="HotSpot类元数据"></a>HotSpot类元数据</h4><p>类加载时，HotSpot VM会在永久代创建类的内部表示instanceKlass或arrayKlass。instanceKlass应用了与之对应的java.lang.Class实例，后者是前者的Java镜像。HotSpot VM内部使用称为klassOop的数据结构访问instanceKlass。后缀“Oop”表示普通对象指针，所以klassOop是应用java.lang.Class的HotSpot内部抽象，它是指向Klass（与Java类对应的内部表示）的普通对象指针。</p><h4 id="内部的类加载数据"><a href="#内部的类加载数据" class="headerlink" title="内部的类加载数据"></a>内部的类加载数据</h4><p>类加载过程中，HotSpot VM维护了3张散列表。SystemDictionary包含已加载的类，它将建立类名/类加载器（包括初始类加载器和定义类加载器）与klassOop对象之间的映射。目前只有在安全点事才能移除SystemDictionary中的元素。Placeholder-Table包含当前正在加载的类，它用于检查ClassCircularityError，多线程类加载器并行加载类时也会用到它。LoaderConstraintTable用于追踪类型安全检查的约束条件。<font color="DeepPink">这些散列表都需要加锁保证访问安全，在HotSpot VM中，这个锁称为SystemDictionary_lock。通常，HotSpot VM借助类加载器对象锁对加载类的过程进行序列化。</font></p><h3 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h3><p>Java是一门类型安全语言，官方标准的Java编译器（javac）可以生成合法的类文件和类型安全的字节码，但Java虚拟机无法确保字节码一定是由可信的javac编译器产生的，所以在链接时必须进行字节码验证以保障类型安全。</p><h3 id="类数据共享"><a href="#类数据共享" class="headerlink" title="类数据共享"></a>类数据共享</h3><p>类数据共享是Java 5引人的特性，以缩短Java程序（特別是小程序）的启动时间，同时也能减少它们的内存占用。使用Java HotSpot JRE安装程序在32位平台上安装Java运行环境（JRE)时，安装程序会加载系统jar中的部分类，变成私有的内部表示并转储成文件，称为共享文档(Shared Archive)。如果过没有使用Java HotSpot JRE安装程序，也可以手工生成该文件。之后调用Java虚拟机时，共享文档会映射到JVM内存中，从而减少减少加载这些类的开销，也使得这些类的大部分JVM允数椐能在多个JVM进程间共享。</p><h3 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h3><p>HotSpot VM解释器是一种基于模板的解释器。JVM启动时，HotSpot VM运行时系统利用内部TemplateTable中的信息在内存中生成解析器。TemplateTable包含于每个字节码对应的机器代码，每个模板描述一个字节码。</p><p>HotSpot VM解释器堪于模板的设计要好于传统的switch语句循环方式。switch语句需要重复执行比较操作，最差情况需要和所冇字节码比较。此外，switch语句必须使用单独的软件栈传递 Java 参数。HotSpot VM使用本地C栈传递 Java 参数。一些存储在C变量中的HotSpot VM内部变量，例如Java线程的程序计数器或栈指针，并不能保证总是存储在底层硬件寄存器中。结果，管理这些软件解释器数据结构就会占去总执行时间的相当大一部分。不过总体来说，HotSpot解释器显著缩短HotSpot VM和实体机之问的性能差距，解释速度也明显变快了，然而代价是大量与机器相关的代码。例如，Intel X86平台特定的代码大约有10000行，SPARC平台专用的代码大约打14000行。由于需要支持动态代码生成（JIT编译），整体的代码量和复杂度也显著变大。并且调 试动态生成的机器码（ JIT编译代码）比调试静态代码困难多了。虽然这些不利于运行时系统的改善，但也并非不可能完成的任务。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>当与Java的语义约束冲突时，Java虚拟机会用异常通知程序。异常处理由HotSpot VM解释器、JIT编译器和其他HotSpot VM组件一起协作实现。异常处理主要有两种情形，同一方法中抛出和捕获异常，或由调用方法捕获异常。异常可以由抛出字节码、VM内部调用返回、JNI调用返回或Java调用返回所引发。</p><h3 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h3><p><font color="DeepPink">HotSpot VM通过协作、轮询的机制创建安全点</font>。简中来说，线程会经常询问：“我该在安全点停住么？ ”高效地询问这个问题并不是件容易的事。线程在状态变迁的过程中，会经常询问这个问题，但并非所有的状态变迁都会如此询问，比如线程离开HotSpot VM进人本地代码的情况。此外，JIT编译代码从java方法中返回或正作循环迭代的某个阶段时，线程也会询问“我该在安全点停住吗？ ”。正在执行解释代码的线程通常不会询问它们是否该在安全点停住。相反，当解释器切换到不同的分配表时，会请求安全点。切换操作中包含一部分代码，用以询问何时离开安全点。当离开安全点时，分配表会再次切换回来。一旦请求了安全点，VMThread就必须在继续执行VM操作前等待，直到确定所行线程都已进入安全点保全状态为止。在安全点时，VMThread用Threads_lock阻塞所有正在运行的线程，VM操作完成后 , VMThread释放Threads_lock。</p><h3 id="Java本地接口（JNI）"><a href="#Java本地接口（JNI）" class="headerlink" title="Java本地接口（JNI）"></a>Java本地接口（JNI）</h3><p>切记，一旦在应用中使用JNI，就意味着丧失了Java平台的两个好处,依赖JNI的Java应用难以在多种异构的硬件平台上运行。即便应用中Java语言编写的部分可以移植到多种硬件平台，采用本地编程语言的部分也需要重新编译。换句话说，一旦使用JNI就失去了Java承诺的特性，即“一次编写，到处运行”。其次，Java是强类型和安全的语言,本地语言如C或C++则不是。因此，Java开发者用JNI编写应用时必须格外小心。误用本地力可能破坏整个应用。鉴于此，在调JNI方法前，Java应用常常需要安仝检查。额外的安全检查以及HotSpot VM在Java与JNI之间的数据复制会降低应用的性能。</p><p>HotSpot VM追踪正在执行本地方法的线稈时必须特別小心。在HotSpot VM的某些活动过程中，尤其是垃圾收柒的某些阶段，线程必须在安全点时暂停，以保证Java内存堆不被更改，确保垃圾收集的准确性。当HotSpot VM线程执行本地代码到达安全点时，线程可以继续执行本地代码，直到它Java代码或者发起JNI调用为止。</p><h3 id="VM致命错误处理"><a href="#VM致命错误处理" class="headerlink" title="VM致命错误处理"></a>VM致命错误处理</h3><p>HotSpot内部使用信号进行通信。当无法识别信号时，将调用致命错误处理程序。在无法识别的情况下，它可能来自应用程序JNI代码，OS本地库，JRE本地库或JVM本身的错误。</p><h2 id="HotSpot-VM垃圾收集器"><a href="#HotSpot-VM垃圾收集器" class="headerlink" title="HotSpot VM垃圾收集器"></a>HotSpot VM垃圾收集器</h2><h3 id="分代垃圾收集"><a href="#分代垃圾收集" class="headerlink" title="分代垃圾收集"></a>分代垃圾收集</h3><p>垃圾收集器不耑要扫描幣个（可能比新生代更大）老年代就能识别新生代中的存活对象，从而缩短Minor GC的时间。HotSpot VM的垃圾收集器使用称为卡表（CardTable)的数据结构来达到这个目的。老年代以512字节为块划分成若十张卡（Card)。卡表是个单字节数组，每个数组元索对位堆中的一张卡。每次老年代对象中某个引用新生代的字段发生变化时，HotSpot VM就必须将该卡所对位的卡表元素设置为适当的值，从而将该引用字段所在的卡标记为脏。在Minor GC过程中，垃圾收集器只会在脏卡中扫描查找老年代-新生代引用。<br><img alt data-src="/images/java-performance-note/%E5%9B%BE3-3.png"><br>HotSpot VM的字节码解释器和JIT编译器使用写屏障(Write Barrier)维护卡表。写屏障足是一小段将卡状态设罝为脏的代码。解释器每次执行更新引用的字节码时，邰会执行一段写屏障；JIT 编译器在生成更新引用的代码后，也会生成一段写屏障。虽然写屏障使得应用线程增加了一些性能开销，但Minor GC变快了许多，整天的垃圾收集效率也提高了许多。通常应用的吞吐量也会有所改善。</p><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>需要指出的足，<font color="DeepPink">在Minor GC过程中，Survivor可能不足以容纳Eden和另一个Survivor中的存活对象。如果Survivor 中的存活对象溢出，多余的对象将被移到老年代。这称为过早提升(Premature Promotion)</font>。这会导致老年代中短期存活对象的增长，可能会引发严重的性能问题。再进一步说，在Minor GC过程中，如果老年代满了而无法容纳更多的对象，Minor GC之后通常就会进行Full GC,这将导致遍历整个Java堆。这称为提升失败（Promotion Failure）。</p><h3 id="快速内存分配"><a href="#快速内存分配" class="headerlink" title="快速内存分配"></a>快速内存分配</h3><p>对象内存分配器的操作需要和垃圾收集器紧密配合。垃圾收災器必须记录它冋收的空间，而分配器在重用堆空间之前耑要找到可以满足其分配需求的空闲空间。垃圾收集器以复制方式回收HotSpot VM 新生代，其好处在于回收以后Eden总为空，在Eden中运用被称为指计碰撞(Bump-the-Pointer)的技术就可以有效地分配空间。这种技水迫踪最后—个分配的对象（常称为top),当有新的分己请求时，分配器只需要检查top和eden未端之间的空间是否能容纳。如果能容纳，top则跳到新近分配对象的未端。</p><p><font color="DeepPink">重要的Java应用大多是多线程的，因此内存分配的操作需要考虑多线程安全。如果只用全局锁，在Eden中的分配操作就会成为瓶颈而降低性能。HotSpot VM没有采用这种方式，而是以一种称为线程本地分配缓冲区（thread-Local Allocation Buffer,TLAB)的技术，为每个线程设设置各自的缓冲区(即Eden的一小块），以此改善多线程分配的吞吐量。因为每个TLAB都只有一个线程从中分配对象，所以可以使用指针碰撞技术快速分配而不需要任何锁。然而当线程的TLAB填满耑要获取新的空间时（不常见），它就需要采用多线程安全的方式了。大部分时候，HotSpot VM的new Object()操作只需要大约十条指令。垃圾收集器清空Eden区域，然后就可以支持快速内存分配了。</font></p><h2 id="HotSpot-VM-JIT编译器"><a href="#HotSpot-VM-JIT编译器" class="headerlink" title="HotSpot VM JIT编译器"></a>HotSpot VM JIT编译器</h2><p>经典的寄存器分配策略是图着色算法，通常可以使机器寄存器的使用率达到最高，而且多余的值很少会卸载到栈中。图表示的是同时有哪些变量在使用．以及哪些寄存器可以存放这些变虽。如果同时存活的变量数超过了可用的寄存器数，垂要性最低的变狱将被移到栈中，使得其他变量可以使用寄存器。指派某个变量给寄存器通常需要来回几次构建图和着色。这也份致了它的不足，图着色算法花费的时间、数据结构所需的空间都比较昂贵。</p><h1 id="JVM性能监控"><a href="#JVM性能监控" class="headerlink" title="JVM性能监控"></a>JVM性能监控</h1><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><h3 id="重要的垃圾收集数据"><a href="#重要的垃圾收集数据" class="headerlink" title="重要的垃圾收集数据"></a>重要的垃圾收集数据</h3><p>重要的垃圾收集数据包括：</p><ul><li>当前使用的垃圾收集器</li><li>Java堆的大小</li><li>新生代和老年代的大小</li><li>永久代的大小</li><li>Minor GC的持续时间</li><li>Minor GC的频率</li><li>Minor GC的空间回收量</li><li>Full GC的持续时间</li><li>Full GC的频率</li><li>每个并发垃圾收集周期内的空间回收量</li><li>垃圾收集前后Java堆的占用量</li><li>垃圾收集前后新生代和老年代的占用量</li><li>垃圾收集前后永久代的占用量</li><li>是否老年代或永久代的占用触发了 Full GC</li><li>应用是否显式调用了 System.gc()</li></ul><h3 id="垃圾回收报告"><a href="#垃圾回收报告" class="headerlink" title="垃圾回收报告"></a>垃圾回收报告</h3><h3 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h3><p>可以使用-XX:+ Print Compilation监控 HotSpot JIT编译器。-XX:+ PrintCompilation为每<br>次编译生成一行日志。</p><p>日志样例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7java. lang String: indexOf (151 bytes)</span><br><span class="line">8% !sun. awt. image. PNGImageDecoder: produceImage a 960 (1920 bytes)</span><br><span class="line">9  !sun awt. image. PNGImageDecoder: produceImage (1920 bytes)</span><br><span class="line">10java. lang. AbstractStringBuilder: append(40 bytes)</span><br><span class="line">11njava. lang System: arraycopy (static)</span><br><span class="line">12sjava util. Hashtable: get (69 bytes)</span><br><span class="line">13bjava util. HashMap: indexFor (6 bytes)</span><br><span class="line">14made zombie java. awt. geom. Path2DSIterator: isDone (20 bytes)</span><br></pre></td></tr></table></figure><h1 id="JVM性能调优入门"><a href="#JVM性能调优入门" class="headerlink" title="JVM性能调优入门"></a>JVM性能调优入门</h1><h2 id="应用程序的系统需求"><a href="#应用程序的系统需求" class="headerlink" title="应用程序的系统需求"></a>应用程序的系统需求</h2><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p><font color="DeepPink">吞吐量是对单位时间内处理工作量的度量</font>。设计吞吐量需求时,我们一般不考虑它对延迟或者响应时间的影响。通常情况下,增加吞吐量的代价是延迟的增加或内存使用的增加。</p><p>吞吐量性能需求的一个典型例子是,应用程序每秒需要完成2500次事务。</p><h3 id="延迟或响应性"><a href="#延迟或响应性" class="headerlink" title="延迟或响应性"></a>延迟或响应性</h3><p><font color="DeepPink">延迟,或者响应性,是对应用程序收到指令开始工作直到完成该工作所消耗时间的度量。</font></p><p>定义延迟或响应性需求时并不考虑程序的吞吐量。通常情况下,提高响应性或缩小延迟的代价是更低的吞吐量、或者更多的内存消耗(或者二者同时发生)</p><p>延迟或响应需求的一个典型例子是,应用程序应该在60毫秒内完成交易请求的处理工作。</p><h3 id="内存占用"><a href="#内存占用" class="headerlink" title="内存占用"></a>内存占用</h3><p><font color="DeepPink">内存占用指在同等程度的吞吐量、延迟、可用性和可管理性前提下,运行应用程序所需的内存大小。</font>内存占用通常以运行应用程序需要的Java堆大小或者运行应用程序需要的总内存大小来表述。一般情况下,通过增大Java堆的方式增加可用内存能够提高吞吐量、降低延迟或者兼顾二者。应用程序的可用内存减少时,吞吐量和延迟通常都会受到影响。应用程序的内存占用限制了固定内存的机器上能同时运行的应用程序实例数。</p><p>内存占用需求的一个典型例子是,应用程序需要在拥有8GB内存的系统上以单个实例方式运行或者在24GB内存的系统上以3个应用程序实例方式运行。</p><h2 id="性能收集调优基础"><a href="#性能收集调优基础" class="headerlink" title="性能收集调优基础"></a>性能收集调优基础</h2><h3 id="性能属性"><a href="#性能属性" class="headerlink" title="性能属性"></a>性能属性</h3><ul><li>吞吐量:是评价垃圾收集器能力的重要指标之一,指不考虑垃圾收集引起的停顿时间或内存消耗,垃圾收集器能支撑应用程序达到的最高性能指标。</li><li>延迟:也是评价垃圾收集器能力的重要指标,度量标准是缩短由于垃圾收集引起的停顿时间或完全消除因垃圾收集所引起的停顿,避免应用程序运行时发生抖动。</li><li>内存占用:垃圾收集器流畅运行所需要的内存数量。</li></ul><p><font color="DeepPink">这其中任何一个属性性能的提高几乎都是以另一个或两个属性性能的损失作代价的。换句话说,某一个属性上的性能提高总会牺牲另一个或两个属性。然而,对大多数的应用而言,极少出现这三个属性的重要程度都同等的情况。很多时候,某一个或两个属性的性能要比另一个重要。</font></p><p>我们需要了解对应用程序而言哪些系统需求是最重要的,也需要知道对应用程序而言这三个性能属性哪些是最重要的。确定哪些属性最重要,并将其映射到应用程序的系统需求,对应用程序而言非常重要。</p><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>谈到JVM垃圾收集器调优也有三个需要理解的基本原则。</p><ul><li>每次 Minor GC都尽可能多地收集垃圾对象。我们把这称作“ Minor gc回收原则”。遵守这原则可以减少应用程序发生 Full GC的频率。 Full GC的持续时间总是最长的,是应用程序无法达到其延迟或吞吐量要求的罪魁祸首。</li><li>处理吞吐量和延迟问题时,垃圾处理器能使用的内存越大,即Java堆空间越大,垃圾收集的效果越好,应用程序运行也越流畅。我们称之为“GC内存最大化原则”。</li><li>在这三个性能属性(吞吐量、延迟、内存占用)中任意选择两个进行JVM垃圾收集器调优。我们称之为“GC调优的3选2原则”。</li></ul><p>调优JVM垃圾收集的过程中谨记这三条原则能帮助你更轻松地调优垃圾收集,达到应用程序的性能要求。</p><h2 id="确定内存占用"><a href="#确定内存占用" class="headerlink" title="确定内存占用"></a>确定内存占用</h2><h3 id="HotSpot-VM堆布局"><a href="#HotSpot-VM堆布局" class="headerlink" title="HotSpot VM堆布局"></a>HotSpot VM堆布局</h3><p>通过-Xmn可以很方便地设定新生代空间的初始值和最大值。有一点需要特别注意,如果-Xms和-Ⅺmx并没有设定为同一个值,使用-Xmn选项时,Java堆的大小变化不会影响新生代空间,即新生代空间的大小总保持恒定,而不是随着Java堆大小的扩展或缩减做相应的调整。因此,请注意,只有在-Xms与-Xmx设定为同一值时才使用-Xmn选项。</p><p>老年代空间的大小会根据新生代的大小隐式设定。老年代空间的初始值为-Xmx的值减去XX:    News zel的值。老年代空间的最小值为-Xmx的值减去-XX: MaxNewSize的值。如果-Xms与Xmx设置为同一值,同时使用了-Xmn,或者-XX: Newsize与-XX: MaxNewsize一样,则老年代的大小为-Xmx(或-Xms)的值减去-Xmn。</p><p>实际上,当 HotSpot VM发现当前可用空间不足以容纳下一次 Minor go提升的对象时就会进行 Full GC。与因空间问题导致的 Minor<br>GC过程中的对象提升失败比较起来,这种方式的代价要小得多。从失败的对象提升中恢复是一个很昂贵的操作。水久代没有足够的空间存储新的VM或类元数据时也会发生 Full GC。</p><p>如果Full G缘于老年代空间已满,即使永久代空间并没有用尽,老年代和永久代都会进行垃圾收集。同样,如果Full GC由永久代空间用尽引起,老年代和永久代也都会进行垃圾收集,无论老年代是否还有空闲空间。开启-XX:+UseParallelGC或-XX:+ UseParallelOldGC时,如果关闭-XX:-ScavengeBeforeFulIGC, HotSpot VM在Full GC之前不会进行Minor GC,但FuGC过程中依然会收集新生代;如果开启-XX:+ScavengeBeforeFullGC, HotSpot VM在FuGC前会先做一次Minor GC,分担一部分Full GC原本要做的工作。</p><h3 id="堆大小调优着眼点"><a href="#堆大小调优着眼点" class="headerlink" title="堆大小调优着眼点"></a>堆大小调优着眼点</h3><p>如果你使用的HotSpot VM不接受-XX:+UseparallelOldGC选项,可以使用-XX:+UseParallelOldGC代替。如果你很清楚Java应用程序要使用多大的Java堆空间,可以将Java堆大小作为调优的入手点,使用-Xmx和-Xms设置Java堆的大小。如果你不清楚Java应用程序到底需要使用多大的Java堆,可以利用HotSpot VM自动选取Java堆的大小。启动ava应用程序时不指定-Xmx或-Xms的值, HotSpot VM会自动设定Java堆大小的初始值。换句话说,这是一个起始点。随着调优过程,后面会逐渐调整Java堆的大小。</p><p>通过HotSpot命令行选项-XX:+PrintCommandLineFlags还可以查看堆的初始值及最大值。-XX:+PrintCommandlineFlags选项可以输出HotSpot VM初始化时使用-XX:InitialHeapSize=&lt;n&gt; -XX:MaxHeapSize=&lt;m&gt;指定的堆的初始值及最大值,其中&lt;n&gt;是以字节为单位的初始Java堆大小,&lt;m&gt;是以字节为单位的堆的最大值。</p><h3 id="计算活跃数据大小"><a href="#计算活跃数据大小" class="headerlink" title="计算活跃数据大小"></a>计算活跃数据大小</h3><p>活跃数据大小是应用程序运行于稳定态时,长期存活的对象在Java堆中占用的空间大小。换句话说,活跃数据大小是应用程序运行于稳定态,FuGC之后Java堆中老年代和永久代占用的空间大小。</p><p>Java应用的活跃数据大小可以通过GC日志收集。活跃数据大小包括下面的内容:</p><ul><li>应用程序运行于稳定态时,老年代占用的Java堆大小;</li><li>应用程序运行于稳定态时,永久代占用的Java堆大小。<br>除了活跃数据大小,稳定态的FuGC也会对延迟带来严重影响。</li></ul><p>为了更好地度量应用程序的活跃数据大小,最好在多次 Full GC之后再查看Java堆的占用情况。另外,需要确保 Full GC发生时,应用程序正处于稳定态。</p><p>如果应用程序没有发生 Full GC或者不经常发生 Full GC,你可以使用JM监控工具ⅤisuaL VM或JConsole人工触发 Full GC。你也可以使用HotSpot JDK发行版中提供的jmap命令,通过命令行强制进行Full GC。为了实现这个目的,jmap需要使用- histo:live命令行选项及JVM进程号。JVM进程号可以通过JDK的js命令获得。例如,Java应用程序的JM进程号是348,使用jmap触发 Full GC的命令行如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -histo: live 348</span><br></pre></td></tr></table></figure><p>jmap命令触发 Full Gc的同时也生成一份包含对象分配信息的堆分析文件。为了专注本步操作,你可以忽略生成的堆分析文件。</p><h3 id="初始化堆大小配置"><a href="#初始化堆大小配置" class="headerlink" title="初始化堆大小配置"></a>初始化堆大小配置</h3><p>推荐的做法是基于最差延迟进行估算。</p><table><thead><tr><th>空间</th><th>命令行选项</th><th>占用倍数</th></tr></thead><tbody><tr><td>Java堆</td><td>-Xms和-Xmx</td><td>3-4倍Full GC后的老年代空间占用量</td></tr><tr><td>永久代</td><td>-XX:Permsize<br>-XX:MaxPermSize</td><td>1.2-1.5倍Full GC后的永久代空间占用量</td></tr><tr><td>新生代</td><td>-Xmn</td><td>1~1.5倍 Full GC后的老年代空间占用量</td></tr><tr><td>老年代</td><td>Java堆大小减新生代大小</td><td>2-3倍Full GC后的老年代空间占用量</td></tr></tbody></table><h2 id="调优延迟-响应性"><a href="#调优延迟-响应性" class="headerlink" title="调优延迟/响应性"></a>调优延迟/响应性</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>这一步调优有多个输入,都源于应用程序的系统性需求。</p><ul><li>应用程序可接受的平均停滞时间。平均停滞时间将与测量出的Minor GC持续时间进行比较。</li><li>可接受的Minor GC(会导致延迟)频率。 Minor GC的频率将与可容忍的值进行比较。对应用程序干系人而言,GC持续的时间往往比GC发生的频率更重要。</li><li>应用程序干系人可接受的应用程序的最大停顿时间。最大停顿时间将与最差情况下Full GC的持续时间进行比较。</li><li>应用程序干系人可接受的最大停顿发生的频率。最大停顿发生的频率基本上就是Full GC的频率。同样,对于大多数应用程序干系人而言,相对于GC的频率,他们更关心GC持续的平均停顿时间和最大停顿时间。</li></ul><h3 id="优化新生代的大小"><a href="#优化新生代的大小" class="headerlink" title="优化新生代的大小"></a>优化新生代的大小</h3><p>调整新生代空间时,需要谨记下面几个准则：</p><ul><li>老年代空间大小不应该小于活跃数据大小的1.5倍。</li><li>新生代空间至少应为Java堆大小的10%,通过Xmx和-Xms可以设定该值。新生代过小可能适得其反,会导致频繁的Minor GC。</li><li>增大Java堆大小时,需要注意不要超过JVM可用的物理内存数。堆占用过多内存将导致底层系统交换到虚拟内存,反而会造成垃圾收集器和应用程序的性能低下。</li></ul><h3 id="监控晋升阈值"><a href="#监控晋升阈值" class="headerlink" title="监控晋升阈值"></a>监控晋升阈值</h3><p>最大晋升阈值可以通过HotSpot VM的命令行选项-XX: MaxTenuringThreshold=&lt;n&gt;设置。使用HotSpot VM的命令行选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX: +PrintTenuringDistribution</span><br></pre></td></tr></table></figure><p>可以监控晋升的分布或者对象年龄分布,并以此为依据确定最优的最大晋升阈值值。</p><p>通过-XX:+PrintTenuringDistribution命令行选项可以观察Survivor空间中的对象是如何老化的。在-XX:+ PrintTenuringDistribution生成的输出中,我们需要关注的是随着对象年龄的增加,各对象年龄上字节数减少的情况,以及 HotSpot VM计算出的晋升阈值是否等于或接近设置的最大晋升阈值。</p><p>XX:+PrintTenuringDistribution会输出每次Minor GC时晋升分布的情况。它也可以和其他的垃圾收集命令行选项,例如-XX:+PrintGCDateStamps、-XX:+PrintGcTime Stamps或-XX:+PrintgCDetails配合使用。对Survivor空间的有效对象老化进行微调时,应该使用选项XX:+PrintTenuringDistribution在垃圾收集日志中包含晋升分布的统计信息。同样,如果需要在生产环境中判断一个应用程序事件是否源于一次Stop-The-World压缩式垃圾收集,往往也需要获取晋升分布的日志信息,使用该选项是非常有帮助的。</p><blockquote><p>通常情况下,观察到新的晋升阈值持续小于最大晋升阈值,或者观察到 Survivor空间大小小于总的存活对象大小都表明 Survivor空间过小。</p></blockquote><h3 id="调整-Survivor空间的容量"><a href="#调整-Survivor空间的容量" class="headerlink" title="调整 Survivor空间的容量"></a>调整 Survivor空间的容量</h3><p>调整Survivor空间容量一个应该谨记于心的重要原则:<font color="DeepPink">调整Survivor空间容量时,如果新生代空间大小不变,增大Survivor空间会减少Eden空间;而减少Eden空间会增加Minor GC的频率。</font>因此,为了同时满足应用程序Minor GC频率的要求,就需要增大当前新生代空间的大小;即增大Survivor空间大小时,Eden空间的大小应该保持不变。换句话说,每当 Survivor空间增加时,新生代空间都应该增大。如果可以增大Minor GC的频率,你可以选择用一部分Eden空间来增大Survivor空间,或者直接增大新生代空间大小。如果内存足够,相对于减少Eden空间.增加新生代大小通常是更好的选择。保持Eden空间大小恒定, Minor GC的频率就不会由于Survivor空间增大而发生变化。</p><blockquote><p>如果你观察到垃圾收集中晋升分布极少出现对象年龄为15的情况,并且也没有发生Surviⅳvor空间溢出,那么应该设置最大晋升阈值为其默认值15。这种场景下,对象都不是长期存活对象,在年龄很小的时候就被回收了,根本不会生存到最大晋升年限的年龄15。</p></blockquote><h4 id="调优目标Survivor空间占用"><a href="#调优目标Survivor空间占用" class="headerlink" title="调优目标Survivor空间占用"></a>调优目标Survivor空间占用</h4><p>目标Survivor空间占用是HotSpot VM尝试在Minor GC之后仍然维持的Survivor空间占用。通过 HotSpot VM的命令行选项-XX: TargetSurvivorRatio=&lt;percent&gt;可以对该值进行调整。通过命令行选项指定的参数实际上是Survivor空间占用的百分比而不是一个比率。它的默认值是50。</p><p>HotSpot VM研发团队对不同类型的应用程序进行了大量的负荷测试,结果表明50%的目标Survivor空间占用能适应大多数的应用程序,这是因为它能应对Minor GC时存活对象的急速增加。</p><p>极少发生需要对目标Survivor空间占用进行调优的情况。但是,如果应用程序有一个相对稳定的对象分配速率,可以考虑提高目标 Survivor空间占用到8090。这样可以减少用于老化对象的Survivor空间的数量。将-XX:TargetSurvivorRatio=&lt;percent&gt;设置得大于默认值会带来的冋题是不能很妤的适应迅速上涨的对象分配速率,导致提升对象的时机比预期更早。使用CMS时,如果对象提升过快会导致老年代占用增大,由于提升了一些非长期存活的对象,这些对象在将来的并发垃圾收集周期中一定会被回收,导致出现内存碎片的概率较高。碎片是我们要尽量避免的,因为它最终会导致Stop-The-World压缩式垃圾收集。</p><p><font color="DeepPink">成功的CMS收集器调优要能以对象从新生代提升到老年代的同等速度对老年代中的对象进行垃圾收集。达不到这个标准则称之为“失速”(Lost the Race)失速的结果就会发生Stop-The-World压缩式垃圾收集。避免失速的关键是要结合足够大的老年代空间和足够快地初始化CMS垃圾收集周期,让它以比提升速率更快的速度回收空间。</font></p><p><font color="DeepPink">CMS周期的初始化基于老年代空间的占用情况。如果CMS周期开始得太晚,就会发生失速。如果它无法以足够快的速度回收对象,就无法避免老年代空间用尽。但是CMS周期开始得过早又会引起无用的消耗,影响应用程序的吞吐量。通常,早启动CMS周期要比晚启动CMS好,因为启动太晚的结果比启动过早的结果要恶劣得多。</font></p><p>如果GC日志中发现concurrent mode failures字样,可以通过下面的命令行选项通知HotSpot在更早的时间启动CMS垃圾收集周期。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX: CMSInitiatingOccupancy Fraction=&lt;percent&gt;</span><br></pre></td></tr></table></figure><p>设定的值是CMS垃圾收集周期在老年代空间占用达到多少百分比时启动。例如,如果你希望CMS周期在老年代空间占用达到65%时开始,可以设置-XX:CMSInitiatingoccupancy Fraction=65。</p><p>另一个可以与-XX:CMSInitiatingOccupancyFraction=&lt;percent&gt;一起使用另一个Hotspot命令行选项是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseCMSInitiatingOccupancyOnly</span><br></pre></td></tr></table></figure><p>-XX:+UseCMSInitiatingOccupancyOnly 告知HotSpot VM总是使用-XX:CMSInitiatingOccupancyFraction设定的值作为启动CMS周期的老年代空间占用阈值。不使用-XX:+UseRs InitiatingOccupancyOnly, HotSpot VM仅在启动的第一个CMS周期里使用-XX:CMSInitiatingOccupancyFraction设定的值作为占用比率,之后的周期中又转向自适应地启动CMS周期,即第一次CMS周期之后就不再使用-XX:CMSInitiatingoccupancy Fraction设定的值。</p><blockquote><p>过选项设置何时启动CMS周期时,最好同时使用-XX:CMSInitiatingOccupancyFraction=&lt;percent&gt;和-XX:+UseCMSInitiatingOccupancyOnly</p></blockquote><p><font color="DeepPink">选项-XX:CMSInitiatingOccupancyFraction设定的空间占用值应该大于老年代占用空间和活跃数据大小之比。应用程序的活跃数据大小就是一次Full GC之后堆所占用的空间大小。如果使用-XX:CMSInitiatingOccupancyFraction设置的值小于活跃数据的占用百分比,CMS收集器一直运行陷入死循环。因此-XX:CMSInitiatingoccupancyFraction设置的一个通用原则是老年代占用百分比应该至少应该是活跃数据大小的1.5倍。</font></p><p><font color="DeepPink">何时(提前或推迟)启动CMS周期取决于对象从新生代提升至老年代的速率,即老年代空间的增长率。如果老年代空间消耗得比较慢,可以在稍晩的时候启动CMS周期。如果老年代空间消耗迅速,你应该在较早的时候启动CMS周期,但是也不应低于活跃数据的占用的比率。</font>不应该将启动CMS周期的值设置得比活跃数据的大小低,解决这个问题更好的方法是增大老年代空间的大小。</p><h3 id="显式的垃圾收集"><a href="#显式的垃圾收集" class="headerlink" title="显式的垃圾收集"></a>显式的垃圾收集</h3><p>使用CMS时,如果你观察到由显式调用System.gc()触发的Full GC,有2种处理的方法。</p><p>1、可以使用如下的 HotSpot VM命令行选项,指定 HotSpot VM以CMS垃圾收集周期的方式执行</p><p>-XX:+ExplicitGCInvokesConcurrent</p><p>或者</p><p>-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses</p><p>前者需要Java6及以上版本。后者需要Java6 Update4及以上版本。如果你的JK版本支持,最好使用-XX:+ExplicitGCInvokes ConcurrentAndUnloadsClasses选项。</p><p>2、也可以使用下面的命令行通知HotSpot VM忽略显式的 System.gc()调用</p><p>-XX: +DisableExplicitGC</p><p>要留意的是,使用这个命令行选项也会导致其他 HotSpot VM的垃圾收集器忽略显式的System.gc()调用。</p><p>禁用显式的垃圾收集时应该慎重,它可能会对应用程序的性能造成较大影响。还有可能出现这样的场景,你需要及时对对象引用做处理,但与之对应的垃圾收集却跟不上其节奏。使用Java RMI的应用程序尤其容易碰到这种问题。我们建议除非有非常明确的理由,否则不要轻易地禁用显式的垃圾收集。与此同时,也建议只在有明确理由的情况下才在应用程序中使用System.gc()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2010-12-16T23:04:39.452-0600:[Full GC(System)</span><br><span class="line">CMS:418061K-&gt;428608K(16384K),0.2539726 secs</span><br><span class="line">418749K-&gt;4288608K(31168K),</span><br><span class="line">[CMS Perm:32428K-&gt;32428K(65536K)],</span><br><span class="line">0.2540393 secs]</span><br><span class="line">[Times: user=0. 12 sys=0. 01, real=0. 25 secs]</span><br></pre></td></tr></table></figure><p>请留意Full GC之后的(System)标签,它表明System.gc()触发了本次 Full GC。如果在垃圾收集日志中发现了显式的Full GC,你需要先判断为什么它会发生,之后再决定是否要禁用,是否要把该调用从代码中移除,或者是否有必要指定一个条件来触发CMS并发垃圾收集周期。</p><h2 id="应用程序吞吐量调优"><a href="#应用程序吞吐量调优" class="headerlink" title="应用程序吞吐量调优"></a>应用程序吞吐量调优</h2><blockquote><p>一个通用原则是使用 Throughput收集器时,垃圾收集的开销应该小于5%。如果可以将垃圾收集的开销减少到1%甚至更少,那基本上就已经到了极限,进一步优化花费的代价很大。</p></blockquote><h3 id="调优并行垃圾收集线程"><a href="#调优并行垃圾收集线程" class="headerlink" title="调优并行垃圾收集线程"></a>调优并行垃圾收集线程</h3><p>并行垃圾收集器使用的线程数也应该依据系统上运行的应用程序数以及底层的硬件平台进行相应的调优。多个应用程序运行于同一个系统上时,建议通过命令行选项-XX:ParallelGCThreads=&lt;n&gt;将并行垃圾收集的线程数设置为小于其默认值。</p><p>否则,由于大量的垃圾收集线程同时运行,其他应用程序的性能将受到严重影响。截至Java6 Update23,默认情况下并行垃圾收集的线程数等于Java API Runtime.availableProcessors的返回值(如果该返回值小于等于8),否则其等于8+(Runtime.availableProcessors()-8)*5/8。<font color="DeepPink">多个应用程序运行于同一系统上时设置并行垃圾收集线程的一个通用原则是用虚拟处理器的数目 (Runtime.availableProcessors()的返回值)除以该系统上运行的应用程序数。</font>这里我们假设这些应用程序的负荷及堆大小的情况相差不大。如果应用程序的负荷及Java堆大小差异很大,那么为每个Java应用设置不同权重,并据此设置并行垃圾线程数是一个比较好的方法。</p><h3 id="在NUMA系统上部署"><a href="#在NUMA系统上部署" class="headerlink" title="在NUMA系统上部署"></a>在NUMA系统上部署</h3><p>如果应用程序需要在NUMA(非一致性内存架构)系统上部署,还有一个可以与Throughput收集器一起使用的HotSpot命令行选项是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseNUMA</span><br></pre></td></tr></table></figure><p>该命令行选项根据CPU与内存位置的关系在分配线程运行的本地内存中分配对象。这里依据的假设是分配对象的线程是近期最有可能访问该对象的线程。相对于远程的内存而言,在同一线程的本地内存中分配对象用更短的时间即能访问该对象的内容。</p><p>只有当JVM的部署跨CPU、不同CPU访问内存的拓扑有所不同,导致访问时间也有所差别的环境下才选择使用-XX:+UseNUMA选项。例如,虽然JVM部署到NUMA系统的一个处理器集上,但是这个处理器集并不存在跨CPU访问内存的拓扑,没有访问时间的差别,那么就不应该使用-XX:+UseNUMa选项。</p><blockquote><p>简而言之,攴持NUMA的VM会根据NUMA节点划分堆,线程创建新的对象时,只会在该线程运行所在核的NUMA节点上分配对象,后续该线程如果需要使用这个对象,就直接从本地内存中访问。通常情况下,如果没有使用命令,臂如RHE下使用Inumactl,设置CPU的亲和性( Affinity),默认就跨多个内存节点,满足-XX:+UseNUMA的使用条件。</p></blockquote><blockquote><p>注：Throughput garbage collector,实际指的是 Parallel收集器</p></blockquote><h2 id="其它性能命令行选项"><a href="#其它性能命令行选项" class="headerlink" title="其它性能命令行选项"></a>其它性能命令行选项</h2><h3 id="大页面支持"><a href="#大页面支持" class="headerlink" title="大页面支持"></a>大页面支持</h3><p>计算机系统的内存被划分成称为“页”的固定大小的块。程厅访问内存的过程中会将虚拟内存地址转换成物理内存地址。虚拟地址到物理地址的转换是通过表完成的。为了减少每次内存访问时访问页表的代价,通常的做法是使用一块快速缓存,对虚拟地址到物理地址的转换进行缓存。这块缓存被称为转译快查缓存(TLB)。</p><p>使用TLB完成从虚拟地址到物理地址的映射比遍历整个贝表的方式要快得多。TLB通常只能容纳固定数量的条目。TLB中的一条记录就是按页面大小统计的一块内存地址区间的映射。因此系统的页面越大,每个条目能映射的内存地址区间越大,每个TLB能管理的空间也越大。TLB代表的地址区间越大,地址转译请求在TLB中失效的可能性就越小。当一个地址转译请求无法在TLB中找到匹配项时,我们称之发生了“TLB失效”。TLB失效事件发生时常常需要遍历内存中的页表,査找虚拟地址到物理地址的映射。与在TLB中查找地址映射比较起来,遍历页表是一项非常昂贵的操作。由此可见,使用大页面的好处是其减小了TLB失效的几率。</p><p>HotSpot虚拟机在 Oracle solaris(这之后称为 Solaris)、 Linux和 Windows上都支持大页面。页面大小还可能随着处理器的不同有所不同。另外,为了使用大页面还可能需要对操作系统进行配置。</p><h1 id="Java-应用的基准测试"><a href="#Java-应用的基准测试" class="headerlink" title="Java 应用的基准测试"></a>Java 应用的基准测试</h1><h2 id="基准测试所面临的挑战"><a href="#基准测试所面临的挑战" class="headerlink" title="基准测试所面临的挑战"></a>基准测试所面临的挑战</h2><h3 id="基准测试的预热阶段"><a href="#基准测试的预热阶段" class="headerlink" title="基准测试的预热阶段"></a>基准测试的预热阶段</h3><p>执行基准测试时使用HotSpot VM命令行选项-XX:+PrintCompilation是一个好习惯,使用该命令行选项的输岀可以判断JT编译器何时完成了预热阶段,确保在 HotSpot编译器到达稳定态后,即已经完成它的优化工作(生成了适合基准测试的优化机器码)后再开始基准数据采样。-XX:+PrintCompilation选项通知VM为每个它优化或逆优化的函数输出一条日志。下面是在一段微基准测试中使用-XX:+PrintCompilation选项输出的日志片段:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">11java.util.Random:: nextInt (60 bytes)</span><br><span class="line">12java.util.Random: next (47 bytes</span><br><span class="line">13java.util.concurrent atomic Atomi CLong: get (5 bytes)</span><br><span class="line">14java.util.HashSet: contains (9 bytes)</span><br><span class="line">15java.util.HashMap: transfer (83 bytes)</span><br><span class="line">16java.util.Arrays SArrayList: set (16 bytes)</span><br><span class="line">17java.util.Arrays SArrayList: set (16 bytes)</span><br><span class="line">18java.util.Collections: swap (25 bytes)</span><br><span class="line">19java.util.Arrays SArrayList: get (7 bytes)</span><br><span class="line">20java.lang.Long: &lt;init&gt; (10 bytes)</span><br><span class="line">21java.lang.Integer: longvalue (6 bytes)</span><br><span class="line">22java.lang.Long: valueOf (36 bytes)</span><br><span class="line">23java.lang.Integer: stringSize (21 bytes)</span><br><span class="line">24java.lang.Integer: getChars (131 bytes)</span><br></pre></td></tr></table></figure><p><font color="DeepPink">观察日志中已经不再有-XX:+PrintCompilation输出的信息(表明JIT编译器的优化工作已经完成)之后才正式开始采样数据。此外,基准测试还应该在不使用-XX:+PrintCompilation选项的情况下运行几次,比较其性能与使用-XX:+ PrintCompilation选项的结果是否一致。如果二者不一致,可能在创建基准测试或微基准测试时受到了其他因素的影响。</font></p><blockquote><p>微基准测试中有一个惯例,即在开始采样间隔开始计时之前,先调用几次 System.gc()。多次调用 System.gc()的目的是希望通过Java对象的终结方法释放内存,而这往往需要进行多次垃圾收集才能完成。此外,当对象不可达,导致终结方法一直处于等待队列,或者部分执行队列中,调用System.runFinalization()接口可以请求JVM执行其fina1ize()方法,完成垃圾收集。</p></blockquote><h3 id="使用Java-Time接口"><a href="#使用Java-Time接口" class="headerlink" title="使用Java Time接口"></a>使用Java Time接口</h3><p>引入新的System.nanoTime()接口之前,大多数的Java基准测试或微基准测试都使用System.currentTimeMillis()接口获取采样间隔的开始和终止时间,根据终止时间与开始时间的间隔得到运行关注的代码所消耗的时间使用Java的System.currentTimeMillis()和System.nanoTime()接口都有一定程度的精度问题。虽然 System.currentTimeMillis()的返回值是以亳秒计的当前时间,但毫秒级的精度却取决于操作系统。Java API Specification中对于System.currentTimeMillis()有明确的陈述:虽然该接口的返回值是毫秒,但返回值的粒度取决于底层的操作系统。这一规范为操作系统使用自身的亳秒级系统接口提供了方便,但是可能存在这样的情况,尽管使用的是毫秒计数器,但是更新间隔却过大,譬如每30毫秒更新一次。这个规范有意地规定得比较宽松,试图让Java API尽可能地支持更多的操作系统,其中就包含一些无法提供毫秒级时钟精度的操作系统。使用Java API System. nanoTime()也有类似的问题。<font color="DeepPink">虽然该方法提供了纳秒级的精度,但接口并不保证提供纳秒级的精度: System.nanoTime()的 Java API Specification中明确提到不保证System.nanoTime()返回值的更新频度。</font></p><p>因此,使用System.currentTimeMillis()计算时间消耗时,采样的时间间隔应该足够大,尽量减少System, currentTimeMillis()精度带来的影响。也即是说,采样的时间间隔需要比毫秒大(譬如几秒、或者尽可能几分钟)同样的原则也适用于 System.nanoTime()。根据 jJava API Specification,System.nanoTime()依赖底层的操作系统,返回系统中可用的最精确时钟的当前值。然而,最精确的可用系统时钟可能也没有纳秒级的精度。进行基准测试时,建议首先摸清楚这两个Java API在对应平台或操作系统上的粒度或精度。如果你不是很清楚,但手里有源代码,可以通过查看这两个API的底层实现,了解其粒度和精度。如果你使用 System.currentTimeMillis(或System.nanoTime())。而且采样时间间隔很短(相对于毫秒或纳秒来讲),要特别注意这个问题。</p><blockquote><p>微基准测试时,使用System.nanoTime()获取启动和终止时间计算采样间隔是一种好方法。接着计算终止与启动的时间差就可以得到微基准测试的耗时,以及每次操作选代所消耗的纳秒数或者每秒所发生的迭代次数。最重要的是要确保微基准测试运行的时间要足够长,确保应用程序运行已达稳定态且采样的时间也足够长。</p></blockquote><h3 id="剔除无效代码"><a href="#剔除无效代码" class="headerlink" title="剔除无效代码"></a>剔除无效代码</h3><p>为了避免微基准测试中的代码被定性为无效代码,引发过度简化的问题,可以采用下面的编程实践：</p><ul><li><font color="DeepPink">让该方法变得必不可少</font></li><li><font color="DeepPink">在釆样阶段结束时直接输出计算的结果,或者保存该计算结果,在采样阶段结束后输出该值</font></li></ul><p>要使计算有意义,就要向被测方法传入参数,并从被测方法返回计算结果。此外,在基准测试采样阶段内或在多个不同的基准测试采样阶段间变换迭代次数也是一个不错的方法,然后比较每毫秒内发生的迭代次数,判断迭代次数是否保持恒定,同时使用-XX:+PrintCompilation选项追踪记录JT编译器的状态。</p><h3 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h3><p>HotSpot VM的Client和Server JIT编译器都能对方法进行内联。这意味着调用过程中,目标方法会被展开到调用方法中。这个过程是由J编译器完成的,J编译器通过降低方法调用的开销提升执行性能。此外,内联的代码可能提供更多的优化机会,整合后的代码可能更简单,或者消除了无效调用,而这些在不内联的情况下是无法实现的。内联在微基准测试中还可能实现让人眼前一亮的性能提升。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintInlining</span><br><span class="line">-XX:MaxInlineSize=N</span><br></pre></td></tr></table></figure><h3 id="逆优化"><a href="#逆优化" class="headerlink" title="逆优化"></a>逆优化</h3><p>JIT编译器以其执行优化的能力而著称于世。但是,某些场景下JIT编译器也会进行“逆优化”。譬如,Java应用一旦开始运行,方法调用变得频繁;JIT编译器就可以根据从程序过程中了解到的信息做出优化决策。有些时候,优化的决策在后续可能被证明是错误的。当JIT编译器发现之前的优化作了错误的优化决策时就会进行逆优化。很多时候,在JIT编译器逆优化不久之后(一旦达到一定的执行次数阈值)就会接着再次进行优化。忽视发生的逆优化可能得出错误的性能结论。</p><blockquote><p>使用-XX:+PrintCompilation选项可以帮助确定是否发生了逆优化。-XX:+Printcompilation选项的输出中如果包含“mad not entrant”,即表明之前的编译优化被丢弃了,方法将通过解释器运行,直到该方法执行足够的次数再触发优化。</p></blockquote><p><font color="DeepPink">软件开发者应该专注于优秀的软件架构、设计以及实现,没有必要过度担忧现代JT编译器的影响。如果对软件架构、设计或实现的修改是为了克服JT编译器的一些性质,就应该考虑这是JT编译器的缺陷或不足。</font></p><h3 id="创建微基准测试的注意事项"><a href="#创建微基准测试的注意事项" class="headerlink" title="创建微基准测试的注意事项"></a>创建微基准测试的注意事项</h3><ol><li>明确你需要了解的性能指标是什么,设计相应的实验冋答你需要解决的冋题。不要受些无关痛痒的因素影响而忽略了你真正需要解决的问题。</li><li>确保采样阶段中每次使用同样的工作量。</li><li>计算并收集多种性能指标,譬如消耗时间、单位时冋迭代次数或每次迭代的消耗时间用在预热阶段之后,采样阶段期间记录的性能指标。留意度量时间的精度和粒度,特别是使用了System.currentTimeMi1lis()和 System.nanoTime()况。多次运行试验,并变换采样的周期数或釆样的持续时间。之后再比较其所消耗的时间,密切注意单位时间迭代次数或每迭代消耗时间指标的变化。微基准测试经历了足够的预热、达到稳定态时,后一个指标几乎应该与釆样阶段持续时间的变化保持一致。</li><li>开始釆样之前确认微基准测试已经到达稳定态。可遵循的一条通用原则是,确保微基准测试至少运行10秒以上。使用 HotSpot的-XX:+PrintCompilation选项通过插入表示微基准测试执行阶段的工具可以帮助确认基准测试已经到达稳定态。这一步的日的是确保在开始采样之前,微基准测试经过充分预热,在采样阶段不会发生进一步的优化或逆优化事件。</li><li>多次运行基准测试以确保观测的结果是可重复的。多次运行可以为你最终的结论提供有力支持。</li><li>运行实验及观测结果时特别要留意得到的结果是否合理。如果碰到无法解释或可疑的结果,要花时间去研究、回顾实验的设计,确保观察的结果合理。</li><li>通过传递随时变化的参数到关注的方法中、返回关注方法的执行结果、在采样周期之外打印输出计算结果使计算更有意义,避免在微基准测试中创建无效代码。</li><li>留意内联可能对微基准测试产生的影响。如果对结果存疑,可以通过XX:+PrintInlining和-XX:+PrintCompilation命令行选项,利用HotSpot Debug VM观察HotSpot JIT编译器进行内联决策的过程。</li><li>确保执行微基准测试时其他的应用程序不会对系统造成影响。执行微基准测试时即使向桌面窗口管理器中添加很小或者很简单的应用程序(譬如天气应用或者股票行情记录软件),都会对系统性能造成影响。</li><li>当你需要很明确地了解JIT编译器生成了什么样的优化代码时,可以使用Oracle Solaris Studio Performance Analyzer或者HotSpot Debug VM(使用-XX:+PrintOptoAssembly选项)查看生成的汇编代码。</li><li>采用小数据集或数据结构的微基准测试受缓存的影响很大。微基准测试的结果可能每次执行都不一样,在不同的机器上运行结果也差别很大。</li><li>对于采用多线程的微基准测试需要意识到线程调度可能不是确定性的,特别是在负荷较重的情况下。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> GC </tag>
            
            <tag> JVM </tag>
            
            <tag> 读书笔记 </tag>
            
            <tag> Performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Epoll 的本质是什么？</title>
      <link href="/epoll-principle.html"/>
      <url>/epoll-principle.html</url>
      
        <content type="html"><![CDATA[<p>从事服务端开发，少不了要接触网络编程。epoll 作为 Linux 下高性能网络服务器的必备技术至关重要，nginx、Redis、Skynet 和大部分游戏服务器都使用到这一多路复用技术。</p><p>epoll 很重要，但是 epoll 与 select 的区别是什么呢？epoll 高效的原因是什么？</p><p><img alt data-src="/images/linux-epoll/%E9%A6%96%E9%A1%B5%E5%9B%BE.jpg"></p><p>网上虽然也有不少讲解 epoll的文章，但要么是过于浅显，或者陷入源码解析，很少能有通俗易懂的。笔者于是决定编写此文，让缺乏专业背景知识的读者也能够明白 epoll 的原理。</p><p><font color="DeepPink">文章核心思想是：要让读者清晰明白 epoll 为什么性能好。</font></p><p><font color="DeepPink">本文会从网卡接收数据的流程讲起，串联起 CPU 中断、操作系统进程调度等知识；再一步步分析阻塞接收数据、select 到 epoll 的进化过程；最后探究 epoll 的实现细节。</font></p><h1 id="一、从网卡接收数据说起"><a href="#一、从网卡接收数据说起" class="headerlink" title="一、从网卡接收数据说起"></a>一、从网卡接收数据说起</h1><p>下边是一个典型的计算机结构图，计算机由 CPU、存储器（内存）与网络接口等部件组成，了解 epoll 本质的第一步，要从硬件的角度看计算机怎样接收网络数据。<br><img alt data-src="/images/linux-epoll/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84%E5%9B%BE.jpg"><br><em>计算机结构图（图片来源：Linux内核完全注释之微型计算机组成结构）</em></p><p>下图展示了网卡接收数据的过程。</p><ul><li>在 ① 阶段，网卡收到网线传来的数据；</li><li>经过 ② 阶段的硬件电路的传输；</li><li>最终 ③ 阶段将数据写入到内存中的某个地址上。</li></ul><p>这个过程涉及到 DMA 传输、IO 通路选择等硬件有关的知识，但我们只需知道：<font color="DeepPink">网卡会把接收到的数据写入内存</font>。</p><p><img alt data-src="/images/linux-epoll/%E7%BD%91%E5%8D%A1%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%87%E7%A8%8B.jpg"><br><em>网卡接收数据的过程</em></p><p>通过硬件传输，网卡接收的数据存放到内存中，操作系统就可以去读取它们。</p><h1 id="二、如何知道接收了数据？"><a href="#二、如何知道接收了数据？" class="headerlink" title="二、如何知道接收了数据？"></a>二、如何知道接收了数据？</h1><p>了解 epoll 本质的第二步，要从 CPU 的角度来看数据接收。理解这个问题，要先了解一个概念——<font color="DeepPink">中断</font>。</p><p>计算机执行程序时，会有优先级的需求。比如，当计算机收到断电信号时，它应立即去保存数据，保存数据的程序具有较高的优先级（电容可以保存少许电量，供 CPU 运行很短的一小段时间）。</p><p><font color="DeepPink">一般而言，由硬件产生的信号需要 CPU 立马做出回应，不然数据可能就丢失了，所以它的优先级很高。CPU 理应中断掉正在执行的程序，去做出响应；当 CPU 完成对硬件的响应后，再重新执行用户程序。</font>中断的过程如下图，它和函数调用差不多，只不过函数调用是事先定好位置，而中断的位置由“信号”决定。<br><img alt data-src="/images/linux-epoll/%E4%B8%AD%E6%96%AD%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8.jpg"><br><em>中断程序调用</em></p><p>以键盘为例，当用户按下键盘某个按键时，键盘会给 CPU 的中断引脚发出一个高电平，CPU能够捕获这个信号，然后执行键盘中断程序。下图展示了各种硬件通过中断与 CPU 交互的过程。<br><img alt data-src="/images/linux-epoll/CPU%E4%B8%AD%E6%96%AD.jpg"><br><em>CPU 中断（图片来源：net.pku.edu.cn）</em></p><p>现在可以回答“<strong>如何知道接收了数据？</strong>”这个问题了：<font color="DeepPink">当网卡把数据写入到内存后，网卡向 CPU 发出一个中断信号，操作系统便能得知有新数据到来，再通过网卡中断程序去处理数据。</font></p><h1 id="三、进程阻塞为什么不占用-CPU-资源？"><a href="#三、进程阻塞为什么不占用-CPU-资源？" class="headerlink" title="三、进程阻塞为什么不占用 CPU 资源？"></a>三、进程阻塞为什么不占用 CPU 资源？</h1><p>了解 epoll 本质的第三步，要从操作系统进程调度的角度来看数据接收。<font color="DeepPink">阻塞是进程调度的关键一环，指的是进程在等待某事件（如接收到网络数据）发生之前的等待状态，recv、select 和 epoll 都是阻塞方法</font>。下边分析一下进程阻塞为什么不占用 CPU 资源？</p><p>为简单起见，我们从普通的 recv 接收开始分析，先看看下面代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//创建socket</span><br><span class="line">int s = socket(AF_INET, SOCK_STREAM, 0);   </span><br><span class="line">//绑定</span><br><span class="line">bind(s, ...)</span><br><span class="line">//监听</span><br><span class="line">listen(s, ...)</span><br><span class="line">//接受客户端连接</span><br><span class="line">int c = accept(s, ...)</span><br><span class="line">//接收客户端数据</span><br><span class="line">recv(c, ...);</span><br><span class="line">//将数据打印出来</span><br><span class="line">printf(...)</span><br></pre></td></tr></table></figure><p>这是一段最基础的网络编程代码，先新建 socket 对象，依次调用 bind、listen 与 accept，最后调用 recv 接收数据。recv 是个阻塞方法，当程序运行到 recv 时，它会一直等待，直到接收到数据才往下执行。</p><p>那么阻塞的原理是什么？</p><h2 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h2><p><font color="DeepPink">操作系统为了支持多任务，实现了进程调度的功能，会把进程分为“运行”和“等待”等几种状态。运行状态是进程获得 CPU 使用权，正在执行代码的状态；等待状态是阻塞状态，比如上述程序运行到 recv 时，程序会从运行状态变为等待状态，接收到数据后又变回运行状态。</font>操作系统会分时执行各个运行状态的进程，由于速度很快，看上去就像是同时执行多个任务。</p><p>下图的计算机中运行着 A、B 与 C 三个进程，其中进程 A 执行着上述基础网络程序，一开始，这 3 个进程都被操作系统的工作队列所引用，处于运行状态，会分时执行。<br><img alt data-src="/images/linux-epoll/%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E4%B8%AD%E6%9C%89ABC%E4%B8%89%E4%B8%AA%E8%BF%9B%E7%A8%8B.jpg"><br><em>工作队列中有 A、B 和 C 三个进程</em></p><h2 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h2><p>当进程 A 执行到创建 socket 的语句时，操作系统会创建一个由文件系统管理的 socket 对象（如下图）。这个 socket 对象包含了发送缓冲区、接收缓冲区与等待队列等成员。等待队列是个非常重要的结构，它指向所有需要等待该 socket 事件的进程。<br><img alt data-src="/images/linux-epoll/%E5%88%9B%E5%BB%BAsocket.jpg"><br><em>创建 socket</em></p><p><strong>当程序执行到 recv 时，操作系统会将进程 A 从工作队列移动到该 socket 的等待队列中</strong>（如下图）。由于工作队列只剩下了进程 B 和 C，依据进程调度，CPU 会轮流执行这两个进程的程序，不会执行进程 A 的程序。所以进程 A 被阻塞，不会往下执行代码，也不会占用 CPU 资源。<br><img alt data-src="/images/linux-epoll/socket%E7%9A%84%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97.jpg"><br><em>socket 的等待队列</em></p><blockquote><p>注：操作系统添加等待队列只是添加了对这个“等待中”进程的引用，以便在接收到数据时获取进程对象、将其唤醒，而非直接将进程管理纳入自己之下。上图为了方便说明，直接将进程挂到等待队列之下。</p></blockquote><h2 id="唤醒进程"><a href="#唤醒进程" class="headerlink" title="唤醒进程"></a>唤醒进程</h2><p><strong>当 socket 接收到数据后，操作系统将该 socket 队列上的进程重新放回到工作队列，该进程变成运行状态，继续执行代码。同时由于 socket 的接收缓冲区已经有了数据，recv 可以返回接收到的数据。</strong></p><h1 id="四、内核接收网络数据全过程"><a href="#四、内核接收网络数据全过程" class="headerlink" title="四、内核接收网络数据全过程"></a>四、内核接收网络数据全过程</h1><p>这一步，贯穿网卡、中断与进程调度的知识，叙述阻塞 recv 下，内核接收数据的全过程。</p><p>如下图所示，进程在 recv 阻塞期间，计算机收到了对端传送的数据（步骤①），数据经由网卡传送到内存（步骤②），然后网卡通过中断信号通知 CPU 有数据到达，CPU 执行中断程序（步骤③）。</p><p>此处的中断程序主要有两项功能，先将网络数据写入到对应 socket 的接收缓冲区里面（步骤④），再唤醒进程 A（步骤⑤），重新将进程 A 放入工作队列中。<br><img alt data-src="/images/linux-epoll/%E5%86%85%E6%A0%B8%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E5%85%A8%E8%BF%87%E7%A8%8B.jpg"><br><em>内核接收数据全过程</em></p><p>唤醒进程的过程如下图所示：<br><img alt data-src="/images/linux-epoll/%E5%94%A4%E9%86%92%E8%BF%9B%E7%A8%8B.jpg"><br><em>唤醒进程</em></p><p>以上是内核接收数据全过程，这里我们可能会思考两个问题：</p><ul><li>其一，<strong>操作系统如何知道网络数据对应于哪个 socket？</strong></li><li>其二，<strong>如何同时监视多个 socket 的数据？</strong></li></ul><p>第一个问题：<font color="DeepPink">因为一个 socket 对应着一个端口号，而网络数据包中包含了 ip 和端口的信息，内核可以通过端口号找到对应的 socket。当然，为了提高处理速度，操作系统会维护端口号到 socket 的索引结构，以快速读取。</font></p><p>第二个问题是多路复用的重中之重，也正是本文后半部分的重点。</p><h1 id="五、同时监视多个-socket-的简单方法"><a href="#五、同时监视多个-socket-的简单方法" class="headerlink" title="五、同时监视多个 socket 的简单方法"></a>五、同时监视多个 socket 的简单方法</h1><p>服务端需要管理多个客户端连接，而 recv 只能监视单个 socket，这种矛盾下，人们开始寻找监视多个 socket 的方法。<font color="DeepPink"> epoll 的要义就是高效地监视多个 socket</font>。</p><p>从历史发展角度看，必然先出现一种不太高效的方法，人们再加以改进，正如 select 之于 epoll。</p><p>先理解不太高效的 select，才能够更好地理解 epoll 的本质。</p><p>假如能够预先传入一个 socket 列表，如果列表中的 socket 都没有数据，挂起进程，直到有一个 socket 收到数据，唤醒进程。这种方法很直接，也是 select 的设计思想。</p><p>为方便理解，我们先复习 select 的用法。在下边的代码中，先准备一个数组 fds，让 fds 存放着所有需要监视的 socket。然后调用 select，如果 fds 中的所有 socket 都没有数据，select 会阻塞，直到有一个 socket 接收到数据，select 返回，唤醒进程。用户可以遍历 fds，通过 FD_ISSET 判断具体哪个 socket 收到数据，然后做出处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int s = socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">bind(s, ...);</span><br><span class="line">listen(s, ...);</span><br><span class="line">int fds[] =  存放需要监听的socket;</span><br><span class="line">while(1)&#123;</span><br><span class="line">    int n = select(..., fds, ...)</span><br><span class="line">    for(int i=0; i &lt; fds.count; i++)&#123;</span><br><span class="line">        if(FD_ISSET(fds[i], ...))&#123;</span><br><span class="line">            //fds[i]的数据处理</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="select-的流程"><a href="#select-的流程" class="headerlink" title="select 的流程"></a>select 的流程</h2><p>select 的实现思路很直接，假如程序同时监视如下图的 sock1、sock2 和 sock3 三个 socket，那么在调用 select 之后，操作系统把进程 A 分别加入这三个 socket 的等待队列中。<br><img alt data-src="/images/linux-epoll/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8A%8A%E8%BF%9B%E7%A8%8BA%E5%88%86%E5%88%AB%E5%8A%A0%E5%85%A5%E8%BF%99%E4%B8%89%E4%B8%AAsocket%E7%9A%84%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97%E4%B8%AD.jpg"><br><em>操作系统把进程 A 分别加入这三个 socket 的等待队列中</em></p><p>当任何一个 socket 收到数据后，中断程序将唤起进程。下图展示了 sock2 接收到了数据的处理流程：</p><blockquote><p>注：recv 和 select 的中断回调可以设置成不同的内容。</p></blockquote><p><img alt data-src="/images/linux-epoll/sock2%E6%8E%A5%E6%94%B6%E5%88%B0%E4%BA%86%E6%95%B0%E6%8D%AE%E4%B8%AD%E6%96%AD%E7%A8%8B%E5%BA%8F%E5%94%A4%E8%B5%B7%E8%BF%9B%E7%A8%8BA.jpg"><br><em>sock2 接收到了数据，中断程序唤起进程 A</em></p><p>所谓唤起进程，就是将进程从所有的等待队列中移除，加入到工作队列里面，如下图所示：<br><img alt data-src="/images/linux-epoll/%E5%B0%86%E8%BF%9B%E7%A8%8BA%E4%BB%8E%E6%89%80%E6%9C%89%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97%E4%B8%AD%E7%A7%BB%E9%99%A4%E5%86%8D%E5%8A%A0%E5%85%A5%E5%88%B0%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E9%87%8C%E9%9D%A2.jpg"><br><em>将进程 A 从所有等待队列中移除，再加入到工作队列里面</em></p><p>经由这些步骤，当进程 A 被唤醒后，它知道至少有一个 socket 接收了数据。程序只需遍历一遍 socket 列表，就可以得到就绪的 socket。</p><p>这种简单方式行之有效，在几乎所有操作系统都有对应的实现。</p><p>但是简单的方法往往有缺点，主要是：</p><p>其一，<strong>每次调用 select 都需要将进程加入到所有监视 socket 的等待队列，每次唤醒都需要从每个队列中移除。这里涉及了两次遍历，而且每次都要将整个 fds 列表传递给内核，有一定的开销。正是因为遍历操作开销大，出于效率的考量，才会规定 select 的最大监视数量，默认只能监视 1024 个 socket。</strong></p><p>其二，<strong>进程被唤醒后，程序并不知道哪些 socket 收到数据，还需要遍历一次。</strong></p><p>那么，<font color="DeepPink">有没有减少遍历的方法？有没有保存就绪 socket 的方法？这两个问题便是 epoll 技术要解决的。</font></p><blockquote><p>补充说明： 本节只解释了 select 的一种情形。当程序调用 select 时，内核会先遍历一遍 socket，如果有一个以上的 socket 接收缓冲区有数据，那么 select 直接返回，不会阻塞。这也是为什么 select 的返回值有可能大于 1 的原因之一。如果没有 socket 有数据，进程才会阻塞。</p></blockquote><h1 id="六、epoll-的设计思路"><a href="#六、epoll-的设计思路" class="headerlink" title="六、epoll 的设计思路"></a>六、epoll 的设计思路</h1><p>epoll 是在 select 出现 N 多年后才被发明的，是 select 和 poll（poll 和 select 基本一样，有少量改进）的增强版本。epoll 通过以下一些措施来改进效率：</p><h2 id="措施一：功能分离"><a href="#措施一：功能分离" class="headerlink" title="措施一：功能分离"></a>措施一：功能分离</h2><p>select 低效的原因之一是将“维护等待队列”和“阻塞进程”两个步骤合二为一。如下图所示，每次调用 select 都需要这两步操作，然而大多数应用场景中，需要监视的 socket 相对固定，并不需要每次都修改。epoll 将这两个操作分开，先用 epoll_ctl 维护等待队列，再调用 epoll_wait 阻塞进程。显而易见地，效率就能得到提升。<br><img alt data-src="/images/linux-epoll/%E7%9B%B8%E6%AF%94selectepoll%E6%8B%86%E5%88%86%E4%BA%86%E5%8A%9F%E8%83%BD.jpg"></p><p><em>相比 select，epoll 拆分了功能</em></p><p>为方便理解后续的内容，我们先了解一下 epoll 的用法。如下的代码中，先用 epoll_create 创建一个 epoll 对象 epfd，再通过 epoll_ctl 将需要监视的 socket 添加到 epfd 中，最后调用 epoll_wait 等待数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int s = socket(AF_INET, SOCK_STREAM, 0);   </span><br><span class="line">bind(s, ...)</span><br><span class="line">listen(s, ...)</span><br><span class="line"></span><br><span class="line">int epfd = epoll_create(...);</span><br><span class="line">epoll_ctl(epfd, ...); //将所有需要监听的socket添加到epfd中</span><br><span class="line"></span><br><span class="line">while(1)&#123;</span><br><span class="line">    int n = epoll_wait(...)</span><br><span class="line">    for(接收到数据的socket)&#123;</span><br><span class="line">        //处理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>功能分离，使得 epoll 有了优化的可能。</p><h2 id="措施二：就绪列表"><a href="#措施二：就绪列表" class="headerlink" title="措施二：就绪列表"></a>措施二：就绪列表</h2><p>select 低效的另一个原因在于程序不知道哪些 socket 收到数据，只能一个个遍历。如果内核维护一个“就绪列表”，引用收到数据的 socket，就能避免遍历。如下图所示，计算机共有三个 socket，收到数据的 sock2 和 sock3 被就绪列表 rdlist 所引用。当进程被唤醒后，只要获取 rdlist 的内容，就能够知道哪些 socket 收到数据。<br><img alt data-src="/images/linux-epoll/%E5%B0%B1%E7%BB%AA%E5%88%97%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg"><br><em>就绪列表示意图</em></p><h1 id="七、epoll-的原理与工作流程"><a href="#七、epoll-的原理与工作流程" class="headerlink" title="七、epoll 的原理与工作流程"></a>七、epoll 的原理与工作流程</h1><p>本节会以示例和图表来讲解 epoll 的原理和工作流程。</p><h2 id="创建-epoll-对象"><a href="#创建-epoll-对象" class="headerlink" title="创建 epoll 对象"></a>创建 epoll 对象</h2><p>如下图所示，当某个进程调用 epoll_create 方法时，内核会创建一个 eventpoll 对象（也就是程序中 epfd 所代表的对象）。eventpoll 对象也是文件系统中的一员，和 socket 一样，它也会有等待队列。<br><img alt data-src="/images/linux-epoll/%E5%86%85%E6%A0%B8%E5%88%9B%E5%BB%BAeventpoll%E5%AF%B9%E8%B1%A1.jpg"><br><em>内核创建 eventpoll 对象</em></p><p>创建一个代表该 epoll 的 eventpoll 对象是必须的，因为内核要维护“就绪列表”等数据，“就绪列表”可以作为 eventpoll 的成员。</p><h2 id="维护监视列表"><a href="#维护监视列表" class="headerlink" title="维护监视列表"></a>维护监视列表</h2><p>创建 epoll 对象后，可以用 epoll_ctl 添加或删除所要监听的 socket。以添加 socket 为例，如下图，如果通过 epoll_ctl 添加 sock1、sock2 和 sock3 的监视，内核会将 eventpoll 添加到这三个 socket 的等待队列中。<br><img alt data-src="/images/linux-epoll/%E6%B7%BB%E5%8A%A0%E6%89%80%E8%A6%81%E7%9B%91%E5%90%AC%E7%9A%84socket.jpg"><br><em>添加所要监听的 socket</em></p><p>当 socket 收到数据后，中断程序会操作 eventpoll 对象，而不是直接操作进程。</p><h2 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h2><p>当 socket 收到数据后，中断程序会给 eventpoll 的“就绪列表”添加 socket 引用。如下图展示的是 sock2 和 sock3 收到数据后，中断程序让 rdlist 引用这两个 socket。<br><img alt data-src="/images/linux-epoll/%E7%BB%99%E5%B0%B1%E7%BB%AA%E5%88%97%E8%A1%A8%E6%B7%BB%E5%8A%A0%E5%BC%95%E7%94%A8.jpg"><br><em>给就绪列表添加引用</em></p><p>eventpoll 对象相当于 socket 和进程之间的中介，socket 的数据接收并不直接影响进程，而是通过改变 eventpoll 的就绪列表来改变进程状态。</p><p>当程序执行到 epoll_wait 时，如果 rdlist 已经引用了 socket，那么 epoll_wait 直接返回，如果 rdlist 为空，阻塞进程。</p><h2 id="阻塞和唤醒进程"><a href="#阻塞和唤醒进程" class="headerlink" title="阻塞和唤醒进程"></a>阻塞和唤醒进程</h2><p>假设计算机中正在运行进程 A 和进程 B，在某时刻进程 A 运行到了 epoll_wait 语句。如下图所示，内核会将进程 A 放入 eventpoll 的等待队列中，阻塞进程。<br><img alt data-src="/images/linux-epoll/epoll_wait%E9%98%BB%E5%A1%9E%E8%BF%9B%E7%A8%8B.jpg"><br><em>epoll_wait 阻塞进程</em></p><p>当 socket 接收到数据，中断程序一方面修改 rdlist，另一方面唤醒 eventpoll 等待队列中的进程，进程 A 再次进入运行状态（如下图）。也因为 rdlist 的存在，进程 A 可以知道哪些 socket 发生了变化。<br><img alt data-src="/images/linux-epoll/epoll%E5%94%A4%E9%86%92%E8%BF%9B%E7%A8%8B.jpg"><br><em>epoll 唤醒进程</em></p><h1 id="八、epoll-的实现细节"><a href="#八、epoll-的实现细节" class="headerlink" title="八、epoll 的实现细节"></a>八、epoll 的实现细节</h1><p>至此，相信读者对 epoll 的本质已经有一定的了解。但我们还需要知道 eventpoll 的数据结构是什么样子？</p><p>此外，就绪队列应该应使用什么数据结构？eventpoll 应使用什么数据结构来管理通过 epoll_ctl 添加或删除的 socket？</p><p>如下图所示，eventpoll 包含了 lock、mtx、wq（等待队列）与 rdlist 等成员，其中 rdlist 和 rbr 是我们所关心的。<br><img alt data-src="/images/linux-epoll/epoll%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg"><br><em>epoll 原理示意图，图片来源：《深入理解Nginx：模块开发与架构解析(第二版)》，陶辉</em></p><h2 id="就绪列表的数据结构"><a href="#就绪列表的数据结构" class="headerlink" title="就绪列表的数据结构"></a>就绪列表的数据结构</h2><p>就绪列表引用着就绪的 socket，所以它应能够快速的插入数据。</p><p>程序可能随时调用 epoll_ctl 添加监视 socket，也可能随时删除。当删除时，若该 socket 已经存放在就绪列表中，它也应该被移除。所以就绪列表应是一种能够快速插入和删除的数据结构。</p><p>双向链表就是这样一种数据结构，epoll 使用双向链表来实现就绪队列（对应上图的 rdllist）。</p><h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><p>既然 epoll 将“维护监视队列”和“进程阻塞”分离，也意味着需要有个数据结构来保存监视的 socket，至少要方便地添加和移除，还要便于搜索，以避免重复添加。红黑树是一种自平衡二叉查找树，搜索、插入和删除时间复杂度都是O(log(N))，效率较好，epoll 使用了红黑树作为索引结构（对应上图的 rbr）。</p><p>注：因为操作系统要兼顾多种功能，以及由更多需要保存的数据，rdlist 并非直接引用 socket，而是通过 epitem 间接引用，红黑树的节点也是 epitem 对象。同样，文件系统也并非直接引用着 socket。为方便理解，本文中省略了一些间接结构。</p><h1 id="九、小结"><a href="#九、小结" class="headerlink" title="九、小结"></a>九、小结</h1><p>epoll 在 select 和 poll 的基础上引入了 eventpoll 作为中间层，使用了先进的数据结构，是一种高效的多路复用技术。这里也以表格形式简单对比一下 select、poll 与 epoll，结束此文。希望读者能有所收获。</p><p><img alt data-src="/images/linux-epoll/%E5%B0%8F%E7%BB%93.jpg"></p><p>原文地址：<a href="https://my.oschina.net/editorial-story/blog/3052308" target="_blank" rel="noopener">https://my.oschina.net/editorial-story/blog/3052308</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Epoll </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas 学习笔记</title>
      <link href="/arthas-learning-notes.html"/>
      <url>/arthas-learning-notes.html</url>
      
        <content type="html"><![CDATA[<p>阿里 Arthas 学习笔记</p><a id="more"></a><h1 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h1><p>查看当前线程信息，查看线程的堆栈。</p><p>参数说明：</p><table><thead><tr><th>参数名称</th><th>参数说明</th><th>示例</th></tr></thead><tbody><tr><td>id</td><td>线程id</td><td></td></tr><tr><td>[n:]</td><td>指定最忙的前N个线程并打印堆栈</td><td>thread -n 3</td></tr><tr><td>[b]</td><td>找出当前阻塞其他线程的线程</td><td>thread -b</td></tr><tr><td>[i <value>]</value></td><td>指定cpu占比统计的采样间隔，单位为毫秒</td><td></td></tr></tbody></table><blockquote><p>注意， 目前只支持找出synchronized关键字阻塞住的线程， 如果是java.util.concurrent.Lock， 目前还不支持。</p></blockquote><h1 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h1><p>查看当前JVM信息。</p><p>使用参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">$ jvm</span><br><span class="line"> RUNTIME                                                                                                                                                                                       </span><br><span class="line">-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> MACHINE-NAME                                           1@9db2689bb4d6                                                                                                                         </span><br><span class="line"> JVM-START-TIME                                         2019-07-16 18:18:06                                                                                                                    </span><br><span class="line"> MANAGEMENT-SPEC-VERSION                                2.0                                                                                                                                    </span><br><span class="line"> SPEC-NAME                                              Java Virtual Machine Specification                                                                                                     </span><br><span class="line"> SPEC-VENDOR                                            Oracle Corporation                                                                                                                     </span><br><span class="line"> SPEC-VERSION                                           12                                                                                                                                     </span><br><span class="line"> VM-NAME                                                OpenJDK 64-Bit Server VM                                                                                                               </span><br><span class="line"> VM-VENDOR                                              Oracle Corporation                                                                                                                     </span><br><span class="line"> VM-VERSION                                             12.0.1+12                                                                                                                              </span><br><span class="line"> INPUT-ARGUMENTS                                        -XX:G1PeriodicGCInterval=120000                                                                                                        </span><br><span class="line">                                                        -XX:G1PeriodicGCSystemLoadThreshold=0                                                                                                  </span><br><span class="line">                                                                                                                                                                                               </span><br><span class="line"> CLASS-PATH                                             application.jar                                                                                                                        </span><br><span class="line"> BOOT-CLASS-PATH                                                                                                                                                                               </span><br><span class="line"> LIBRARY-PATH                                           /usr/java/packages/lib:/usr/lib64:/lib64:/lib:/usr/lib                                                                                 </span><br><span class="line">                                                                                                                                                                                               </span><br><span class="line">-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> CLASS-LOADING                                                                                                                                                                                 </span><br><span class="line">-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> LOADED-CLASS-COUNT                                     11046                                                                                                                                  </span><br><span class="line"> TOTAL-LOADED-CLASS-COUNT                               11377                                                                                                                                  </span><br><span class="line"> UNLOADED-CLASS-COUNT                                   331                                                                                                                                    </span><br><span class="line"> IS-VERBOSE                                             false                                                                                                                                  </span><br><span class="line">                                                                                                                                                                                               </span><br><span class="line">-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> COMPILATION                                                                                                                                                                                   </span><br><span class="line">-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> NAME                                                   HotSpot 64-Bit Tiered Compilers                                                                                                        </span><br><span class="line"> TOTAL-COMPILE-TIME                                     74558(ms)                                                                                                                              </span><br><span class="line">                                                                                                                                                                                               </span><br><span class="line">-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> GARBAGE-COLLECTORS                                                                                                                                                                            </span><br><span class="line">-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> G1 Young Generation                                    12027/52593(ms)                                                                                                                        </span><br><span class="line"> [count/time]                                                                                                                                                                                  </span><br><span class="line"> G1 Old Generation                                      0/0(ms)                                                                                                                                </span><br><span class="line"> [count/time]                                                                                                                                                                                  </span><br><span class="line">                                                                                                                                                                                               </span><br><span class="line">-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> MEMORY-MANAGERS                                                                                                                                                                               </span><br><span class="line">-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> CodeCacheManager                                       CodeHeap &apos;non-nmethods&apos;                                                                                                                </span><br><span class="line">                                                        CodeHeap &apos;profiled nmethods&apos;                                                                                                           </span><br><span class="line">                                                        CodeHeap &apos;non-profiled nmethods&apos;                                                                                                       </span><br><span class="line">                                                                                                                                                                                               </span><br><span class="line"> Metaspace Manager                                      Metaspace                                                                                                                              </span><br><span class="line">                                                        Compressed Class Space                                                                                                                 </span><br><span class="line">                                                                                                                                                                                               </span><br><span class="line"> G1 Young Generation                                    G1 Eden Space                                                                                                                          </span><br><span class="line">                                                        G1 Survivor Space                                                                                                                      </span><br><span class="line">                                                        G1 Old Gen                                                                                                                             </span><br><span class="line">                                                                                                                                                                                               </span><br><span class="line"> G1 Old Generation                                      G1 Eden Space                                                                                                                          </span><br><span class="line">                                                        G1 Survivor Space                                                                                                                      </span><br><span class="line">                                                        G1 Old Gen                                                                                                                             </span><br><span class="line">                                                                                                                                                                                               </span><br><span class="line">                                                                                                                                                                                               </span><br><span class="line">-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> MEMORY                                                                                                                                                                                        </span><br><span class="line">-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> HEAP-MEMORY-USAGE                                      184549376(176.00 MiB)/2113929216(1.97 GiB)/32178700288(29.97 GiB)/60812520(58.00 MiB)                                                  </span><br><span class="line"> [committed/init/max/used]                                                                                                                                                                     </span><br><span class="line"> NO-HEAP-MEMORY-USAGE                                   115539968(110.19 MiB)/7667712(7.31 MiB)/-1(-1 B)/108227072(103.21 MiB)                                                                 </span><br><span class="line"> [committed/init/max/used]                                                                                                                                                                     </span><br><span class="line"> PENDING-FINALIZE-COUNT                                 0                                                                                                                                      </span><br><span class="line">                                                                                                                                                                                               </span><br><span class="line">-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> OPERATING-SYSTEM                                                                                                                                                                              </span><br><span class="line">-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> OS                                                     Linux                                                                                                                                  </span><br><span class="line"> ARCH                                                   amd64                                                                                                                                  </span><br><span class="line"> PROCESSORS-COUNT                                       32                                                                                                                                     </span><br><span class="line"> LOAD-AVERAGE                                           2.25                                                                                                                                   </span><br><span class="line"> VERSION                                                3.10.0-514.26.2.el7.x86_64                                                                                                             </span><br><span class="line">                                                                                                                                                                                               </span><br><span class="line">-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> THREAD                                                                                                                                                                                        </span><br><span class="line">-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> COUNT                                                  1060                                                                                                                                   </span><br><span class="line"> DAEMON-COUNT                                           25                                                                                                                                     </span><br><span class="line"> PEAK-COUNT                                             1062                                                                                                                                   </span><br><span class="line"> STARTED-COUNT                                          2463                                                                                                                                   </span><br><span class="line"> DEADLOCK-COUNT                                         0                                                                                                                                      </span><br><span class="line">                                                                                                                                                                                               </span><br><span class="line">-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> FILE-DESCRIPTOR                                                                                                                                                                               </span><br><span class="line">-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> MAX-FILE-DESCRIPTOR-COUNT                              -1                                                                                                                                     </span><br><span class="line"> OPEN-FILE-DESCRIPTOR-COUNT                             -1                                                                                                                                     </span><br><span class="line">Affect(row-cnt:0) cost in 14 ms.</span><br></pre></td></tr></table></figure><h1 id="sysprop"><a href="#sysprop" class="headerlink" title="sysprop"></a>sysprop</h1><p>查看当前JVM的系统属性(System Property)。</p><p>与jinfo 信息类似，不过sysprop提供修改单个属性值的功能。</p><p>查看单个属性，支持通过TAB键自动补全。</p><h1 id="sysenv"><a href="#sysenv" class="headerlink" title="sysenv"></a>sysenv</h1><p>查看当前JVM的环境属性(System Environment Variables)。</p><p>查看单个属性，支持通过TAB键自动补全。</p><h1 id="sc、sm、jad"><a href="#sc、sm、jad" class="headerlink" title="sc、sm、jad"></a>sc、sm、jad</h1><h2 id="sc"><a href="#sc" class="headerlink" title="sc"></a>sc</h2><p>查看JVM已加载的类信息,可以package前缀模糊匹配。</p><h2 id="sm"><a href="#sm" class="headerlink" title="sm"></a>sm</h2><p>查看已加载类的方法信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ monitor com.jiankunking.logsearch.services.LogSearchService queryStringByKeyWord</span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 90 ms.</span><br><span class="line"> timestamp            class                                                method                total  success  fail  avg-rt(ms)  fail-rate                                                   </span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------------------------                                                  </span><br><span class="line"> 2019-08-02 10:37:50  com.jiankunking.logsearch.services.LogSearchService  queryStringByKeyWord  61     61       0     96.68       0.00%                                                       </span><br><span class="line"></span><br><span class="line"> timestamp            class                                                method                total  success  fail  avg-rt(ms)  fail-rate                                                   </span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------------------------                                                  </span><br><span class="line"> 2019-08-02 10:38:50  com.jiankunking.logsearch.services.LogSearchService  queryStringByKeyWord  27     27       0     51.06       0.00%                                                       </span><br><span class="line"></span><br><span class="line"> timestamp            class                                                method                total  success  fail  avg-rt(ms)  fail-rate                                                   </span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------------------------                                                  </span><br><span class="line"> 2019-08-02 10:39:50  com.jiankunking.logsearch.services.LogSearchService  queryStringByKeyWord  0      0        0     0.00        0.00%</span><br></pre></td></tr></table></figure><h2 id="jad"><a href="#jad" class="headerlink" title="jad"></a>jad</h2><p>反编译指定已加载类的源码。</p><p>jad 命令将 JVM 中实际运行的 class 的 byte code 反编译成 java 代码，便于你理解业务逻辑；</p><ul><li>在 Arthas Console 上，反编译出来的源码是带语法高亮的，阅读更方便</li><li>当然，反编译出来的 java 代码可能会存在语法错误，但不影响你进行阅读理解</li></ul><blockquote><p>sc、sm、jad 三个命令可以结合使用。</p></blockquote><h1 id="classloader"><a href="#classloader" class="headerlink" title="classloader"></a>classloader</h1><p>查看classloader的继承树，urls，类加载信息。</p><p>classloader 命令将 JVM 中所有的classloader的信息统计出来，并可以展示继承树，urls等。</p><p>可以让指定的classloader去getResources，打印出所有查找到的resources的url。对于ResourceNotFoundException比较有用。</p><h1 id="mc、redefine"><a href="#mc、redefine" class="headerlink" title="mc、redefine"></a>mc、redefine</h1><h2 id="mc"><a href="#mc" class="headerlink" title="mc"></a>mc</h2><p>Memory Compiler/内存编译器，编译.java文件生成.class。</p><h2 id="redefine"><a href="#redefine" class="headerlink" title="redefine"></a>redefine</h2><p>加载外部的.class文件，redefine jvm已加载的类。</p><blockquote><p>mc、redefine 可以结合使用</p></blockquote><h1 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ monitor com.jiankunking.logsearch.services.LogSearchService queryStringByKeyWord</span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 90 ms.</span><br><span class="line"> timestamp            class                                                method                total  success  fail  avg-rt(ms)  fail-rate                                                   </span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------------------------                                                  </span><br><span class="line"> 2019-08-02 10:37:50  com.jiankunking.logsearch.services.LogSearchService  queryStringByKeyWord  61     61       0     96.68       0.00%                                                       </span><br><span class="line"></span><br><span class="line"> timestamp            class                                                method                total  success  fail  avg-rt(ms)  fail-rate                                                   </span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------------------------                                                  </span><br><span class="line"> 2019-08-02 10:38:50  com.jiankunking.logsearch.services.LogSearchService  queryStringByKeyWord  27     27       0     51.06       0.00%                                                       </span><br><span class="line"></span><br><span class="line"> timestamp            class                                                method                total  success  fail  avg-rt(ms)  fail-rate                                                   </span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------------------------                                                  </span><br><span class="line"> 2019-08-02 10:39:50  com.jiankunking.logsearch.services.LogSearchService  queryStringByKeyWord  0      0        0     0.00        0.00%</span><br></pre></td></tr></table></figure><h1 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h1><p>方法执行数据观测。</p><p>让你能方便的观察到指定方法的调用情况。能观察到的范围为：返回值、抛出异常、入参，通过编写OGNL 表达式进行对应变量的查看。</p><blockquote><p>这个有点强大啊</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">$ watch  com.jiankunking.logsearch.services.LogSearchService queryStringByKeyWord  &quot;&#123;params,target,returnObj&#125;&quot; -x 2 -b -s -n 2</span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 111 ms.</span><br><span class="line">ts=2019-08-02 10:48:48; [cost=0.006503ms] result=@ArrayList[</span><br><span class="line">    @Object[][</span><br><span class="line">        @String[monitor],</span><br><span class="line">        @String[console],</span><br><span class="line">        null,</span><br><span class="line">        @String[all],</span><br><span class="line">        @String[all],</span><br><span class="line">        null,</span><br><span class="line">        null,</span><br><span class="line">        @Integer[100],</span><br><span class="line">        @Long[1564713816522],</span><br><span class="line">        @Long[1564714116522],</span><br><span class="line">        null,</span><br><span class="line">        @[desc],</span><br><span class="line">    ],</span><br><span class="line">    @LogSearchService[</span><br><span class="line">        log=@Logger[Logger[com.jiankunking.logsearch.services.LogSearchService]],</span><br><span class="line">        esFilterService=@ESFilterService[com.jiankunking.logsearch.services.ESFilterService@58ebfd03],</span><br><span class="line">        indexPrefixService=@IndexPrefixService[com.jiankunking.logsearch.services.IndexPrefixService@19fb8826],</span><br><span class="line">        searchAfterSort=@String[][isEmpty=false;size=3],</span><br><span class="line">    ],</span><br><span class="line">    null,</span><br><span class="line">]</span><br><span class="line">ts=2019-08-02 10:48:48; [cost=91.878471ms] result=@ArrayList[</span><br><span class="line">    @Object[][</span><br><span class="line">        @String[monitor],</span><br><span class="line">        @String[console],</span><br><span class="line">        null,</span><br><span class="line">        @String[all],</span><br><span class="line">        @String[all],</span><br><span class="line">        null,</span><br><span class="line">        null,</span><br><span class="line">        @Integer[100],</span><br><span class="line">        @Long[1564713816522],</span><br><span class="line">        @Long[1564714116522],</span><br><span class="line">        null,</span><br><span class="line">        @[desc],</span><br><span class="line">    ],</span><br><span class="line">    @LogSearchService[</span><br><span class="line">        log=@Logger[Logger[com.jiankunking.logsearch.services.LogSearchService]],</span><br><span class="line">        esFilterService=@ESFilterService[com.jiankunking.logsearch.services.ESFilterService@58ebfd03],</span><br><span class="line">        indexPrefixService=@IndexPrefixService[com.jiankunking.logsearch.services.IndexPrefixService@19fb8826],</span><br><span class="line">        searchAfterSort=@String[][isEmpty=false;size=3],</span><br><span class="line">    ],</span><br><span class="line">    @SearchResult[</span><br><span class="line">        metadata=@MetaData[MetaData(total=21431)],</span><br><span class="line">        items=@ArrayList[isEmpty=false;size=100],</span><br><span class="line">    ],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h1><p>方法内部调用路径，并输出方法路径上的每个节点上耗时</p><p>trace 命令能主动搜索 class-pattern／method-pattern 对应的方法调用路径，渲染和统计整个调用链路上的所有性能开销和追踪调用链路。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">$ trace  com.jiankunking.logsearch.services.LogSearchService queryStringByKeyWord </span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 182 ms.</span><br><span class="line">`---ts=2019-08-02 10:53:36;thread_name=http-nio-8080-exec-8;id=42d;is_daemon=true;priority=5;TCCL=org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader@1095194</span><br><span class="line">    `---[416.520613ms] com.jiankunking.logsearch.services.LogSearchService:queryStringByKeyWord()</span><br><span class="line">        +---[0.019415ms] org.elasticsearch.search.builder.SearchSourceBuilder:&lt;init&gt;() #78</span><br><span class="line">        +---[0.011853ms] org.elasticsearch.index.query.QueryBuilders:boolQuery() #79</span><br><span class="line">        +---[0.02617ms] com.jiankunking.logsearch.services.ESFilterService:addProjectFilter() #80</span><br><span class="line">        +---[0.005593ms] com.jiankunking.logsearch.util.StringUtils:isEmpty() #81</span><br><span class="line">        +---[0.006519ms] java.lang.String:equals() #81</span><br><span class="line">        +---[0.002157ms] com.jiankunking.logsearch.util.StringUtils:isEmpty() #84</span><br><span class="line">        +---[0.002046ms] java.lang.String:equals() #84</span><br><span class="line">        +---[0.004284ms] com.jiankunking.logsearch.util.StringUtils:isNotEmpty() #87</span><br><span class="line">        +---[0.002342ms] com.jiankunking.logsearch.util.StringUtils:isNotEmpty() #90</span><br><span class="line">        +---[0.002066ms] com.jiankunking.logsearch.util.StringUtils:isNotEmpty() #98</span><br><span class="line">        +---[0.005008ms] org.elasticsearch.index.query.QueryBuilders:rangeQuery() #114</span><br><span class="line">        +---[0.005904ms] com.jiankunking.logsearch.util.TimeUtils:toDate() #115</span><br><span class="line">        +---[0.006666ms] org.elasticsearch.index.query.RangeQueryBuilder:gte() #115</span><br><span class="line">        +---[0.002128ms] com.jiankunking.logsearch.util.TimeUtils:toDate() #116</span><br><span class="line">        +---[0.004161ms] org.elasticsearch.index.query.RangeQueryBuilder:lte() #116</span><br><span class="line">        +---[0.347063ms] org.elasticsearch.index.query.BoolQueryBuilder:must() #117</span><br><span class="line">        +---[min=0.002196ms,max=0.030129ms,total=0.036436ms,count=3] org.elasticsearch.search.builder.SearchSourceBuilder:sort() #126</span><br><span class="line">        +---[0.005683ms] org.elasticsearch.search.builder.SearchSourceBuilder:fetchSource() #131</span><br><span class="line">        +---[0.003406ms] org.elasticsearch.search.builder.SearchSourceBuilder:size() #133</span><br><span class="line">        +---[0.003613ms] org.elasticsearch.search.builder.SearchSourceBuilder:query() #133</span><br><span class="line">        +---[0.321264ms] org.elasticsearch.search.builder.SearchSourceBuilder:toString() #134</span><br><span class="line">        +---[0.00689ms] org.springframework.http.HttpMethod:name() #136</span><br><span class="line">        +---[0.172438ms] com.jiankunking.logsearch.services.IndexPrefixService:getIndexPrefix() #136</span><br><span class="line">        +---[0.012968ms] com.jiankunking.logsearch.util.ESQueryUtils:getEndpoint() #136</span><br><span class="line">        +---[398.953869ms] com.jiankunking.logsearch.util.ESQueryUtils:performRequest() #136</span><br><span class="line">        +---[0.336319ms] com.alibaba.fastjson.JSON:parse() #138</span><br><span class="line">        +---[min=0.002461ms,max=0.013798ms,total=0.016259ms,count=2] java.util.Map:get() #140</span><br><span class="line">        +---[0.006434ms] java.lang.Integer:intValue() #140</span><br><span class="line">        +---[min=0.001908ms,max=0.002073ms,total=0.003981ms,count=2] java.util.Map:get() #141</span><br><span class="line">        +---[0.007532ms] com.jiankunking.logsearch.dto.SearchResult:&lt;init&gt;() #145</span><br><span class="line">        +---[0.004286ms] java.util.ArrayList:&lt;init&gt;() #146</span><br><span class="line">        +---[0.005725ms] com.alibaba.fastjson.JSONArray:iterator() #148</span><br><span class="line">        +---[min=8.07E-4ms,max=0.010324ms,total=0.124433ms,count=101] java.util.Iterator:hasNext() #148</span><br><span class="line">        +---[min=8.16E-4ms,max=0.009674ms,total=0.114893ms,count=100] java.util.Iterator:next() #148</span><br><span class="line">        +---[min=8.38E-4ms,max=0.013835ms,total=0.130734ms,count=100] com.alibaba.fastjson.JSONObject:get() #150</span><br><span class="line">        +---[min=8.69E-4ms,max=0.005654ms,total=0.112518ms,count=100] com.jiankunking.logsearch.util.MapUtils:getSize() #151</span><br><span class="line">        +---[min=7.84E-4ms,max=0.005522ms,total=0.106345ms,count=100] java.util.HashMap:&lt;init&gt;() #151</span><br><span class="line">        +---[min=8.4E-4ms,max=0.016457ms,total=0.12907ms,count=100] com.alibaba.fastjson.JSONArray:iterator() #152</span><br><span class="line">        +---[min=8.21E-4ms,max=0.002612ms,total=0.106495ms,count=100] java.util.Iterator:hasNext() #152</span><br><span class="line">        +---[min=8.07E-4ms,max=0.018355ms,total=0.143992ms,count=100] java.util.Iterator:next() #152</span><br><span class="line">        +---[min=8.72E-4ms,max=0.008687ms,total=0.132524ms,count=100] java.lang.String:valueOf() #153</span><br><span class="line">        +---[min=8.07E-4ms,max=0.008049ms,total=0.110329ms,count=100] java.lang.String:contains() #153</span><br><span class="line">        +---[min=8.46E-4ms,max=0.002612ms,total=0.109295ms,count=100] java.lang.String:valueOf() #156</span><br><span class="line">        +---[min=8.86E-4ms,max=0.041239ms,total=0.178986ms,count=100] java.util.HashMap:put() #156</span><br><span class="line">        +---[min=7.96E-4ms,max=0.008521ms,total=0.113489ms,count=100] com.alibaba.fastjson.JSONObject:get() #159</span><br><span class="line">        +---[min=8.2E-4ms,max=0.016801ms,total=0.125154ms,count=100] java.util.Map:get() #159</span><br><span class="line">        +---[min=8.39E-4ms,max=0.002089ms,total=0.106842ms,count=100] java.util.HashMap:put() #159</span><br><span class="line">        +---[min=7.86E-4ms,max=0.002836ms,total=0.104852ms,count=100] com.alibaba.fastjson.JSONObject:get() #160</span><br><span class="line">        +---[min=8.4E-4ms,max=0.003068ms,total=0.10763ms,count=100] java.util.HashMap:put() #160</span><br><span class="line">        +---[min=8.02E-4ms,max=0.020112ms,total=0.122423ms,count=100] com.alibaba.fastjson.JSONObject:get() #161</span><br><span class="line">        +---[min=8.22E-4ms,max=0.001939ms,total=0.104809ms,count=100] java.util.HashMap:put() #161</span><br><span class="line">        +---[min=7.99E-4ms,max=0.00186ms,total=0.10316ms,count=100] com.alibaba.fastjson.JSONObject:get() #162</span><br><span class="line">        +---[min=8.17E-4ms,max=0.012238ms,total=0.115955ms,count=100] java.util.Map:get() #162</span><br><span class="line">        +---[min=8.14E-4ms,max=0.018342ms,total=0.124331ms,count=100] java.util.HashMap:put() #162</span><br><span class="line">        +---[min=8.47E-4ms,max=0.003852ms,total=0.113692ms,count=100] com.alibaba.fastjson.JSONObject:containsKey() #164</span><br><span class="line">        +---[min=8.11E-4ms,max=0.017145ms,total=0.122375ms,count=100] com.alibaba.fastjson.JSONObject:containsKey() #167</span><br><span class="line">        +---[min=7.85E-4ms,max=0.002459ms,total=0.10233ms,count=100] com.alibaba.fastjson.JSONObject:get() #167</span><br><span class="line">        +---[min=8.57E-4ms,max=0.005959ms,total=0.11281ms,count=100] java.util.Map:containsKey() #167</span><br><span class="line">        +---[min=7.86E-4ms,max=0.016889ms,total=0.116022ms,count=100] com.alibaba.fastjson.JSONObject:get() #171</span><br><span class="line">        +---[min=8.27E-4ms,max=0.007969ms,total=0.121529ms,count=100] java.util.Map:get() #171</span><br><span class="line">        +---[min=8.24E-4ms,max=0.017969ms,total=0.126264ms,count=100] java.util.Map:containsKey() #171</span><br><span class="line">        +---[min=7.83E-4ms,max=0.001924ms,total=0.101244ms,count=100] com.alibaba.fastjson.JSONObject:get() #172</span><br><span class="line">        +---[min=7.92E-4ms,max=0.247702ms,total=0.502606ms,count=200] java.util.Map:get() #172</span><br><span class="line">        +---[min=8.61E-4ms,max=0.010095ms,total=0.124106ms,count=100] java.util.HashMap:put() #172</span><br><span class="line">        +---[min=7.84E-4ms,max=0.002789ms,total=0.100561ms,count=100] com.alibaba.fastjson.JSONObject:get() #174</span><br><span class="line">        +---[min=8.18E-4ms,max=0.003825ms,total=0.105746ms,count=100] java.util.Map:get() #174</span><br><span class="line">        +---[min=8.17E-4ms,max=0.003044ms,total=0.108946ms,count=100] java.util.Map:containsKey() #174</span><br><span class="line">        +---[min=7.83E-4ms,max=0.010689ms,total=0.10957ms,count=100] com.alibaba.fastjson.JSONObject:get() #175</span><br><span class="line">        +---[min=7.92E-4ms,max=0.018299ms,total=0.225606ms,count=200] java.util.Map:get() #175</span><br><span class="line">        +---[min=8.53E-4ms,max=0.002182ms,total=0.108485ms,count=100] java.util.HashMap:put() #175</span><br><span class="line">        +---[min=7.84E-4ms,max=0.005874ms,total=0.103371ms,count=100] com.alibaba.fastjson.JSONObject:get() #177</span><br><span class="line">        +---[min=8.02E-4ms,max=0.002017ms,total=0.101695ms,count=100] java.util.Map:get() #177</span><br><span class="line">        +---[min=8.26E-4ms,max=0.002735ms,total=0.106121ms,count=100] java.util.Map:containsKey() #177</span><br><span class="line">        +---[min=8.0E-4ms,max=0.017176ms,total=0.130393ms,count=100] com.alibaba.fastjson.JSONObject:get() #178</span><br><span class="line">        +---[min=8.03E-4ms,max=0.003318ms,total=0.204767ms,count=200] java.util.Map:get() #178</span><br><span class="line">        +---[min=8.55E-4ms,max=0.008081ms,total=0.115006ms,count=100] java.util.HashMap:put() #178</span><br><span class="line">        +---[min=9.11E-4ms,max=0.014017ms,total=0.136197ms,count=100] java.util.List:add() #180</span><br><span class="line">        +---[0.005288ms] com.jiankunking.logsearch.dto.SearchResult:setItems() #182</span><br><span class="line">        `---[0.002643ms] com.jiankunking.logsearch.dto.SearchResult:setTotal() #183</span><br></pre></td></tr></table></figure><h1 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h1><p>输出当前方法被调用的调用路径。</p><p>很多时候我们都知道一个方法被执行，但这个方法被执行的路径非常多，或者你根本就不知道这个方法是从那里被执行了，此时你需要的是 stack 命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">$ stack  com.jiankunking.logsearch.services.LogSearchService queryStringByKeyWord </span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 173 ms.</span><br><span class="line">ts=2019-08-02 10:55:44;thread_name=http-nio-8080-exec-1;id=426;is_daemon=true;priority=5;TCCL=org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader@1095194</span><br><span class="line">    @com.jiankunking.logsearch.controller.LogSearchController.searchByKeyWord()</span><br><span class="line">        at com.jiankunking.logsearch.controller.LogSearchController$$FastClassBySpringCGLIB$$61775844.invoke(&lt;generated&gt;:-1)</span><br><span class="line">        at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204)</span><br><span class="line">        at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:746)</span><br><span class="line">        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)</span><br><span class="line">        at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:88)</span><br><span class="line">        at com.jiankunking.logsearch.aspect.ControllerTimeConsumeAspect.doAround(ControllerTimeConsumeAspect.java:34)</span><br><span class="line">        at jdk.internal.reflect.GeneratedMethodAccessor91.invoke(null:-1)</span><br><span class="line">        at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Method.java:567)</span><br><span class="line">        at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:644)</span><br><span class="line">        at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:633)</span><br><span class="line">        at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:70)</span><br><span class="line">        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:174)</span><br><span class="line">        at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92)</span><br><span class="line">        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:185)</span><br><span class="line">        at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688)</span><br><span class="line">        at com.jiankunking.logsearch.controller.LogSearchController$$EnhancerBySpringCGLIB$$2f145034.searchByKeyWord(&lt;generated&gt;:-1)</span><br><span class="line">        at jdk.internal.reflect.GeneratedMethodAccessor97.invoke(null:-1)</span><br><span class="line">        at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Method.java:567)</span><br><span class="line">        at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:209)</span><br><span class="line">        at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:136)</span><br><span class="line">        at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:102)</span><br><span class="line">        at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:891)</span><br><span class="line">        at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)</span><br><span class="line">        at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)</span><br><span class="line">        at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:991)</span><br><span class="line">        at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:925)</span><br><span class="line">        at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:974)</span><br><span class="line">        at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:866)</span><br><span class="line">        at javax.servlet.http.HttpServlet.service(HttpServlet.java:635)</span><br><span class="line">        at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:851)</span><br><span class="line">        at javax.servlet.http.HttpServlet.service(HttpServlet.java:742)</span><br><span class="line">        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)</span><br><span class="line">        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">        at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)</span><br><span class="line">        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)</span><br><span class="line">        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">        at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99)</span><br><span class="line">        at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)</span><br><span class="line">        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)</span><br><span class="line">        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">        at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:109)</span><br><span class="line">        at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)</span><br><span class="line">        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)</span><br><span class="line">        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">        at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93)</span><br><span class="line">        at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)</span><br><span class="line">        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)</span><br><span class="line">        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">        at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200)</span><br><span class="line">        at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)</span><br><span class="line">        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)</span><br><span class="line">        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">        at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:198)</span><br><span class="line">        at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)</span><br><span class="line">        at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:493)</span><br><span class="line">        at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140)</span><br><span class="line">        at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81)</span><br><span class="line">        at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87)</span><br><span class="line">        at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)</span><br><span class="line">        at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:800)</span><br><span class="line">        at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)</span><br><span class="line">        at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:806)</span><br><span class="line">        at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1498)</span><br><span class="line">        at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)</span><br><span class="line">        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:835)</span><br></pre></td></tr></table></figure><h1 id="tt"><a href="#tt" class="headerlink" title="tt"></a>tt</h1><p>方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测。</p><h1 id="options"><a href="#options" class="headerlink" title="options"></a>options</h1><p>全局开关</p><table><thead><tr><th>名称</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>unsafe</td><td>false</td><td>是否支持对系统级别的类进行增强，打开该开关可能导致把JVM搞挂，请慎重选择！</td></tr><tr><td>dump</td><td>false</td><td>是否支持被增强了的类dump到外部文件中，如果打开开关，class文件会被dump到/${application dir}/arthas-class-dump/目录下，具体位置详见控制台输出</td></tr><tr><td>batch-re-transform</td><td>true</td><td>是否支持批量对匹配到的类执行retransform操作</td></tr><tr><td>json-format</td><td>false</td><td>是否支持json化的输出</td></tr><tr><td>disable-sub-class</td><td>false</td><td>是否禁用子类匹配，默认在匹配目标类的时候会默认匹配到其子类，如果想精确匹配，可以关闭此开关</td></tr><tr><td>debug-for-asm</td><td>false</td><td>打印ASM相关的调试信息</td></tr><tr><td>save-result</td><td>false</td><td>是否打开执行结果存日志功能，打开之后所有命令的运行结果都将保存到/home/admin/logs/arthas/arthas.log中</td></tr><tr><td>job-timeout</td><td>id</td><td>异步后台任务的默认超时时间，超过这个时间，任务自动停止；比如设置 1d, 2h, 3m, 25s，分别代表天、小时、分、秒</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Arthas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员常用词汇</title>
      <link href="/coder-vocabulary.html"/>
      <url>/coder-vocabulary.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>下面是工作中，经常用到的一些词汇，持续更新</p></blockquote><a id="more"></a><p>1, abbreviation  [əbriːvɪ’eɪʃ(ə)n]<br>n. 缩写；缩写词<br>2, abruptly<br>adv. 突然地；唐突地<br>3, absence  [‘æbsns]<br>n. 没有；缺乏；缺席；不注意<br>4, absent  [ˈæbsnt;(for v.)əbˈsɛnt]<br>adj. 缺席的；缺少的；心不在焉的；茫然的<br>vt. 使缺席<br>5, absorber  [əb’sɔːbə]<br>n. 减震器；吸收器；吸收体<br>6, accessible  [ək’sesɪb(ə)l]<br>adj. 易接近的；可进入的；可理解的<br>7, accidental  [æksɪ’dent(ə)l]<br>adj. 意外的；偶然的；附属的；临时记号的;<br>n. 次要方面；非主要的特性；临时记号<br>8, accomplished  [ə’kʌmplɪʃt; ə’kɒm-]<br>adj. 完成的；熟练的，有技巧的；有修养的；有学问的<br>9, accumulate  [ə’kjumjəlet]<br>vi. 累积；积聚<br>vt. 积攒<br>10, accumulation  [ə,kjʊmjə’leʃən]<br>n. 积聚，累积；堆积物<br>11, accuracy  [‘ækjʊrəsɪ]<br>n. [数] 精确度，准确性<br>12, actually  [‘æktjʊəlɪ; -tʃʊ-]<br>adv. 实际上；事实上<br>13, Actually  [‘æktjʊəlɪ; -tʃʊ-]<br>adv. 实际上；事实上<br>14, actuator  [‘æktʃʊ,etɚ]<br>n. [自] 执行机构；激励者；促动器<br>15, Adaptee<br>被适配者<br>16, additionally  [ə’dɪʃənəlɪ]<br>adv. 此外；又，加之<br>17, Additivity  [,ædɪ’tɪvətɪ]<br>n. 添加；相加性<br>18, addon  [addon]<br>n. 插件<br>19, adequate  [ˈædɪkwət]<br>adj. 充足的；适当的；胜任的<br>20, adjacent  [ə’dʒesnt]<br>adj. 邻近的，毗连的<br>21, adopt  [ə’dɒpt]<br>vt. 采取；接受；收养；正式通过;<br>vi. 采取；过继<br>22, Advice  [əd’vaɪs]<br>n. 建议；忠告；劝告；通知<br>23, advisable  [əd’vaɪzəb(ə)l]<br>adj. 明智的，可取的，适当的<br>24, advisor  [əd’vaɪzə]<br>n. 顾问；指导教师；劝告者<br>25, affinity  [ə’fɪnəti]<br>n. 密切关系；吸引力；姻亲关系；类同<br>26, affliction  [ə’flɪkʃ(ə)n]<br>n. 苦难；苦恼；折磨<br>27, afford  [ə’fɔrd]<br>vt. 给予，提供；买得起<br>n. (Afford)人名；(英)阿福德<br>28, agenda  [ə’dʒɛndə]<br>n. 议程；日常工作事项<br>29, aggregation  [,ægrɪ’geʃən]<br>n. [地质][数] 聚合，聚集；聚集体，集合体<br>30, agnostic  [æg’nɒstɪk]<br>n. 不可知论者;<br>adj. 不可知论的<br>31, aligned  [ə’laɪn]<br>adj. 对齐的；均衡的<br>v. 结盟（align的过去式）；使成一直线<br>32, Alliance  [ə’laɪəns]<br>n. 联盟，联合；联姻<br>33, allocation  [,ælə’keʃən]<br>n. 分配，配置；安置<br>34, allowable  [ə’laʊəbl]<br>adj. 许可的；正当的；可承认的；可获宽免<br>35, along with<br>沿（顺）着；连同…一起；与…一道；随同…一起<br>36, alternative  [ɔːl’tɜːnətɪv; ɒl-]<br>adj. 供选择的；选择性的；交替的;<br>n. 二中择一；供替代的选择<br>37, ambassador  [æm’bæsədɚ]<br>n. 大使；代表；使节<br>38, ameliorate  [ə’milɪə’ret]<br>vt. 改善；减轻（痛苦等）；改良<br>vi. 变得更好<br>39, amend  [ə’mend]<br>vt. 修改；改善，改进<br>vi. 改正，改善；改过自新<br>n. (Amend)人名；(德、英)阿门德<br>40, amended<br>adj. 修正的<br>v. 修订；改进（amend的过去分词）<br>41, amid  [美/ə’mɪd/]<br>prep. 在其中，在其间;<br>n. (Amid)人名；(法、阿拉伯)阿米德;<br>42, among  [ə’mʌŋ]<br>prep. 在…中间；在…之中<br>43, analogous  [ə’næləgəs]<br>adj. 类似的；[昆] 同功的；可比拟的<br>44, analysts  [‘æn(ə)lɪsts]<br>n. 分析师；分析家；[分化] 分析员（analyst的复数）<br>45, Analyzer  [‘ænəlaɪzə]<br>n. [计] 分析器；分析者；检偏镜<br>46, anatomy  [ə’nætəmi]<br>n. 解剖；解剖学；剖析；骨骼<br>47, ancestor  [‘ænsɛstɚ]<br>n. 始祖，祖先；被继承人<br>48, animate  [‘ænɪmeɪt]<br>vt. 使有生气；使活泼；鼓舞；推动;<br>adj. 有生命的<br>49, animation  [,ænɪ’meʃən]<br>n. 活泼，生气；激励；卡通片绘制<br>50, Annotation  [ænə’teɪʃ(ə)n]<br>n. 注释；注解；释文<br>51, annotations  []<br>释文<br>52, announce  [ə’naʊns]<br>vt. 宣布；述说；预示；播报<br>vi. 宣布参加竞选；当播音员<br>53, anomalies<br>n. 异常现象，反常现象（anomaly 复数形式）<br>54, approach  [ə’protʃ]<br>n. 方法；途径；接近<br>vt. 接近；着手处理<br>vi. 靠近<br>55, appropriate  [ə’prəʊprɪət]<br>adj. 适当的；恰当的；合适的;<br>vt. 占用，拨出<br>56, approve  [ə’pruːv]<br>vt. 批准；赞成；为…提供证据;<br>vi. 批准；赞成；满意<br>57, approximately  [ə’prɒksɪmətlɪ]<br>adv. 大约，近似地；近于<br>58, approximation  [ə,prɒksɪ’meɪʃn]<br>n. [数] 近似法；接近；[数] 近似值<br>59, approximations  [approximations]<br>[数] 近似值<br>60, apsara<br>n. (Apsara)人名；(法)阿普萨拉<br>61, arbitrarily  [,ɑrbə’trɛrəli]<br>adv. 武断地；反复无常地；专横地<br>62, arbitrary  [‘ɑːbɪt(rə)rɪ]<br>adj. [数] 任意的；武断的；专制的<br>63, arbitrate  [‘ɑːbɪtreɪt]<br>vt. 仲裁；公断<br>64, archetype  [‘ɑːkɪtaɪp]<br>n. 原型<br>65, architectural  [,ɑːkɪ’tektʃərəl]<br>adj. 建筑学的；建筑上的；符合建筑法的<br>66, archive  [‘ɑrkaɪv]<br>n. 档案馆；档案文件;<br>vt. 把…存档<br>67, Archive  [‘ɑrkaɪv]<br>n. 档案馆；档案文件;<br>vt. 把…存档<br>68, arguably  [‘ɑrɡjuəbli]<br>adv. 可论证地；可争辩地；正如可提出证据加以证明的那样地<br>[广义用法]可能，大概<br>69, ark  [ɑrk]<br>n. 约柜；方舟；（美）平底船；避难所<br>n. (Ark)人名；(俄、土)阿尔克<br>70, artifact  [‘ɑ:təˌfækt]<br>n. 人工制品；手工艺品<br>71, artifacts  [‘a:rtifækts]<br>n. 史前古器物；人工产品<br>72, Artifacts  [‘a:rtifækts]<br>n. 史前古器物；人工产品<br>73, Artificial  [ɑːtɪ’fɪʃ(ə)l]<br>adj. 人造的；仿造的；虚伪的；非原产地的；武断的<br>74, Aspect  [‘æspekt]<br>n. 方面；方向；形势；外貌<br>75, assailed  [ə’seɪl]<br>vt. 攻击；质问；着手解决<br>76, asset  [‘æset]<br>n. 资产；优点；有用的东西；有利条件；财产；有价值的人或物</p><p>n. （法）阿塞（人名）<br>77, Assets  []<br>n. 资产；[经] 财产；有利条件（asset的复数）<br>78, asshole  [‘æshəʊl]<br>n. 屁眼儿，肛门；令人讨厌的人<br>adj. 愚蠢的；窝囊的；可恶的<br>79, assign  [ə’saɪn]<br>vt. 分配；指派；[计][数] 赋值;<br>vi. 将财产过户（尤指过户给债权人）<br>80, assignee  [æsɪ’niː; -saɪ-]<br>n. 代理人；受托人；分配到任务的人<br>81, association  [əsəʊsɪ’eɪʃ(ə)n; -ʃɪ-]<br>n. 协会，联盟，社团；联合；联想<br>82, assume  [ə’sjuːm]<br>vt. 承担；假定；采取；呈现;<br>vi. 装腔作势；多管闲事<br>83, asterisk  [‘æstərɪsk]<br>n. 星号<br>vt. 注上星号；用星号标出<br>84, async  [əˈsɪŋk]<br>abbr. 异步，非同步（asynchronous）<br>85, asynchronous  [ə’sɪŋkrənəs; eɪ-]<br>adj. [电] 异步的；不同时的；不同期的<br>86, Asynchronous  [ə’sɪŋkrənəs; eɪ-]<br>adj. [电] 异步的；不同时的；不同期的<br>87, atlassian  </p><p>88, atop  [ə’tɒp]<br>prep. 在…的顶上;<br>adv. 在顶上<br>89, attach  [ə’tætʃ]<br>vt. 使依附；贴上；系上；使依恋;<br>vi. 附加；附属；伴随<br>90, attendance  [ə’tend(ə)ns]<br>n. 出席；到场；出席人数；考勤<br>91, attendees<br>n. 参加者；出席者（attendee的复数）<br>92, atypical  [eɪ’tɪpɪk(ə)l; æ-]<br>adj. 非典型的；不合规则的<br>93, audit  [‘ɔːdɪt]<br>vi. 审计；[审计] 查账;<br>n. 审计；[审计] 查账;<br>vt. （美）旁听<br>94, authentication  [ɔː,θentɪ’keɪʃən]<br>n. 证明；鉴定；证实<br>95, Authentication  [ɔː,θentɪ’keɪʃən]<br>n. 证明；鉴定；证实<br>96, authorization  [ɔːθəraɪ’zeɪʃ(ə)n]<br>n. 授权，认可；批准，委任<br>97, Authorization  [ɔːθəraɪ’zeɪʃ(ə)n]<br>n. 授权，认可；批准，委任<br>98, authorize  [‘ɔθəraɪz]<br>vt. 批准，认可；授权给；委托代替<br>99, automata  [ɔ’tɑmətə]<br>n. 自动装置；机器人 （automaton的复数）<br>100, Automation  [ɔːtə’meɪʃ(ə)n]<br>n. 自动化；自动操作<br>101, autowire<br>n. 自动装配<br>102, auxiliary  [ɔːg’zɪlɪərɪ; ɒg-]<br>n. 助动词；辅助者，辅助物；附属机构;<br>adj. 辅助的；副的；附加的<br>103, avail  [ə’veɪl]<br>n. 效用，利益;<br>vt. 有益于，有益于；使对某人有利。;<br>vi. 有益于，有益于；使对某人有利。<br>104, await  [ə’weɪt]<br>vt. 等候，等待；期待<br>105, Aware  [ə’weə]<br>adj. 意识到的；知道的；有…方面知识的；懂世故的;<br>n. (Aware)人名；(阿拉伯、索)阿瓦雷<br>106, awesome  [‘ɔːs(ə)m]<br>【网络】另人竟为的；生畏；真了不起；傲森<br>107, Awesome  [‘ɔːs(ə)m]<br>adj. 令人敬畏的；使人畏惧的；可怕的；极好的<br>108, axis  [‘æksɪs]<br>n. 轴；轴线；轴心国<br>109, backslash  [backslash]<br>n. 反斜杠，反斜线符号<br>110, backwards  [‘bækwɚdz]<br>adv. 倒；向后；逆<br>111, Badge  [bædʒ]<br>n. 徽章；证章；标记;<br>vt. 授给…徽章<br>112, banner  [‘bænɚ]<br>n. 横幅图片的广告模式<br>n. 旗帜，横幅,标语<br>n. 人名(英、德、罗)班纳<br>113, barge  [bɑrdʒ]<br>vi. 蹒跚；闯入<br>n. 驳船；游艇<br>vt. 用船运输；蛮不讲理地闯入或打扰某事物<br>n. (Barge)人名；(英)巴奇；(德)巴格；(西)巴尔赫；(法、葡)巴尔热<br>114, Barter  [‘bɑːtə]<br>vi. 进行易货贸易；[贸易] 作物物交换；讨价还价;<br>vt. 以…作为交换；拿…进行易货贸易;<br>n. 易货贸易；物物交换；实物交易;<br>n. (Barter)人名；(英)巴特<br>115, Bash  [bæʃ]<br>vt. 猛击，痛击；怒殴;<br>n. 猛烈的一击，痛击;<br>n. (Bash)人名；(英、俄、巴基)巴什<br>116, be populated with<br>用…填充<br>117, be responsible for  []<br>对……负责；是……的原因<br>Be responsible for: 负责  对  承担责任<br>118, bear  [bɛr]<br>vt. 结果实，开花（正式）<br>vt. 忍受；承受；具有；支撑<br>n. 熊<br>n. (Bear)人名；(英)贝尔<br>119, bearer  [‘bɛrɚ]<br>n. 持票人；[建] 承木；[机] 托架；送信人；搬运工人<br>120, beast  [biːst]<br>n. 野兽；畜生，人面兽心的人<br>121, behalf  [bɪ’hɑːf]<br>n. 代表；利益<br>122, benchmarks  [benchmarks]<br>n. [计] 基准；标竿；水准点；基准测试程序数值（benchmark的复数形式）<br>v. 测定基准点（benchmark的三单形式）<br>123, bend  [bend]<br>vt. 使弯曲；使屈服；使致力；使朝向;<br>vi. 弯曲，转弯；屈服；倾向；专心于;<br>n. 弯曲;<br>n. (Bend)人名；(瑞典)本德<br>124, beware  [bɪ’wɛr]<br>vi. 当心，小心<br>vt. 注意，当心；提防<br>125, bin  [bɪn]<br>n. 箱子，容器；二进制;<br>vt. 把…放入箱中;<br>n. (Bin)人名；(意、柬)宾；(日)敏(名)；(东南亚国家华语)民<br>126, Binary  [‘baɪnərɪ]<br>adj. [数] 二进制的；二元的，二态的<br>127, Binary Distributions<br>二进制发行版<br>128, bio  [‘baɪəʊ]<br>n. 个人简历，小传</p><p>n. (Bio)人名；(法、意、葡、土、刚(金)、塞拉)比奥<br>129, bitwise<br>n. 按位<br>130, biz  [bɪz]<br>n. 商业（等于business）<br>131, blazing  [‘bleɪzɪŋ]<br>adj. 燃烧的；强烈的；闪耀的;<br>adv. 非常;<br>v. 燃烧；闪耀；迸发；公开（blaze的ing形式）<br>132, block  [blɒk]<br>n. 块；街区；大厦；障碍物;<br>vt. 阻止；阻塞；限制；封盖;<br>adj. 成批的，大块的；交通堵塞的;<br>n. (Block)人名；(英、法、德、西、葡、芬、罗)布洛克<br>133, Block  [blɒk]<br>n. 块；街区；大厦；障碍物;<br>vt. 阻止；阻塞；限制;<br>adj. 成批的，大块的；交通堵塞的;<br>n. (Block)人名；(英、法、德、西、葡、芬、罗)布洛克<br>134, blueprint  [‘blʊ’prɪnt]<br>vt. 计划；制成蓝图<br>n. 蓝图，设计图；计划<br>135, blur  [blɜː]<br>vt. 涂污；使…模糊不清；使暗淡；玷污;<br>vi. 沾上污迹；变模糊;<br>n. 污迹；模糊不清的事物<br>136, board  [bɔrd]<br>n. 董事会；木板；甲板；膳食<br>vt. 上（飞机、车、船等）；用板盖上；给提供膳宿<br>vi. 寄宿<br>n. (Board)人名；(英、西)博德<br>137, boilerplate  [‘bɔɪlɚplet]<br>n. 样板文件；引用<br>138, boils<br>n. 生疖，疮（boil复数）<br>139, bold  [bold]<br>adj. 大胆的，英勇的；黑体的；厚颜无耻的；险峻的<br>n. (Bold)人名；(英、德、罗、捷、瑞典)博尔德<br>140, bolt  [bəʊlt]<br>n. 螺栓，螺钉；闪电，雷电；门闩；弩箭;（布的）一匹，一卷<br>vt. 筛选；囫囵吞下；（把门、窗等）闩上；突然说出，脱口说出<br>vi. （门窗等）闩上，拴住；冲出，跳出；（马等的）脱缰；囫囵吞下<br>adv. 突然地；像箭似地；直立地<br>141, boost  [buːst]<br>vt. 促进；增加；支援;<br>vi. 宣扬；偷窃;<br>n. 推动；帮助；宣扬;<br>n. (Boost)人名；(英)布斯特；(德)博斯特<br>142, boot  [buːt]<br>vt. 引导；踢；解雇；使穿靴;<br>n. 靴子；踢；汽车行李箱;<br>n. (Boot)人名；(英)布特；(德)博特<br>143, bootstrap  [‘buːtstræp]<br>n. [计] 引导程序，辅助程序；解靴带<br>144, Bootstrap  [‘buːtstræp]<br>n. [计] 引导程序，辅助程序；解靴带<br>145, BootStrap  [‘buːtstræp]<br>n. [计] 引导程序，辅助程序；解靴带<br>146, bootup<br>n. 启动<br>147, borrow  [‘bɒrəʊ]<br>vi. 借；借用；从其他语言中引入</p><p>vt. 借；借用</p><p>n. (Borrow)人名；(英)博罗<br>148, bottleneck  [‘bɑtlnɛk]<br>n. 瓶颈；障碍物<br>149, bound  [baʊnd]<br>adj. 有义务的；受约束的；装有封面的;<br>vt. 束缚；使跳跃;<br>n. 范围；跳跃;<br>vi. 限制；弹起<br>150, bourne  [buən]<br>n. 小溪；目的地；边界<br>n. (Bourne)人名；(英)伯恩；(西)博尔内<br>151, Bourne  [buən]<br>n. 小溪；目的地；边界;<br>n. (Bourne)人名；(英)伯恩；(西)博尔内<br>152, breakthrough  [‘breɪkθruː]<br>n. 突破；突破性进展<br>153, brevity  [‘brɛvəti]<br>n. 简洁，简短；短暂，短促<br>154, brew  [brʊ]<br>vt. 酿造；酝酿<br>vi. 酿酒；被冲泡；即将发生<br>n. 啤酒；质地<br>n. (Brew)人名；(英)布鲁<br>155, brief  [brif]<br>adj. 简短的，简洁的；短暂的，草率的<br>n. 摘要，简报；概要，诉书<br>vt. 简报，摘要；作…的提要<br>n. (Brief)人名；(英)布里夫<br>156, brilliant  [‘brɪlj(ə)nt]<br>adj. 灿烂的，闪耀的；杰出的；有才气的；精彩的，绝妙的<br>157, brittle  [‘brɪt(ə)l]<br>adj. 易碎的，脆弱的；易生气的<br>158, broker  [‘brokɚ]<br>n. 经纪人，掮客<br>vi. 作为权力经纪人进行谈判<br>vt. 以中间人等身分安排…<br>n. (Broker)人名；(英)布罗克；(俄)布罗克尔<br>159, bucket  [‘bʌkɪt]<br>n. 桶，水桶；铲斗；一桶的量<br>v. 倾盆而下；颠簸着行进<br>n. (Bucket)人名；(德)布克特<br>160, buddy  [‘bʌdɪ]<br>n. 伙伴，好朋友；密友；小男孩;<br>vi. 做好朋友，交朋友;<br>n. (Buddy)人名；(英)巴迪<br>161, budget  [‘bʌdʒɪt]<br>n. 预算，预算费<br>vt. 安排，预定；把…编入预算<br>vi. 编预算，做预算<br>adj. 廉价的<br>162, bulk  [bʌlk]<br>n. 体积，容量；大多数，大部分；大块<br>vt. 使扩大，使形成大量；使显得重要<br>n. (Bulk)人名；(土)布尔克<br>163, bunch  [bʌn(t)ʃ]<br>n. 群；串；突出物</p><p>vi. 隆起；打褶；形成一串</p><p>vt. 使成一串；使打褶</p><p>n. (Bunch)人名；(英)邦奇<br>164, bundle  [‘bʌnd(ə)l]<br>n. 束；捆;<br>vt. 捆;<br>vi. 匆忙离开<br>165, Bundle  [‘bʌnd(ə)l]<br>n. 束；捆;<br>vt. 捆;<br>vi. 匆忙离开<br>166, burst  [bɜːst]<br>vi. 爆发，突发；爆炸</p><p>vt. 爆发，突发；爆炸</p><p>n. 爆发，突发；爆炸</p><p>n. (Burst)人名；(德、罗)布尔斯特<br>167, byzantine  [baɪˈzntaɪn;ˈbɪzəntaɪn]<br>adj. 拜占庭式的；东罗马帝国的<br>n. 拜占庭人，拜占庭派的建筑师<br>168, Callable  [‘kɔːləb(ə)l]<br>adj. 随时可偿还的；请求即付的<br>169, Campaign  [kæm’peɪn]<br>vi. 作战；参加竞选；参加活动<br>n. 运动；活动；战役<br>170, canary  [kə’nɛri]<br>n. [鸟] 金丝雀；淡黄色<br>n. (Canary)人名；(英)卡纳里<br>171, candidate  [‘kændɪdeɪt; -dət]<br>n. 候选人，候补者；应试者<br>172, canonical  [kə’nɒnɪk(ə)l]<br>adj. 依教规的；权威的；牧师的<br>n. 牧师礼服<br>173, Canonical  [kə’nɒnɪk(ə)l]<br>adj. 依教规的；权威的；牧师的;<br>n. 牧师礼服<br>174, Canvas  [‘kænvəs]<br>n. 帆布;<br>vt. 用帆布覆盖，用帆布装备;<br>adj. 帆布制的<br>175, Capable  [‘keɪpəb(ə)l]<br>adj. 能干的，能胜任的；有才华的<br>176, capitalized  [capitalized]<br>大写的<br>177, capped  [capped]<br>v. 给…戴帽；去蒂；覆以…；除去盖子；胜过（cap的过去分词形式）<br>adj. 包过的；加盖的；去蒂的<br>178, cardinality  [kɑːdɪ’nælɪtɪ]<br>n. 基数；集的势<br>179, caret  [‘kærət]<br>n. 脱字符号；插入符号;<br>n. (Caret)人名；(法)卡雷；(英)卡雷特<br>180, Caret  [‘kærət]<br>n. 脱字符号；插入符号;<br>n. (Caret)人名；(法)卡雷；(英)卡雷特<br>181, carrot  [‘kærət]<br>n. 胡萝卜;<br>诱饵<br>182, cascading  [kæ’skeɪdɪŋ]<br>n. [电] 级联；串接；阶式渗透</p><p>v. 瀑布般落下；串联；传递信息（cascade的ing形式）<br>183, catalina  [,kætə’li:nə]<br>n. 远程轰炸机;<br>n. (Catalina)人名；(法、西)卡塔利娜；(英)卡塔莉娜<br>184, cave  [keɪv]<br>vt. 使凹陷，使塌落；在…挖洞穴<br>vi. 凹陷，塌落；投降<br>n. 洞穴，窑洞<br>n. (Cave)人名；(西)卡韦；(英)凯夫；(法)卡夫<br>185, caveat  [‘kævɪæt; ‘ke-]<br>n. 警告；中止诉讼手续的申请；货物出门概不退换；停止支付的广告<br>186, caveats<br>n. 警告；说明（caveat的复数）<br>187, cellular  [‘sɛljəlɚ]<br>adj. 细胞的；多孔的；由细胞组成的<br>n. 移动电话；单元<br>188, Celsius  [‘sɛlsɪəs]<br>adj. 摄氏的<br>n. 摄氏度<br>189, characteristic  [kærəktə’rɪstɪk]<br>adj. 典型的；特有的；表示特性的<br>n. 特征；特性；特色<br>190, Characteristics  [,kærəktə’rɪstɪks]<br>n. 特性，特征；特色（characteristic的复数）；特质<br>191, charcuterie  [ʃɑː’kuːt(ə)rɪ]<br>n. 熟食店；猪肉店;<br>n. (Charcuterie)人名；(法)沙尔屈特里<br>192, chase  [tʃeɪs]<br>vt. 追逐；追捕；试图赢得；雕镂;<br>vi. 追逐；追赶；奔跑;<br>n. 追逐；追赶；追击;<br>n. (Chase)人名；(英)蔡斯；(法)沙斯<br>193, chaser  [‘tʃeɪsə]<br>n. 驱逐舰；猎人；饮烈酒后喝的饮料；[机] 螺纹梳刀<br>194, chefs  [ʃefs]<br>n.大厨；主厨（chef的复数）<br>195, Choreographies Processes<br>组合流程<br>196, choreography  [,kɒrɪ’ɒgrəfɪ]<br>n. 编舞；舞蹈艺术；舞艺<br>197, chronicle  [‘krɒnɪk(ə)l]<br>n.编年史，年代记；记录<br>vt.记录；把…载入编年史<br>198, chronology  [krə’nɒlədʒɪ]<br>n. 年表；年代学<br>Chronology: 年代学  年代学  年表<br>199, chubby  [‘tʃʌbi]<br>adj. 圆胖的，丰满的<br>200, chunk  [tʃʌŋk]<br>n.大块；矮胖的人或物<br>201, churn  [tʃɜːn]<br>vi.搅拌；搅动<br>vt.搅拌；搅动<br>n.搅乳器<br>202, cipher  [‘saɪfə]<br>n. 密码；暗号；零</p><p>vi. 使用密码；计算；做算术</p><p>vt. 计算；做算术；将…译成密码<br>203, circuit  [‘sɝkɪt]<br>n. [电子] 电路，回路；巡回；一圈；环道 vi. 环行 vt. 绕回…环行<br>204, circumstance  [ˈsɝ​kəmˌstəns]<br>n. 环境，情况；事件；境遇<br>205, citrus  [‘sɪtrəs]<br>n. [园艺] 柑橘属果树；柑橘类的植物;<br>adj. 柑橘属植物的<br>206, claim  [kleɪm]<br>vi. 提出要求;<br>vt. 要求；声称；需要；认领;<br>n. 要求；声称；索赔；断言；值得<br>207, clamp  [klæmp]<br>vt. 夹紧，固定住<br>n. 夹钳，螺丝钳<br>208, clarity  [‘klærɪtɪ]<br>n. 清楚，明晰；透明;<br>n. (Clarity)人名；(英)克拉里蒂<br>209, Clip  [klɪp]<br>vt. 修剪；夹牢；痛打;<br>vi. 修剪;<br>n. 修剪；夹子；回形针<br>210, clove  [kləʊv]<br>n. [植][中医] 丁香<br>v. 劈开（cleave的过去式）<br>211, clue  [klʊ]<br>n. 线索；（故事等的）情节<br>vt. 为…提供线索；为…提供情况<br>212, cluster  [‘klʌstə]<br>n. 群；簇；丛；串<br>vi. 群聚；丛生<br>vt. 使聚集；聚集在某人的周围<br>n. (Cluster)人名；(英)克拉斯特<br>213, co-branding  [kəu’brændiŋ]<br>n. 联合品牌；合作品牌<br>214, coalesced<br>合并（coalesce的过去式和过去分词）<br>215, coarse  [kɔrs]<br>adj. 粗糙的；粗俗的；下等的<br>216, coerce  [kəʊ’ɜːs]<br>vt. 强制，迫使<br>217, coexist  [,kəʊɪg’zɪst]<br>vi. 共存；和平共处<br>218, cognitive  [‘kɒɡnɪtɪv]<br>adj. 认知的，认识的<br>219, coherency  [coherency]<br>n. 附着；凝聚；联接；相参性<br>220, coherent  [kə(ʊ)’hɪər(ə)nt]<br>adj. 连贯的，一致的；明了的；清晰的；凝聚性的；互相耦合的；粘在一起的<br>221, cohesive  [kəʊ’hiːsɪv]<br>adj. 有结合力的；紧密结合的；有粘着力的<br>222, collaboration  [kəlæbə’reɪʃn]<br>n. 合作；勾结；通敌<br>223, collapsar  [kə’læpsɑː]<br>n. 黑洞（等于black hole）<br>224, collapse  [kə’læps]<br>vi.倒塌；瓦解；暴跌<br>vt.使倒塌，使崩溃；使萎陷；折叠<br>n.倒塌；失败；衰竭<br>225, collide  [kə’laɪd]<br>vi. 碰撞；抵触，冲突;<br>vt. 使碰撞；使相撞<br>226, collision  [kə’lɪʒ(ə)n]<br>n. 碰撞；冲突；（意见，看法）的抵触；（政党等的）倾轧<br>227, collisions  [collisions]<br>n. [物] 碰撞；冲突；撞击（collision的复数形式）<br>228, colloquially  [kə’ləukwiəli]<br>adv. 口语地；用通俗语<br>229, colly<br>vt. （英）把…弄黑<br>n. 锅灰；煤灰<br>n. (Colly)人名；(英、法)科利<br>230, colon  [‘kolən]<br>n. [解剖] 结肠；冒号（用于引语、说明、例证等之前）；科郎（哥斯达黎加货币单位）<br>231, comma  [‘kɑmə]<br>n. 逗号；停顿<br>232, Commerce  [‘kɒmɜːs]<br>n. 贸易，商业<br>233, commercial  [kə’mɜːʃ(ə)l]<br>adj. 商业的；营利的；靠广告收入的;<br>n. 商业广告<br>234, communicating  [kə’mjʊnə,ketɪŋ]<br>adj. 交流的；通信的<br>v. 交流；传播（communicate的现在分词）；传递<br>235, comparison  [kəm’pærɪs(ə)n]<br>n. 比较；对照；比喻；比较关系<br>236, compatible  [kəm’pætɪb(ə)l]<br>adj. 兼容的；能共处的；可并立的<br>237, compensate  [‘kɒmpenseɪt]<br>vi. 补偿，赔偿；抵消;<br>vt. 补偿，赔偿；付报酬<br>238, Compensation  [kɒmpen’seɪʃ(ə)n]<br>n. 补偿；报酬；赔偿金<br>239, comply  [kəm’plaɪ]<br>vi. 遵守；顺从，遵从；答应<br>240, compound  [‘kɒmpaʊnd]<br>n. [化学] 化合物；混合物；复合词</p><p>adj. 复合的；混合的</p><p>v. 合成；混合；恶化，加重；和解，妥协<br>241, comprehensive  [kɒmprɪ’hensɪv]<br>adj. 综合的；广泛的；有理解力的;<br>n. 综合学校；专业综合测验<br>242, Comprehensive  [kɒmprɪ’hensɪv]<br>adj. 综合的；广泛的；有理解力的;<br>n. 综合学校；专业综合测验<br>243, compulsive  [kəm’pʌlsɪv]<br>adj. 强制的；强迫的<br>244, computation  [kɒmpjʊ’teɪʃ(ə)n]<br>n. 估计，计算<br>245, concatenate  [kɑn’kætə,net]<br>vt. 连结；使连锁<br>adj. 连结的；连锁的<br>246, conclusions  [kən’klʊʒənz]<br>n. 结论，总结；决定（conclusion的复数）<br>247, concrete  [‘kɒŋkriːt]<br>adj. 混凝土的；实在的，具体的；有形的;<br>vi. 凝结;<br>vt. 使凝固；用混凝土修筑;<br>n. 具体物；凝结物<br>248, Concrete  [‘kɒŋkriːt]<br>adj. 混凝土的；实在的，具体的；有形的;<br>vi. 凝结;<br>vt. 使凝固；用混凝土修筑;<br>n. 具体物；凝结物<br>249, condense  [kən’dens]<br>vi. 浓缩；凝结;<br>vt. 使浓缩；使压缩<br>250, confidentiality  [,kɑnfɪ,dɛnʃɪ’æləti]<br>n. 机密，[计] 机密性<br>251, confinement  [kən’faɪnmənt]<br>n. 限制；监禁；分娩<br>252, confluence  [‘kɑnfluəns]<br>n. （河流的）汇合、汇流点；（人或物的）聚集<br>253, conjunction  [kən’dʒʌŋkʃən]<br>n. 结合；[语] 连接词；同时发生<br>254, consecutive  [kən’sekjʊtɪv]<br>adj. 连贯的；连续不断的<br>255, conservative  [kən’sɝvətɪv]<br>adj. 保守的<br>n. 保守派，守旧者<br>256, consistent  [kən’sɪstənt]<br>adj. 始终如一的，一致的；坚持的<br>257, constant  [‘kɒnst(ə)nt]<br>adj. 不变的；恒定的；经常的;<br>n. [数] 常数；恒量;<br>n. (Constant)人名；(德)康斯坦特<br>258, Constant  [‘kɒnst(ə)nt]<br>adj. 不变的；恒定的；经常的;<br>n. [数] 常数；恒量;<br>n. (Constant)人名；(德)康斯坦特<br>259, consult  [kən’sʌlt]<br>vt. 查阅；商量；向…请教;<br>vi. 请教；商议；当顾问<br>260, consumption  [kən’sʌm(p)ʃ(ə)n]<br>n. 消费；消耗；肺痨<br>261, contend  [kən’tɛnd]<br>vi. 竞争；奋斗；斗争；争论<br>vt. 主张；为…斗争<br>262, contention  [kən’tɛnʃən]<br>n. 争论，争辩；争夺；论点<br>263, contiguous  [kən’tɪgjʊəs]<br>adj. 连续的；邻近的；接触的<br>264, continual  [kən’tɪnjʊəl]<br>adj. 持续不断的；频繁的<br>265, continuations  [continuations]<br>n. 延续部分；（书籍的）附录；（文学作品的）续集（continuation的复数）<br>266, convenient  [kən’viːnɪənt]<br>adj. 方便的；[废语]适当的；[口语]近便的；实用的<br>267, Convenient  [kən’viːnɪənt]<br>adj. 方便的;<br>方便;<br>近便的;<br>近便地<br>268, convention  [kən’venʃ(ə)n]<br>n. 大会；[法] 惯例；[计] 约定；[法] 协定；习俗<br>269, conversely  [‘kɑnvɝsli]<br>adv. 相反地<br>270, conveys  [conveys]<br>运输<br>表达<br>271, coordinate  [kəʊ’ɔ:dɪneɪt]<br>n. 坐标；同等的人或物;<br>adj. 并列的；同等的;<br>vt. 调整；整合;<br>vi. 协调<br>272, coordinator  [ko’ɔrdn,etɚ]<br>n. 协调者；[自] 协调器；同等的人或物<br>273, cordon  [‘kɔrdn]<br>n. 警戒线；绶带；束带层<br>vt. 用警戒线围住；包围隔离<br>n. (Cordon)人名；(英、西)科登；(法、葡)科尔东<br>274, cornerstone  [‘kɔːnəstəʊn]<br>n. 基础；柱石；地基<br>275, coroutine  [,kəuru:’ti:n]<br>n. 协同程序<br>276, correspond  [kɒrɪ’spɒnd]<br>vi. 符合，一致；相应；通信<br>277, correspondingly  [,kɔrə’spɑndɪŋli]<br>adv. 相应地，相对地<br>278, Cotton  [‘kɒt(ə)n]<br>n. 棉花；棉布；棉线<br>vi. 一致；理解；和谐；亲近<br>adj. 棉的；棉制的<br>n. (Cotton)人名；(英、西、葡)科顿；(法)戈登<br>279, counterintuitive  [,kaʊntərɪn’tjuːɪtɪv]<br>adj. 违反直觉的<br>280, counterpart  [‘kaʊntəpɑːt]<br>n. 副本；配对物；极相似的人或物<br>281, Courage  [‘kʌrɪdʒ]<br>n. 勇气；胆量;<br>n. (Courage)人名；(英)卡里奇；(法)库拉热<br>282, crap  [kræp]<br>n. 废话；废物；屎；拉屎<br>vi. 掷骰子；拉屎<br>n. (Crap)人名；(英)克拉普<br>283, crater  [‘kreɪtə]<br>n. 火山口；弹坑;<br>vt. 在…上形成坑；取消；毁坏;<br>vi. 形成坑；消亡<br>284, crawler  [‘krɔlɚ]<br>n. 爬行者；履带牵引装置<br>285, creamy  [‘kriːmɪ]<br>adj.奶油色的；乳脂状的；含乳脂的<br>286, crisp  [krɪsp]<br>adj. 脆的；新鲜的；易碎的;<br>vt. 使卷曲；使发脆;<br>vi. 卷曲；发脆;<br>n. 松脆物；油炸马铃薯片;<br>n. (Crisp)人名；(英)克里斯普<br>287, criteria  [kraɪ’tɪərɪə]<br>n. 标准，条件（criterion的复数）<br>288, Criteria  [kraɪ’tɪərɪə]<br>n. 标准，条件（criterion的复数）<br>289, critical  [‘krɪtɪk(ə)l]<br>adj. 鉴定的；[核] 临界的；批评的，爱挑剔的；危险的；决定性的；评论的<br>290, criticize  [‘krɪtɪsaɪz]<br>vt. 批评；评论；非难<br>vi. 批评；评论；苛求<br>291, cropper  [‘krɒpə]<br>n. 种植者；农作物；收割机；修剪机<br>n. (Cropper)人名；(意)克罗珀尔；(英)克罗珀<br>292, crucial  [‘kruːʃ(ə)l]<br>adj. 重要的；决定性的；定局的；决断的<br>293, crunch  [krʌn(t)ʃ]<br>n. 咬碎，咬碎声；扎扎地踏<br>vt. 压碎；嘎扎嘎扎的咬嚼；扎扎地踏过<br>vi. 嘎吱作响地咀嚼；嘎吱嘎吱地踏过<br>294, cryptography  [krɪp’tɒgrəfɪ]<br>n. 密码学；密码使用法<br>295, Cryptography  [krɪp’tɒgrəfɪ]<br>n. 密码学；密码使用法<br>296, cue  [kjuː]<br>n.提示，暗示；线索<br>vt.给…暗示<br>n.(Cue)人名；(西)库埃<br>297, culprit  [‘kʌlprɪt]<br>n. 犯人，罪犯；被控犯罪的人<br>298, cumbersome  [‘kʌmbəs(ə)m]<br>adj. 笨重的；累赘的；难处理的<br>299, cumulative  [‘kjumjəletɪv]<br>adj. 累积的<br>300, cumulatively<br>adv. 累积地；渐增地<br>301, curator  [kjʊ(ə)’reɪtə]<br>n. 馆长；监护人；管理者<br>302, curly  [‘kɜːlɪ]<br>adj. 卷曲的；卷毛的；（木材）有皱状纹理的；蜷缩的<br>303, curry  [‘kʌrɪ]<br>vt. 用咖喱烧，给…加咖喱粉；梳刷；鞭打;<br>n. 咖哩粉，咖喱；咖哩饭菜<br>304, cutoff  [‘kʌt,ɔːf]<br>n. 切掉；中断；捷径</p><p>adj. 截止的；中断的<br>305, cutting-edge  [‘kʌtɪŋ’edʒ]<br>n. (刀片的)刃口；尖端；前沿;<br>adj. 先进的，尖端的<br>306, Cycle  [‘saɪk(ə)l]<br>n. 循环；周期；自行车；整套；一段时间;<br>vt. 使循环；使轮转;<br>vi. 循环；骑自行车；轮转<br>307, cyclone  [‘saɪklon]<br>n. 旋风；[气象] 气旋；飓风<br>308, dabble  [‘dæbl]<br>vt. 溅湿；浸入水中<br>vi. 涉猎；涉足；玩水<br>309, daemon  [‘diːmən]<br>n. 守护进程；后台程序<br>310, dapper  [‘dæpɚ]<br>adj. 短小精悍的；衣冠楚楚的；整洁的；整齐的<br>n. (Dapper)人名；(英)达珀；(意)达珀尔；(德)达佩尔<br>311, Dashboard  [‘dæʃbɔːd]<br>n. 汽车等的仪表板；马车等前部的挡泥板<br>312, daunting  [‘dɔntɪŋ]<br>adj. 使人畏缩的；使人气馁的；令人怯步的<br>313, deactivation  [di:,ækti’veiʃən]<br>n. [物化] 减活化作用；钝化作用<br>314, dealt  [delt]<br>v. 处理（deal的过去式和过去分词）<br>315, decade  [‘dekeid]<br>n. 十年，十年期；十<br>316, decay  [dɪ’ke]<br>vi. 衰退，[核] 衰减；腐烂，腐朽<br>n. 衰退，[核] 衰减；腐烂，腐朽<br>vt. 使腐烂，使腐败；使衰退，使衰落<br>n. (Decay)人名；(法)德凯<br>317, decaying  [dɪ’ke]<br>n. [核] 衰减；颓坏；腐蚀作用<br>v. 腐烂；衰退；消瘦（decay的ing形式）<br>adj. 衰减的；腐烂的；消散的<br>318, declarations  [,deklə’reiʃənz]<br>n. [法] 声明（declaration的复数）<br>319, Declarative  [dɪ’klærətɪv]<br>adj. 宣言的；陈述的，说明的<br>320, decommission  [diːkə’mɪʃ(ə)n]<br>vt. 使…退役；解除…的军职<br>321, decorate  [‘dekəreɪt]<br>vt. 装饰；布置；授勋给;<br>vi. 装饰；布置<br>322, decoration  [dekə’reɪʃ(ə)n]<br>n. 装饰，装潢；装饰品；奖章<br>323, decorator  [‘dɛkəretɚ]<br>n. 装饰者；室内装潢师<br>324, decouple  [diː’kʌp(ə)l]<br>vt. 减弱震波;<br>n. [电] 去耦<br>325, decoupling  [di:’kʌpliŋ]<br>n. 去耦<br>v. 去耦（decouple的现在分词）<br>326, dedicate  [‘dɛdɪket]<br>vt. 致力；献身；题献<br>327, dedicated  [‘dɛdə’ketɪd]<br>adj. 专用的；专注的；献身的<br>v. 以…奉献；把…用于（dedicate的过去式和过去分词）<br>328, deem  [diːm]<br>vt. 认为，视作；相信</p><p>vi. 认为，持某种看法；作某种评价</p><p>n. (Deem)人名；(英)迪姆<br>329, deemed  [diːmd]<br>v. 认为（deem的过去式）<br>330, Defer  [dɪ’fɜː]<br>vi. 推迟；延期；服从;<br>vt. 使推迟；使延期;<br>n. (Defer)人名；(法)德费<br>331, Deferred  [dɪ’fɜːd]<br>adj. 延期的;<br>v. 推迟（defer的过去式及过去分词形式）<br>332, deficiency  [dɪ’fɪʃ(ə)nsɪ]<br>n. 缺陷，缺点；缺乏；不足的数额<br>333, deficient  [dɪ’fɪʃ(ə)nt]<br>adj. 不足的；有缺陷的；不充分的<br>334, deflate  [dɪ’flet]<br>vt. 放气；使缩小；紧缩通货；打击；使泄气<br>vi. 缩小；物价下降<br>335, degree  [dɪ’griː]<br>n. 程度，等级；度；学位；阶层<br>336, dejection  [dɪ’dʒekʃ(ə)n]<br>n. 沮丧；粪便<br>337, delimiter  [dɪ’lɪmɪtɚ]<br>n. [计] 定界符<br>338, delta  [‘dɛltə]<br>n. （河流的）三角洲；德耳塔（希腊字母的第四个字）<br>n. (Delta)人名；(英、罗、葡)德尔塔<br>339, demand  [dɪ’mɑːnd]<br>vt. 要求；需要；查询;<br>vi. 需要；请求；查问;<br>n. [经] 需求；要求；需要;<br>n. (Demand)人名；(德)德曼德<br>340, demarcation  [‘dimɑr’keʃən]<br>n. 划分；划界；限界<br>341, democracy  [dɪˈmɑkrəsi]<br>n. 民主，民主主义；民主政治<br>342, demonstrate  [‘demənstreɪt]<br>vt. 证明；展示；论证<br>vi. 示威<br>343, demote  [diː’məʊt]<br>vt. 使降级；使降职<br>344, denial  [dɪ’naɪəl]<br>n. 否认；拒绝；节制；背弃<br>345, denoted<br>表示，指示（denote的过去式和过去分词）<br>346, Denotes  []<br>为…的符号，表示，指示（denote的第三人称单数）<br>347, density  [‘dɛnsəti]<br>n. 密度<br>348, dentry<br>目录项<br>349, depict  [dɪ’pɪkt]<br>vt. 描述；描画<br>350, Deploy  [dɪ’plɒɪ]<br>vt. 配置；展开；使疏开;<br>vi. 部署；展开;<br>n. 部署<br>351, depot  [‘depəʊ]<br>n. 仓库；停车场；航空站;<br>vt. 把…存放在储藏处;<br>adj. 药性持久的;<br>n. (Depot)人名；(刚(布))德波特<br>352, deprecation  [,depri’keiʃən]<br>n. 祈免；贬低；反对<br>353, derivative  [dɪ’rɪvətɪv]<br>n. [化学] 衍生物，派生物；导数<br>adj. 派生的；引出的<br>354, descendant  [dɪ’sɛndənt]<br>adj. 下降的；祖传的<br>n. 后裔；子孙<br>355, descended  [dɪ’sendɪd]<br>adj. 出身于…的；从一个祖先传下来的<br>356, designate  [‘dezɪgneɪt]<br>vt. 指定；指派；标出；把…定名为;<br>adj. 指定的；选定的<br>357, designated  [‘dɛzɪg,netɪd]<br>adj. 指定的；特指的<br>358, desirable  [dɪ’zaɪərəbl]<br>adj. 令人满意的；值得要的 n. 合意的人或事物<br>359, desire  [dɪ’zaɪɚ]<br>n. 欲望；要求，心愿；性欲<br>vt. 想要；要求；希望得到…<br>vi. 渴望<br>n. (Desire)人名；(刚(布)、英)德西雷<br>360, desired  [dɪ’zaɪrd]<br>adj. 渴望的；想得到的<br>v. 渴望，要求（desire的过去分词形式）<br>361, destruction  [dɪ’strʌkʃ(ə)n]<br>n. 破坏，毁灭；摧毁<br>362, detach  [dɪ’tætʃ]<br>vt. 分离；派遣；使超然<br>363, detached  [dɪ’tætʃt]<br>adj. 分离的，分开的；超然的<br>v. 分离<br>364, Detail  [‘diːteɪl]<br>n. 细节，详情;<br>vt. 详述；选派;<br>vi. 画详图<br>365, deviation  [‘divɪ’eʃən]<br>n. 偏差；误差；背离<br>366, diagnose  [‘daɪəgnəʊz; -‘nəʊz]<br>vt. 诊断；断定</p><p>vi. 诊断；判断<br>367, diagram  [‘daɪəgræm]<br>n. 图表；图解<br>vt. 用图解法表示<br>diagram: 图表  图解  简图<br>368, dial  [‘daɪəl]<br>n. 转盘；刻度盘；钟面<br>vi. 拨号<br>vt. 给…拨号打电话<br>n. (Dial)人名；(英)戴尔<br>369, dialect  [‘daɪəlekt]<br>n. 方言，土话；同源语；行话；个人用语特征</p><p>adj. 方言的<br>370, Dialect  [‘daɪəlekt]<br>n. 方言，土话；同源语；行话；个人用语特征;<br>adj. 方言的<br>371, digest  [daɪ’dʒɛst]<br>vt. 消化；吸收；融会贯通<br>vi. 消化<br>n. 文摘；摘要<br>372, Digest  [daɪ’dʒest; dɪ-]<br>vt. 消化；吸收；融会贯通;<br>vi. 消化;<br>n. 文摘；摘要<br>373, dimension  [dɪ’menʃ(ə)n; daɪ-]<br>n. 方面;[数] 维；尺寸；次元；容积 vt. 标出尺寸;<br>adj. 规格的;<br>adj. 规格的<br>374, dimensional  [dɪ’menʃənəl]<br>adj. 空间的；尺寸的<br>375, dimensionality  [daɪmɛnʃə’næləti]<br>n. 维度；幅员；广延<br>376, dimensions  [dɪ’mɛnʃənz]<br>n. 规模，大小<br>377, directive  [daɪ’rɛktɪv]<br>n. 指示；指令<br>adj. 指导的；管理的<br>378, disambiguate  [dɪsæm’bɪgjʊeɪt]<br>vt. 消除（字句等的）含糊意义，消除…的虚无主义<br>379, disastrous  [dɪ’zɑːstrəs]<br>adj. 灾难性的；损失惨重的；悲伤的<br>380, discrepancy  [dɪs’krep(ə)nsɪ]<br>n. 不符；矛盾；相差<br>381, discretionary  [dɪ’skreʃ(ə)n(ə)rɪ]<br>adj. 任意的；自由决定的<br>382, discriminator  [dɪ’skrɪmɪneɪtə]<br>n. [电子] 鉴别器；辨别者<br>383, discuss  [dɪ’skʌs]<br>vt. 讨论；论述，辩论<br>384, dismiss  [dɪs’mɪs]<br>vt. 解散；解雇；开除；让…离开；不予理会、不予考虑;<br>vi. 解散<br>385, Dismissal  [dɪs’mɪsl]<br>n. 解雇；免职<br>386, Dispatcher  [dɪs’pætʃə]<br>n. 调度员；[计] 调度程序；[计] 分配器<br>387, disperse  [dɪ’spɜːs]<br>vt. 分散；使散开；传播;<br>vi. 分散;<br>adj. 分散的<br>388, Displaced  [dɪs’ples]<br>adj. 无家可归的；位移的；被取代的<br>n. 无家可归者<br>v. 取代（displace的过去分词）；移动…的位置；撤换<br>389, disruption  [dɪs’rʌpʃən]<br>n. 破坏，毁坏；分裂，瓦解<br>390, disruptor  [disruptor]<br>n. 破坏者，分裂者<br>391, Disruptor  [dɪsˈrʌpt]<br>n. 破坏者，分裂者<br>392, dissect  [dɪˈsɛkt, daɪ-, ˈdaɪˌsɛkt]<br>vt. 切细；仔细分析<br>vi. 进行解剖；进行详细分析<br>393, Dissector  [dɪ’sektə]<br>n. 解剖器；析象器<br>394, Dissipator  [‘disipeitə]<br>n. 浪子，放荡者<br>395, distinguish  [dɪ’stɪŋgwɪʃ]<br>vi. 区别，区分；辨别<br>vt. 区分；辨别；使杰出，使表现突出<br>396, Distributed  [dɪ’strɪbjʊtɪd]<br>adj. 分布式的，分散式的<br>397, Distributions  [,dɪstrə’bjʊʃən]<br>n. 分派；分派；分销（distribution的复数形式）<br>398, Distro  [Distro]<br>n. 发行版<br>399, divergence  [daɪ’vɜːdʒ(ə)ns]<br>n. 分歧<br>400, Doctype<br>n. 文档类型<br>401, Domestic  [də’mestɪk]<br>adj. 国内的；家庭的；驯养的；一心只管家务的<br>n. 国货；佣人<br>402, dominant  [‘dɒmɪnənt]<br>adj. 显性的；占优势的；支配的，统治的<br>n. 显性<br>403, Donations  [doʊ’neɪʃnz]<br>n. [经] 捐赠（donation的复数）；捐款<br>404, dozens<br>n. 许多（dozen的复数）<br>405, drain  [dren]<br>vi. 排水；流干<br>vt. 喝光，耗尽；使流出；排掉水<br>n. 排水；下水道，排水管；消耗<br>n. (Drain)人名；(英)德雷恩；(法)德兰<br>406, dramatically  [drə’mætɪkəlɪ]<br>adv. 戏剧地；引人注目地;<br>adv. 显著地，剧烈地<br>407, drastically  [‘dræstikəli]<br>adv. 彻底地；激烈地<br>408, drawback  [‘drɔbæk]<br>n. 缺点，不利条件；退税<br>409, drench  [dren(t)ʃ]<br>vt. 使湿透；给（牲畜）灌药;<br>n. 滂沱大雨；浸液<br>410, drill  [drɪl]<br>n. 训练；钻孔机；钻子；播种机<br>vi. 钻孔；训练<br>vt. 钻孔；训练；条播<br>n. (Drill)人名；(德、英)德里尔<br>411, drip  [drɪp]<br>vi. 滴下；充满；漏下<br>n. 水滴，滴水声；静脉滴注；使人厌烦的人<br>vt. 使滴下；溢出，发出<br>412, dual  [‘djuːəl]<br>adj. 双的；双重的;<br>n. 双数；双数词;<br>n. (Dual)人名；(法)迪阿尔<br>413, duckweed  [‘dʌkwiːd]<br>n. 浮萍；水萍<br>414, Duckweed  [‘dʌkwiːd]<br>n. 浮萍；水萍<br>415, ducky  [‘dʌkɪ]<br>adj. 可喜的；极好的；极为愉快的<br>416, dumb  [dʌm]<br>adj. 哑的，无说话能力的；不说话的，无声音的<br>417, dummy  [‘dʌmi]<br>adj. 虚拟的；假的<br>n. 傀儡；哑巴；仿制品<br>418, dust  [dʌst]<br>n. 灰尘；尘埃；尘土;<br>vt. 撒；拂去灰尘;<br>vi. 拂去灰尘；化为粉末;<br>n. (Dust)人名；(德、俄)杜斯特<br>419, Dutch  [dʌtʃ]<br>adj. 荷兰的；荷兰人的；荷兰语的<br>n. 荷兰人；荷兰语<br>adv. 费用平摊地；各自付账地<br>420, dutiful  [‘djuːtɪfʊl; -f(ə)l]<br>adj. 忠实的；顺从的；守本分的<br>421, E-Commerce  [‘i:,kɒmɜ:s]<br>n. 电子商务<br>422, ebook  [‘i:buk]<br>n. 电子书<br>423, echo  [‘ɛko]<br>vt. 反射；重复<br>vi. 随声附和；发出回声<br>n. 回音；效仿<br>424, ecosystem  [‘ɛko,sɪstəm]<br>n. 生态系统<br>425, eden  [‘i:dən]<br>n. 伊甸园（《圣经》中亚当和夏娃最初居住的地方）<br>426, edgesight  </p><p>427, ego  [‘iːgəʊ; ‘e-]<br>n. 自我；自负；自我意识;<br>n. (Ego)人名；(日)依怙 (姓)；(法)埃戈<br>428, elaborate  [ɪ’læbəret]<br>adj. 精心制作的；详尽的；煞费苦心的<br>vt. 精心制作；详细阐述；从简单成分合成（复杂有机物）<br>vi. 详细描述；变复杂<br>429, elapse  [ɪ’læps]<br>vi. 消逝；时间过去<br>n. 流逝；时间的过去<br>430, elapsed<br>v. 时间过去；消逝（elapse的过去分词）<br>431, elastic  [ɪ’læstɪk]<br>adj. 有弹性的；灵活的；易伸缩的;<br>n. 松紧带；橡皮圈<br>432, election  [ɪ’lekʃ(ə)n]<br>n. 选举；当选；选择权；上帝的选拔<br>433, elector  [ɪ’lɛktɚ]<br>n. 选举人；有选举权的人；总统选举人<br>434, elide  [ɪ’laɪd]<br>vt. 省略；取消；删去；不予考虑删节<br>n. (Elide)人名；(意)埃利德<br>435, eligible  [‘elɪdʒɪb(ə)l]<br>adj. 合格的，合适的；符合条件的；有资格当选的<br>n. 合格者；适任者；有资格者<br>436, eliminate  [ɪ’lɪmɪnet]<br>vt. 消除；排除<br>437, elimination  [ɪ,lɪmɪ’neɪʃən]<br>n. 消除；淘汰；除去<br>438, embed  [ɪm’bɛd]<br>vt. 栽种；使嵌入，使插入；使深留脑中<br>439, embedded  [ɪmˈbɛdɪd]<br>adj. 嵌入式的；植入的；内含的<br>v. 嵌入（embed的过去式和过去分词形式）<br>440, Embedded  [ɪm’bedɪd]<br>adj. 嵌入式的；植入的；内含的;<br>v. 嵌入（embed的过去式和过去分词形式）<br>441, embellishment  [ɪm’belɪʃmənt]<br>n. 装饰，修饰；润色<br>442, emergency  [ɪ’mɜːdʒ(ə)nsɪ]<br>n. 紧急情况；突发事件；非常时刻<br>adj. 紧急的；备用的<br>443, emit  [ɪ’mɪt]<br>vt. 发出，放射；发行；发表<br>444, empathy  [‘empəθɪ]<br>n. 神入；移情作用；执着<br>n. 感同身受；同感；共鸣<br>445, emphasis  [‘ɛmfəsɪs]<br>n. 重点；强调；加强语气<br>446, emphasis on  []<br>着重于；对…的强调<br>emphasis on: 对  强调  对……的强调<br>447, emphasize  [‘ɛmfəsaɪz]<br>vt. 强调，着重<br>448, employ  [ɪm’plɒɪ; em-]<br>vt. 使用，采用；雇用；使忙于，使从事于</p><p>n. 使用；雇用<br>449, empower  [ɪm’paʊə; em-]<br>vt. 授权，允许；使能够<br>450, emulation  [,emjʊ’leɪʃən]<br>n. [计] 仿真；竞争；效法<br>451, encapsulate  [ɪn’kæpsjʊleɪt; en-]<br>vt. 压缩；将…装入胶囊；将…封进内部；概述;<br>vi. 形成胶囊<br>452, encapsulated  [ɪn’kæpsəleɪtɪd]<br>adj. 密封的；包在荚膜内的</p><p>v. 压缩（encapsulate的过去分词）；封进内部；装入胶囊<br>453, encapsulates  [ɪn’kæpsjʊleɪt; en-]<br>vt. 压缩；将…装入胶囊；将…封进内部;<br>vi. 形成胶囊<br>454, encapsulation  [ɪn,kæpsə’leʃən]<br>n. 封装；包装<br>455, Encapsulation  [ɪn,kæpsə’leɪʃən]<br>n. 封装；包装<br>456, encompass  [ɪn’kʌmpəs; en-]<br>vt. 包含；包围，环绕；完成<br>457, encore  [‘ɒŋkɔː]<br>n. 再演唱的要求；经要求而再唱<br>vt. 要求再演或唱<br>int. 再来一个<br>458, encounter  [ɪn’kaʊntə; en-]<br>vt. 遭遇，邂逅；遇到;<br>n. 遭遇，偶然碰见;<br>vi. 遭遇；偶然相遇<br>459, encrypted<br>v. 把…编码；把…加密（encrypt的过去分词）<br>460, endeavour  [ɪn’devə; en-]<br>n. 尽力，竭力;<br>vt. 竭力做到，试图或力图（做某事）;<br>vi. 竭力；企图<br>461, enormous  [ɪ’nɔːməs]<br>adj. 庞大的，巨大的；凶暴的，极恶的<br>462, entail  [ɪn’tel]<br>vt. 使需要，必需；承担；遗传给；蕴含<br>n. 引起；需要；继承<br>463, enthusiasm  [ɪn’θjuːzɪæz(ə)m; en-]<br>n. 热心，热忱，热情<br>464, enthusiastic  [ɪn,θjuːzɪ’æstɪk; en-]<br>adj. 热情的；热心的；狂热的<br>465, entrance  [‘entr(ə)ns]<br>n. 入口；进入;<br>vt. 使出神，使入迷<br>466, entrypoint  [entrypoint]<br>n. 进入点；入境点；入口点<br>467, envelope  [‘envələʊp; ‘ɒn-]<br>n. 信封，封皮；包膜；[天] 包层；包迹<br>468, ephemeral  [ə’fɛmərəl]<br>adj. 短暂的；朝生暮死的<br>n. 只生存一天的事物<br>469, epoch  [‘ɛpək]<br>n. [地质] 世；新纪元；新时代；时间上的一点<br>470, equate  [ɪ’kweɪt]<br>vt. 使相等；视为平等;<br>vi. 等同<br>471, equates  [ɪ’kweɪt]<br>vt. 使相等；视为平等</p><p>vi. 等同<br>472, equipment  [ɪ’kwɪpm(ə)nt]<br>n. 设备，装备；器材<br>473, equivalent  [ɪ’kwɪv(ə)l(ə)nt]<br>adj. 等价的，相等的；同意义的;<br>n. 等价物，相等物<br>474, erase  [ɪ’reɪz]<br>vt. 抹去；擦除<br>vi. 被擦去，被抹掉<br>475, erasure  [ɪ’reɪʒə(r)]<br>n. 消除；涂擦的痕迹；消磁<br>476, estimate  [‘ɛstə,met]<br>vi. 估计，估价<br>n. 估计，估价；判断，看法<br>vt. 估计，估量；判断，评价<br>477, Estimate  [‘estɪmeɪt]<br>vi. 估计，估价;<br>n. 估计，估价；判断，看法;<br>vt. 估计，估量；判断，评价<br>478, estimated  [ɛstəˌmetɪd]<br>adj. 估计的；预计的；估算的<br>479, estimation  [,ɛstɪ’meʃən]<br>n. 估计；尊重<br>480, ethereal  [ɪ’θɪərɪəl]<br>adj. 优雅的；轻飘的；缥缈的；超凡的<br>481, ethernet  [‘iθɚnɛt]<br>n. [计] 以太网<br>482, Ethernet  [Ethernet]<br>n. [计] 以太网<br>483, evacuate  [ɪ’vækjuet]<br>vt. 疏散，撤退；排泄<br>vi. 疏散；撤退；排泄<br>484, evacuated  [ɪ’vækjʊ,et]<br>adj. 疏散；排空的，撤退者的<br>v. 疏散；撤出；排泄（evacuate的过去式和过去分词形式）<br>485, evacuation  [ɪ,vækjʊ’eɪʃ(ə)n]<br>n. 疏散；撤离；排泄<br>486, eval  [ɪ’væl]<br>n. 重新运算求出参数的内容<br>487, evaluate  [ɪ’væljʊeɪt]<br>vt. 评价；估价；求…的值;<br>vi. 评价；估价<br>488, Evaluate  [ɪ’væljʊeɪt]<br>vt. 评价；估价；求…的值;<br>vi. 评价；估价<br>489, evaluated<br>vi. 评估；估…的价（evaluate的过去分词形式）<br>490, even  [‘iːv(ə)n]<br>adj. [数] 偶数的；平坦的；相等的;<br>adv. 甚至；即使；还；实际上;<br>vt. 使平坦；使相等;<br>vi. 变平；变得可比较；成为相等;<br>n. (Even)人名；(法)埃旺；(德)埃文；(英)埃文<br>491, eventually  [ɪ’ventʃʊəlɪ]<br>adv. 最后，终于<br>492, evict  [ɪ’vɪkt]<br>vt. 驱逐；逐出<br>493, eviction  [ɪ’vɪkʃ(ə)n]<br>n. 逐出；赶出；收回<br>494, Eviction  [ɪ’vɪkʃ(ə)n]<br>n. 逐出；赶出；收回<br>495, evolve  [ɪ’vɒlv]<br>vt. 发展，进化；进化；使逐步形成；推断出;<br>vi. 发展，进展；进化；逐步形成<br>496, Evolve  [ɪ’vɒlv]<br>vt. 发展，进化；进化；使逐步形成；推断出;<br>vi. 发展，进展；进化；逐步形成<br>497, evolved<br>adj. 进化了的;<br>vt. 使逐步形成（evolve的过去分词）<br>498, exact  [ɪg’zækt; eg-]<br>adj. 准确的，精密的；精确的;<br>vt. 要求；强求；急需;<br>vi. 勒索钱财<br>499, examine  [ɪg’zæmɪn; eg-]<br>vt. 检查；调查； 检测；考试;<br>vi. 检查；调查<br>500, excitable  [ɪk’saɪtəb(ə)l; ek-]<br>adj. 易激动的；易兴奋的；易怒的<br>501, Exclusive  [ɪk’skluːsɪv; ek-]<br>adj. 独有的；排外的；专一的;<br>n. 独家新闻；独家经营的项目；排外者<br>502, exhaustive  [ɪg’zɔːstɪv; eg-]<br>adj. 详尽的；彻底的；消耗的<br>503, exotic  [ɪg’zɒtɪk; eg-]<br>adj. 异国的；外来的；异国情调的<br>504, experimental  [ek,speri’mentəl; ek’s-]<br>adj. 实验的；根据实验的；试验性的<br>505, explanatory  [ɪk’splænətɔri]<br>adj. 解释的；说明的<br>506, explicitly  [ɪk’splɪsɪtli]<br>adv. 明确地；明白地<br>507, explode  [ɪk’spləʊd; ek-]<br>vi. 爆炸，爆发；激增;<br>vt. 使爆炸；爆炸；推翻<br>508, exponential  [‘ɛkspə’nɛnʃəl]<br>adj. 指数的<br>n. 指数<br>509, exponentially  [,ɛkspo’nɛnʃəli]<br>adv. 以指数方式<br>510, exponentiation  [,ekspənenʃɪ’eɪʃ(ə)n]<br>n. [数] 取幂，求幂；乘方<br>511, expose  [ɪk’spəʊz; ek-]<br>vt. 揭露，揭发；使曝光；显示<br>512, expresso  [ek’spresəʊ]<br>n. （蒸汽加压煮出的）浓咖啡<br>513, expunge  [ɪk’spʌndʒ]<br>vt. 擦去；删掉<br>514, Expunge  [ɪk’spʌn(d)ʒ; ek-]<br>vt. 擦去；删掉<br>515, expunges  [ɪk’spʌn(d)ʒ; ek-]<br>vt. 擦去；删掉<br>516, extensible  [ek’stensɪbl; ɪk’stensɪb(ə)l]<br>adj. 可延长的；可扩张的<br>517, Extensible  [ek’stensɪbl; ɪk’stensɪb(ə)l]<br>adj. 可延长的；可扩张的<br>518, extent  [ɪk’stent; ek-]<br>n. 程度；范围；长度<br>519, extract  [ˈekstrækt]<br>vt. 提取；取出；摘录；榨取</p><p>n. 汁；摘录；榨出物；选粹<br>520, extrapolate  [ɪk’stræpə’let]<br>vt. 外推；推断<br>vi. 外推；进行推断<br>过去式:extrapolated; 过去分词:extrapolated; 现在分词:extrapolating<br>521, extrapolated<br>v. 推测（extrapolate的过去分词）<br>adj. 推测的<br>522, Extras  [‘ɛkstrə]<br>n. 附加设备；额外部分；另外收费的部分（extra的复数）<br>523, facade  [fə’sɑːd]<br>n. 正面；表面；外观<br>524, facilitate  [fə’sɪlɪteɪt]<br>vt. 促进；帮助；使容易<br>525, faint  [feɪnt]<br>adj. 模糊的；头晕的；虚弱的；[医] 衰弱的</p><p>vi. 昏倒；变得微弱；变得没气力</p><p>n. [中医] 昏厥，昏倒<br>526, Fake  [feɪk]<br>n. 假货；骗子；假动作;<br>vt. 捏造；假装…的样子;<br>vi. 假装；做假动作;<br>adj. 伪造的;<br>n. (Fake)人名；(英)费克<br>527, Fakes  []<br>n. 赝品；云母板状岩；假冒商品（fake的复数）;<br>v. 佯装；假装（fake的三单形式）;<br>n. (Fakes)人名；(法)法克<br>528, fallback  [‘fɔlbæk]<br>n. 可依靠的东西；后备物品；撤退，退却<br>529, fame  [feɪm]<br>n. 名声，名望；传闻，传说;<br>vt. 使闻名，使有名望<br>530, fanatical  [fə’nætɪkəl]<br>adj. 狂热的<br>531, fancy  [‘fænsɪ]<br>n. 幻想；想象力；爱好;<br>adj. 想象的；奇特的；昂贵的；精选的;<br>vt. 想象；喜爱；设想；自负;<br>vi. 幻想；想象;<br>n. (Fancy)人名；(法)方西<br>532, fanout  [fanout]<br>n. 扇出；展开；分列（账户）<br>533, fatal  [‘fetl]<br>adj. 致命的；重大的；毁灭性的；命中注定的 n. (Fatal)人名；(葡、芬)法塔尔<br>534, fault  [fɔːlt; fɒlt]<br>n. 故障；[地质] 断层；错误；缺点；毛病；（网球等）发球失误</p><p>vi. 弄错；产生断层</p><p>vt. （通常用于疑问句或否定句）挑剔<br>535, favor  [‘feɪvə]<br>vt. 赞成；喜欢；像；赐予；证实;<br>n. 喜爱；欢心；好感<br>536, federate  [‘fedəreɪt]<br>adj. 同盟的；联邦制度下的；联合的<br>vt. 使结成同盟；使结成联邦<br>vi. 结成联邦<br>537, federated  [‘fɛdə,retɪd]<br>adj. 联邦的；联合的；结成同盟的</p><p>v. 结成同盟；按联邦制组织起来（federate的过去分词）<br>538, federation  [fedə’reɪʃ(ə)n]<br>n. 联合；联邦；联盟；联邦政府<br>539, fence  [fens]<br>n. 栅栏；围墙；剑术<br>vt. 防护；用篱笆围住；练习剑术<br>vi. 击剑；搪塞；围以栅栏；跳过栅栏<br>540, fetch  [fetʃ]<br>vt. 取来；接来；到达；吸引;<br>vi. 拿；取物；卖得;<br>n. 取得；诡计<br>541, fictional  [‘fɪkʃənl]<br>adj. 虚构的；小说的<br>542, fictitious  [fɪk’tɪʃəs]<br>adj. 虚构的；假想的；编造的；假装的<br>543, final  [‘faɪn(ə)l]<br>adj. 最终的；决定性的；不可更改的;<br>n. 决赛；期末考试；当日报纸的末版<br>544, finer-grained  [finer-grained]<br>细粒度<br>545, firework  [‘faɪɚwɝk]<br>n. 烟火；激烈情绪<br>546, flap  [flæp]<br>n. 拍打，拍打声；神经紧张；[航] 襟翼<br>vi. 拍动；神经紧张；鼓翼而飞；（帽边等）垂下<br>vt. 拍打；扔；拉下帽边；飘动<br>547, flat  [flæt]<br>adj. 平的；单调的；不景气的；干脆的；平坦的；扁平的；浅的;<br>adv. （尤指贴着另一表面）平直地；断然地；水平地；直接地，完全地;<br>n. 平地；公寓；平面;<br>vt. 使变平；[音乐]使（音调）下降，尤指降半音;<br>vi. 逐渐变平；[音乐]以降调唱（或奏）;<br>n. （法）弗拉特（人名）；（英）弗莱特（人名）<br>548, flatten  [‘flætn]<br>vt. 击败，摧毁；使……平坦 vi. 变平；变单调 n. (Flatten)人名；(德)弗拉滕<br>549, flatter  [‘flætə]<br>vt. 奉承；谄媚；使高兴<br>550, flavors<br>n. 风味调料（flavor复数）<br>v. 添加味道（flavor的三单形式）<br>551, flavour<br>n. 香味；滋味<br>vt. 给……调味；给……增添风趣<br>552, fledged  [fledʒd]<br>adj. 成熟的；快会飞的；羽毛丰满的<br>553, flood  [flʌd]<br>vt. 淹没；充满；溢出<br>vi. 涌出；涌进；为水淹没<br>n. 洪水；泛滥；一大批<br>n. (Flood)人名；(英)弗勒德；(瑞典、芬)弗洛德<br>554, fluent  [‘fluənt]<br>adj. 流畅的，流利的；液态的；畅流的<br>555, flute  [fluːt]<br>n. 长笛；【工程设计】(刀具的)出屑槽<br>vt. 用长笛吹奏<br>vi. 吹长笛<br>556, forcibly  [‘fɔːsɪblɪ]<br>adv. 用力地；强制地；有说服力地<br>557, foremost  [‘fɔːməʊst]<br>adj. 最重要的；最先的<br>adv. 首先；居于首位地<br>558, forges<br>n. 轻便锻炉；熔炉（forge的复数）</p><p>v. 伪造（forge的第三人称单数）；打制</p><p>n. (Forges)人名；(法)福尔热<br>559, fork  [fɔːk]<br>n. 叉；餐叉；耙;<br>vt. 叉起；使成叉状;<br>vi. 分叉；分歧;<br>n. (Fork)人名；(英、德)福克<br>560, formerly  [‘fɔːməlɪ]<br>adv. 以前；原来<br>561, Fortress  [‘fɔːtrɪs]<br>n. 堡垒；要塞;<br>vt. 筑要塞；以要塞防守<br>562, Forwarding  [‘fɔːwədɪŋ]<br>v. 促进；寄发；装订；转递（forward的ing形式）;<br>n. 转发；促进；运输业务；各项装订工序;<br>adj. 运输的；转发的<br>563, foundry  [‘faʊndri]<br>n. 铸造，铸造类；[机] 铸造厂<br>564, fractional  [‘frækʃənl]<br>adj. 部分的；[数] 分数的，小数的<br>565, fragile  [‘frædʒəl]<br>adj. 脆的；易碎的<br>566, fragments  [‘frægmənt]<br>n. 碎片（fragment的复数）；片断；[计] 分段;<br>v. 破碎（fragment的三单形式）；打碎<br>567, frequency  [‘frikwənsi]<br>n. 频率；频繁<br>568, fresh  [freʃ]<br>adj. 新鲜的；清新的；淡水的；无经验的;<br>n. 开始；新生；泛滥;<br>adv. 刚刚，才；最新地<br>569, frugal  [‘fruːg(ə)l]<br>adj. 节俭的；朴素的；花钱少的<br>570, frustrate  [frʌ’streɪt; ‘frʌs-]<br>vt. 挫败；阻挠；使感到灰心;<br>vi. 失败；受挫;<br>adj. 挫败的；无益的<br>571, fudge  [fʌdʒ]<br>n. 软糖；胡说；谎话<br>vt. 捏造；粗制滥造；回避<br>vi. 逃避责任；欺骗；蒙混<br>int. 胡说八道！<br>n. (Fudge)人名；(英)富奇<br>572, functionality  [fʌŋkʃə’nælətɪ]<br>n. 功能；[数] 泛函性，函数性<br>573, fundamental  [fʌndə’ment(ə)l]<br>adj. 基本的，根本的<br>n. 基本原理；基本原则<br>574, fuzzy  [‘fʌzi]<br>adj. 模糊的；失真的；有绒毛的<br>n. (Fuzzy)人名；(英)富齐<br>[ 比较级:fuzzier 最高级:fuzziest ]<br>575, gain  [geɪn]<br>n. 增加；利润；收获;<br>vt. 获得；增加；赚到;<br>vi. 增加；获利;<br>n. (Gain)人名；(英、匈、法)盖恩<br>576, gauge  [gedʒ]<br>n. 计量器；标准尺寸；容量规格<br>vt. 测量；估计；给…定规格<br>577, gear  [ɡɪr]<br>n. 齿轮；装置，工具；传动装置 vi. 适合；搭上齿轮；开始工作 vt. 开动；搭上齿轮；使……适合；使……准备好 adj. 好极了 n. (Gear)人名；(英)吉尔<br>578, gem  [dʒɛm]<br>n. 宝石，珍宝； 精华；受人重视者<br>vi. 点缀； 用宝石装饰； 饰以宝石<br>adj. 最佳品质的<br>n. (Gem)人名；(英)杰姆<br>579, geographically  [dʒɪə’græfɪkli]<br>adv. 在地理上；地理学上<br>580, gigabytes<br>n. 千兆字节（gigabyte的复数）；十亿位元组<br>581, glimpse  [glɪm(p)s]<br>n. 一瞥，一看</p><p>vi. 瞥见</p><p>vt. 瞥见<br>582, glossary  [‘glɒs(ə)rɪ]<br>n. 术语（特殊用语）表；词汇表；专业词典<br>583, glossed  [glɒs]<br>n. 光彩；注释；假象;<br>vt. 使光彩；掩盖；注释;<br>n. (Gloss)人名；(德、西、捷)格洛斯<br>584, goals  [gəʊlz]<br>n. 目标，[心理] 目的；进球，射中次数<br>585, gradient  [‘greɪdɪənt]<br>n. [数][物] 梯度；坡度；倾斜度;<br>adj. 倾斜的；步行的<br>586, gradients<br>n. 渐变，[数][物] 梯度（gradient复数形式）<br>587, gradually  [‘grædʒʊəli]<br>adv. 逐步地；渐渐地<br>588, grant  [grɑːnt]<br>vt. 授予；允许；承认</p><p>vi. 同意</p><p>n. 拨款；[法] 授予物</p><p>n. (Grant)人名；(瑞典、葡、西、俄、罗、英、塞、德、意)格兰特；(法)格朗<br>589, granularity<br>n. 间隔尺寸，[岩] 粒度<br>590, graphical  [‘græfɪk(ə)l]<br>adj. 图解的；绘画的；生动的<br>591, greedy  [‘griːdɪ]<br>adj. 贪婪的；贪吃的；渴望的<br>592, grep  [grep]<br>n. UNIX工具程序；可做文件内的字符串查找;<br>n. (Grep)人名；(苏里)格雷普<br>593, grok  [ɡrɑk]<br>vt. 凭直觉深刻了解；欣赏；神交<br>vi. 心意相通；与…神交<br>594, gross  [ɡros]<br>adj. 总共的；粗野的；恶劣的；显而易见的<br>vt. 总共收入<br>n. 总额，总数<br>n. (Gross)人名；(英、法、德、意、葡、西、俄、芬、罗、捷、匈)格罗斯<br>595, grumpy  [‘ɡrʌmpi]<br>adj. 脾气暴躁的；性情乖戾的<br>n. 脾气坏的人；爱抱怨的人<br>596, guarantee  [,ɡærən’ti]<br>n. 保证；担保；保证人；保证书；抵押品<br>vt. 保证；担保<br>597, guaranteed  [‘gærən’tid]<br>adj. 有保证的，；有人担保的;<br>v. 担保（guarantee的过去式和过去分词）<br>598, guide  [gaɪd]<br>n. 指南；向导；入门书;<br>vt. 引导；带领；操纵;<br>vi. 担任向导;<br>n. (Guide)人名；(法、葡)吉德<br>599, Guvnor  [‘ɡʌvnə]<br>n. 雇主；老板<br>600, gym  [dʒɪm]<br>n. 健身房；体育；体育馆<br>601, hall  [hɔːl]<br>n. 过道，门厅，走廊；会堂；食堂；学生宿舍；大厅，前厅；娱乐中心，会所;<br>n. （土）哈勒（人名）；（德、波、丹、芬、瑞典）哈尔（人名）；（英）霍尔（人名）；（法）阿尔（人名）<br>602, hallway  [‘hɔːlweɪ]<br>n. 走廊；门厅；玄关<br>603, halted<br>v. 停止，停顿（halt的过去式，过去分词）<br>604, halve  [hɑːv]<br>vt. 二等分；把……减半</p><p>n. (Halve)人名；(芬)哈尔韦<br>605, handlers  []<br>n. 操作者；经理人；陶器工人（handler的复数）<br>606, handshake  [‘hæn(d)ʃeɪk]<br>n. 握手<br>607, hashtag  [ˈhæʃˌtæɡ]<br>n. 标签<br>608, hazard  [‘hæzəd]<br>vt. 赌运气；冒…的危险，使遭受危险<br>n. 危险，冒险；冒险的事<br>n. (Hazard)人名；(法)阿扎尔；(英)哈泽德<br>609, headroom  [‘hedruːm; -rʊm]<br>n. 净空；净空高度；头上空间<br>610, heap  [hiːp]<br>n. 堆；许多；累积;<br>vt. 堆；堆积;<br>vi. 堆起来;<br>n. (Heap)人名；(芬)海亚普；(东南亚国家华语)协；(英)希普<br>611, heck  [hek]<br>int.真见鬼（hell的委婉说法）<br>n.饲草架<br>n.(Heck)人名；(德)黑克；(葡、西、法)埃克；(英)赫克<br>612, Hence  [hens]<br>adv. 因此；今后<br>613, hereby  [hɪə’baɪ]<br>adv. 以此方式，据此；特此<br>614, hesitant  [‘hɛzɪtənt]<br>adj. 迟疑的；踌躇的；犹豫不定的<br>615, hesitate  [ˈhɛzətet]<br>vi. 踌躇，犹豫；不愿<br>vt. 踌躇，犹豫；有疑虑，不愿意<br>616, heterogeneous  [,het(ə)rə(ʊ)’dʒiːnɪəs; -‘dʒen-]<br>adj. [化学] 多相的；异种的；[化学] 不均匀的；由不同成分形成的<br>617, heuristics  [hju’rɪstɪks]<br>n. 启发法；启发式教学法<br>618, hexadecimal  [,hɛksə’dɛsɪml]<br>adj. 十六进制的<br>n. 十六进制<br>619, hierarchical  [haɪə’rɑːkɪk(ə)l]<br>adj. 分层的；等级体系的<br>620, hierarchy  [‘haɪərɑːkɪ]<br>n. 层级；等级制度<br>621, hint  [hɪnt]<br>n. 暗示；线索<br>vt. 暗示；示意<br>vi. 示意<br>n. (Hint)人名；(英)欣特；(法)安特<br>622, histogram  [‘hɪstəɡræm]<br>n. [统计] 直方图；柱状图<br>623, hitchhiker  [‘hɪtʃhaɪkə]<br>n. 搭便车的旅行者；顺便插入的广告<br>624, hive  [haɪv]<br>vi. 群居；入蜂房；生活在蜂房中<br>n. 蜂房，蜂巢；热闹的场所；熙攘喧闹的人群<br>vt. 入蜂箱；贮备<br>625, hoist  [hɒɪst]<br>n. 起重机；升起，吊起;<br>vi. 升起；吊起;<br>vt. （用绳索，起重机等）使升起;<br>n. (Hoist)人名；(英)霍伊斯特<br>626, hole  [həʊl]<br>n. 洞，孔；洞穴，穴；突破口<br>vi. 凿洞，穿孔；（高尔夫球等）进洞<br>vt. 凿洞<br>n. (Hole)人名；(瑞典、挪)霍勒；(英)霍尔<br>627, holt  [holt]<br>n. 小林；林丘；杂木林<br>n. (Holt)人名；(英、德、罗、匈、瑞典)霍尔特；(法、西)奥尔特<br>628, homebrew  [homebrew]<br>n. 自酿（啤）酒；公司自产自用<br>629, honestly  [‘ɒnɪstlɪ]<br>adv. 真诚地；公正地<br>630, hood  [hʊd]<br>n. 头巾；覆盖；兜帽<br>n. (Hood)人名；(英)胡德；(德、荷)霍德<br>vt. 罩上；以头巾覆盖<br>631, hostile  [‘hɒstaɪl]<br>adj. 敌对的，敌方的；怀敌意的;<br>n. 敌对<br>632, hourly  [‘aʊɚli]<br>adv. 每小时地；频繁地，随时<br>adj. 每小时的，以钟点计算的；频繁的<br>633, hydrant  [‘haɪdr(ə)nt]<br>n. 消防栓；水龙头；给水栓<br>634, ideally  [aɪ’diəli]<br>adv. 理想地；观念上地<br>635, idempotent  [,aɪdem’pəʊt(ə)nt; aɪ’dempət(ə)nt]<br>adj. 幂等的</p><p>n. [数] 幂等<br>636, identify  [aɪ’dentɪfaɪ]<br>vt. 确定；鉴定；识别，辨认出；使参与；把…看成一样 vi. 确定；认同；一致;<br>vi. 确定；认同；一致<br>637, idiom  [‘ɪdɪəm]<br>n. 成语，习语；土话<br>638, idiomatic  [,ɪdɪə’mætɪk]<br>adj. 惯用的；符合语言习惯的；通顺的<br>639, idle  [‘aɪdl]<br>adj. 闲置的；懒惰的；停顿的 vi. 无所事事；虚度；空转 vt. 虚度；使空转<br>640, Idle  [‘aɪd(ə)l]<br>adj. 闲置的；懒惰的；停顿的;<br>vi. 无所事事；虚度；空转;<br>vt. 虚度；使空转<br>641, ignite  [ɪɡ’naɪt]<br>vt. 点燃；使燃烧；使激动<br>vi. 点火；燃烧<br>642, illegal  [ɪ’liːg(ə)l]<br>n. 非法移民；间谍;adj. [法] 非法的；违法的；违反规则的<br>643, illustrate  [‘ɪləstreɪt]<br>vi. 举例<br>vt. 阐明，举例说明；图解<br>644, immutability  [immutability]<br>n. 不变；永恒性；不变性<br>645, immutable  [ɪ’mjuːtəb(ə)l]<br>adj. 不变的；不可变的；不能变的<br>646, implement  [‘ɪmplɪm(ə)nt]<br>n. 工具，器具；手段<br>vt. 实施，执行；实现，使生效<br>647, implementation  [ɪmplɪmen’teɪʃ(ə)n]<br>n. [计] 实现；履行；安装启用<br>648, implementing  []<br>n. 实施，执行；实现<br>v. 贯彻，执行（implement的现在分词）<br>649, implicit  [ɪm’plɪsɪt]<br>adj. 含蓄的；暗示的；盲从的<br>650, inception  [ɪn’sɛpʃən]<br>n. 起初；获得学位<br>n. 《盗梦空间》（电影名）<br>651, inconvenience  [ɪnkən’viːnɪəns]<br>n. 不便；麻烦;<br>vt. 麻烦；打扰<br>652, incorporate  [ɪn’kɔːpəreɪt]<br>vt. 包含，吸收；体现；把……合并;<br>vi. 合并；混合；组成公司;<br>adj. 合并的；一体化的；组成公司的<br>653, incubator  [‘ɪŋkjʊbeɪtə]<br>n. [禽] 孵卵器；[儿科] 保温箱；早产儿保育器；细菌培养器<br>654, indicate  [‘ɪndɪkeɪt]<br>vt. 表明；指出；预示；象征<br>655, indicating  [‘ɪndɪkeɪtɪŋ]<br>n. 表明；指示<br>v. 表明；指示；要求（indicate的ing形式）<br>adj. 指示的<br>656, indicator  [‘ɪndɪketɚ]<br>n. 指示器；[试剂] 指示剂；[计] 指示符；压力计<br>657, indice<br>n. 指数；标记体<br>658, individual  [ɪndɪ’vɪdjʊ(ə)l]<br>adj. 个人的；个别的；独特的;<br>n. 个人，个体<br>659, individually  [ˌɪndɪˈvɪdʒuəli]<br>adv. 个别地，单独地<br>660, industry  [‘ɪndəstrɪ]<br>n. 产业；工业；勤勉<br>661, inevitably  [ɪ’nevɪtəblɪ; ɪn’evɪtəblɪ]<br>adv. 不可避免地；必然地<br>662, infection  [ɪn’fɛkʃən]<br>n. 感染；传染；影响；传染病<br>663, infer  [ɪn’fɝ]<br>vt. 推断；推论<br>vi. 推断；作出推论<br>664, Infinite  [‘ɪnfɪnət]<br>adj. 无限的，无穷的；无数的；极大的;<br>n. 无限；[数] 无穷大；无限的东西（如空间，时间）<br>665, infrastructure  [‘ɪnfrəstrʌktʃə]<br>n. 基础设施；公共建设；下部构造<br>666, ingest  [ɪn’dʒest]<br>vt. 摄取；咽下；吸收；接待<br>667, ingress  [‘ɪngres]<br>n. 进入；入口；准许进入；入境<br>n. (Ingress)人名；(英)英格雷斯<br>668, inherently  [ɪn’hɪrəntli]<br>adv. 内在地；固有地；天性地<br>669, inhibition  [ɪn(h)ɪ’bɪʃ(ə)n]<br>n. 抑制；压抑；禁止<br>670, Initiative  [ɪ’nɪʃɪətɪv; -ʃə-]<br>n. 主动权；首创精神;<br>adj. 主动的；自发的；起始的<br>671, initiator  [ɪ’nɪʃɪeɪtə]<br>n. 发起人，创始者；教导者；[计] 启动程序；引爆器<br>672, innocent  [‘ɪnəs(ə)nt]<br>adj. 无辜的；无罪的；无知的<br>n. 天真的人；笨蛋<br>n. (Innocent)人名；(英、西)因诺森特；(法)伊诺桑<br>673, inplace<br>n. 原地<br>674, insight  [‘ɪnsaɪt]<br>n. 洞察力；洞悉<br>n. (Insight)人名；(英)因赛特<br>675, inspect  [ɪn’spekt]<br>vt. 检查；视察；检阅;<br>vi. 进行检查；进行视察<br>676, instant  [‘ɪnstənt]<br>adj. 立即的；紧急的；紧迫的<br>n. 瞬间；立即；片刻<br>677, instantaneous  [,ɪnstən’tenɪəs]<br>adj. 瞬间的；即时的；猝发的<br>678, instantiate  [ɪn’stænʃɪeɪt]<br>vt. 例示，举例说明<br>679, instrument  [‘ɪnstrʊm(ə)nt]<br>n. 仪器；工具；乐器；手段；器械<br>680, instrumental  [,ɪnstrə’mɛntl]<br>adj. 乐器的；有帮助的；仪器的，器械的<br>n. 器乐曲；工具字，工具格<br>681, insulation  [ɪnsjʊ’leɪʃ(ə)n]<br>n. 绝缘；隔离，孤立<br>682, intact  [ɪn’tækt]<br>adj. 完整的；原封不动的；未受损伤的<br>683, integrate  [‘ɪntɪgreɪt]<br>vt. 使…完整；使…成整体；求…的积分；表示…的总和;<br>vi. 求积分；取消隔离；成为一体;<br>adj. 整合的；完全的;<br>n. 一体化；集成体<br>684, integration  [ɪntɪ’greɪʃ(ə)n]<br>n. 集成；综合<br>685, Integration  [ɪntɪ’greɪʃ(ə)n]<br>n. 集成；综合<br>686, intense  [ɪn’tɛns]<br>adj. 强烈的；紧张的；非常的；热情的<br>[ 比较级:more intense或 intenser 最高级:most intense或 intensest ]<br>687, intent  [ɪn’tent]<br>n. 意图；目的；含义;<br>adj. 专心的；急切的；坚决的<br>688, intention  [ɪn’tenʃ(ə)n]<br>n. 意图；目的；意向；愈合<br>689, intentionally<br>adv. 故意地，有意地<br>690, interacting  [,ɪntə’rækt]<br>n. 相互作用；相互制约;<br>v. 互相影响；互相作用（interact的ing形式）<br>691, interaction  [ɪntər’ækʃ(ə)n]<br>n. 相互作用；[数] 交互作用<br>n. 互动<br>interaction: 相互作用  交互  交互作用<br>692, interactive  [ɪntər’æktɪv]<br>adj. 交互式的；相互作用的<br>693, Interactive  [ɪntər’æktɪv]<br>adj. 交互式的；相互作用的<br>694, intercept  [,ɪntə’sept]<br>vt. 拦截；截断；窃听;<br>n. 拦截；[数] 截距；截获的情报<br>695, interference  [ɪntə’fɪər(ə)ns]<br>n. 干扰，冲突；干涉<br>696, interleaving<br>n. [计] 交错；交叉</p><p>v. 插入；[计] 交叉存取（interleave的ing形式）<br>697, Intermediate  [,ɪntə’miːdɪət]<br>vi. 起媒介作用;<br>adj. 中间的，中级的;<br>n. [化学] 中间物；媒介<br>698, internally<br>adv. 内部地；国内地；内在地<br>699, Internationalization  [‘ɪntə,næʃənəlaɪ’zeɪʃən]<br>n. 国际化<br>700, Interop<br>n. 交互操作；Interop贸易展示会（每年在美国举办的全球最大的网络专业展览会）<br>701, Interoperability  [‘ɪntər,ɒpərə’bɪlətɪ]<br>n. [计] 互操作性；互用性<br>702, interoperable<br>adj. 彼此协作的；能共同操作的；能共同使用的<br>703, interpolate  [ɪn’tɝpəlet]<br>vt. 篡改；插入新语句<br>vi. 插入；篡改<br>704, interpolation  [ɪn,tɚpə’leʃən]<br>n. 插入；篡改；添写<br>705, Interpretable  [in’tə:prətəbl]<br>adj. 可说明的；可判断的；可翻译的<br>706, interrupt  [ɪntə’rʌpt]<br>vt. 中断；打断；插嘴；妨碍<br>vi. 打断；打扰<br>n. 中断<br>707, interview  [‘ɪntəvjuː]<br>n. 接见，采访；面试，面谈;<br>vt. 采访；接见；对…进行面谈；对某人进行面试<br>708, intoxication  [ɪn,tɒksɪ’keɪʃn]<br>n. [内科] 中毒；陶醉；喝醉<br>709, intrinsic  [ɪn’trɪnsɪk]<br>adj. 本质的，固有的<br>710, introspection  [ɪntrə(ʊ)’spekʃ(ə)n]<br>n. 内省；反省<br>711, introspective  [ɪntrə’spektɪv]<br>adj. 内省的；反省的<br>712, intuitive  [ɪn’tuɪtɪv]<br>adj. 直觉的；凭直觉获知的<br>713, intuitively  [ɪn’tjʊɪtɪvli]<br>adv. 直观地；直觉地<br>714, invariant  [ɪn’vɛrɪənt]<br>adj. 不变的<br>n. [数] 不变量；[计] 不变式<br>715, invasive  [ɪn’veɪsɪv]<br>adj. 侵略性的；攻击性的<br>716, inventory  [‘ɪnv(ə)nt(ə)rɪ]<br>n. 存货，存货清单；详细目录；财产清册<br>717, Inventory  [‘ɪnv(ə)nt(ə)rɪ]<br>n. 存货，存货清单；详细目录；财产清册<br>718, Inversion  [ɪn’vɜːʃ(ə)n]<br>n. 倒置；反向；倒转<br>719, inverted  [ɪn’vɜːtɪd]<br>adj. 倒转的，反向的<br>v. 颠倒（invert的过去分词）；使…反向<br>720, investigate  [ɪn’vestɪgeɪt]<br>v. 调查；研究<br>721, invitation  [ˌɪnvɪˈteɪʃn]<br>n. 邀请；引诱<br>722, invite  [ɪn’vaɪt]<br>vt. 邀请，招待；招致;<br>n. 邀请<br>723, invocation  [,ɪnvə(ʊ)’keɪʃ(ə)n]<br>n. 祈祷；符咒；【法律】(法院对另案的)文件调取；(法权的)行使<br>724, Invocation  [,ɪnvə(ʊ)’keɪʃ(ə)n]<br>n. 祈祷；符咒<br>725, irrespective  [,ɪrɪ’spɛktɪv]<br>adj. 无关的；不考虑的；不顾的<br>726, iteration  [ɪtə’reɪʃ(ə)n]<br>n.[数] 迭代；反复；重复<br>727, iteratively  [‘itə,reitivli]<br>adv. 迭代地；反复地<br>728, iterator  [ɪtə’retɚ]<br>n. 迭代器；迭代程序<br>729, Iterator  [ɪtə’reɪtə]<br>n. 迭代器；迭代程序<br>730, jet  [jɛt]<br>n. 喷射，喷嘴；喷气式飞机；黑玉<br>adj. 墨黑的<br>vt. 射出<br>vi. 射出；[航] 乘喷气式飞机<br>731, journal  [‘dʒɜːn(ə)l]<br>n. 日报，杂志；日记；分类账<br>732, Jumbotron  [‘dʒʌmbəutrɔn]<br>n. 电视机的超大屏幕<br>733, Kestrel  [‘kestr(ə)l]<br>n. （产于欧洲的）茶隼<br>734, kick  [kɪk]<br>n. 踢；反冲，后座力<br>vt. 踢；反冲，朝后座<br>vi. 踢；反冲<br>n. (Kick)人名；(德)基克<br>735, knobs<br>n. 把手（knob的复数）；凸岩<br>736, knuckle  [‘nʌk(ə)l]<br>n. 关节；指关节；指节；膝关节；肘<br>vi. 开始认真工作<br>vt. 用指关节敲打<br>737, lack  [læk]<br>vt. 缺乏；不足；没有；需要;<br>vi. 缺乏；不足；没有;<br>n. 缺乏；不足;<br>n. (Lack)人名；(老)拉；(英、法、意、葡、匈)拉克；(匈)洛克<br>738, landscape  [‘læn(d)skeɪp]<br>n. 风景；风景画；景色；山水画；乡村风景画；地形；（文件的）横向打印格式;<br>vt. 对…做景观美化，给…做园林美化；从事庭园设计;<br>vi. 美化（环境等），使景色宜人；从事景观美化工作，做庭园设计师<br>739, lane  [leɪn]<br>n. 小巷；[航][水运] 航线；车道；罚球区<br>n. (Lane)人名；(英、俄)莱恩；(老)兰；(德、法、意、葡、塞、瑞典)拉内<br>740, Lantern  [‘læntən]<br>n. 灯笼；提灯；灯笼式天窗<br>741, Laptops  []<br>笔记本电脑<br>742, lark  [lɑːk]<br>n. 云雀；百灵鸟；欢乐<br>vi. 骑马玩乐；嬉耍<br>vt. 愚弄<br>n. (Lark)人名；(东南亚国家华语)六<br>743, latch  [lætʃ]<br>vi. 占有，抓住；闭锁<br>vt. 闩上；纠缠住某人<br>n. 门闩<br>n. (Latch)人名；(英)拉奇<br>744, Latch  [lætʃ]<br>vi. 占有，抓住；闭锁;<br>vt. 闩上；纠缠住某人;<br>n. 门闩;<br>n. (Latch)人名；(英)拉奇<br>745, latency  [‘letnsi]<br>n. 潜伏；潜在因素<br>746, latent  [‘letnt]<br>adj. 潜在的；潜伏的；隐藏的<br>747, launching  [‘lɔːntʃɪŋ]<br>n. 发射；下水；创设;<br>v. 发射；发动；开始从事（launch的ing形式）<br>748, lean  [lin]<br>vi. 倾斜；倚靠；倾向；依赖<br>adj. 瘦的；贫乏的，歉收的<br>vt. 使倾斜<br>n. 瘦肉；倾斜；倾斜度<br>n. (Lean)人名；(西)莱安；(柬)连；(英)利恩<br>[ :过去式leaned或 leant 过去分词:leaned或 leant 现在分词:leaning ]<br>749, leap  [lip]<br>vi. 跳，跳跃<br>n. 飞跃；跳跃<br>vt. 跳跃，跳过；使跃过<br>n. (Leap)人名；(法)莱亚<br>750, ledger  [‘ledʒə]<br>n.总账，分户总账；[会计] 分类账；账簿；底账；（手脚架上的）横木<br>n.(Ledger)人名；(英)莱杰<br>751, legacy  [‘legəsɪ]<br>n. 遗赠，遗产<br>752, Legacy  [‘legəsɪ]<br>n. 遗赠，遗产<br>753, lenient  [‘liːnɪənt]<br>adj. 宽大的；仁慈的</p><p>n. (Lenient)人名；(法)勒尼安<br>754, leverage  [‘lɛvərɪdʒ]<br>n. 手段，影响力；杠杆作用；杠杆效率<br>v. 利用；举债经营<br>755, Lexical  [‘leksɪk(ə)l]<br>adj. 词汇的；[语] 词典的；词典编纂的<br>756, lexicographically  </p><p>757, line up<br>排列起；整队<br>758, linguistic  [lɪŋ’gwɪstɪk]<br>adj. 语言的；语言学的<br>759, literal  [‘lɪt(ə)r(ə)l]<br>adj. 文字的；逐字的；无夸张的<br>760, loan  [ləʊn]<br>n. 贷款；借款<br>vi. 借出<br>vt. 借；借给<br>761, lobster  [‘lɒbstə]<br>n. 龙虾<br>龙虾肉<br>762, lockup  [‘lɒkʌp]<br>n. 拘留所，监狱；锁住；监禁<br>763, looks up  </p><p>764, lookup  [‘lʊkʌp]<br>n. 查找；检查<br>765, loop  [luːp]<br>vi. 打环；翻筋斗;<br>n. 环；圈；弯曲部分；翻筋斗;<br>vt. 使成环；以环连结；使翻筋斗<br>766, Loop  [luːp]<br>vi. 打环；翻筋斗;<br>n. 环；圈；弯曲部分；翻筋斗;<br>vt. 使成环；以环连结；使翻筋斗<br>767, loopback  [loopback]<br>n. [计] 回送；回路<br>768, luggage  [‘lʌgɪdʒ]<br>n. 行李；皮箱<br>769, lumberjack  [‘lʌmbədʒæk]<br>n. 伐木工人；木材商的佣工；短茄克衫<br>770, macro  [‘mækro]<br>adj. 巨大的，大量的<br>n. 宏，巨（计算机术语）<br>n. (Macro)人名；(意)马克罗<br>771, malformed  [,mæl’fɔrmd]<br>adj. 畸形的，难看的<br>772, malicious  [mə’lɪʃəs]<br>adj. 恶意的；恶毒的；蓄意的；怀恨的<br>773, malware<br>n. 恶意软件<br>774, mandatory  [‘mændət(ə)rɪ]<br>adj. 强制的；托管的；命令的</p><p>n. 受托者（等于mandatary）<br>775, manifest  [‘mænɪfest]<br>vt. 证明，表明；显示<br>vi. 显示，出现<br>n. 载货单，货单；旅客名单<br>adj. 显然的，明显的；明白的<br>776, manipulate  [mə’nɪpjʊleɪt]<br>vt. 操纵；操作；巧妙地处理；篡改<br>777, Manipulation  [mə,nɪpjʊ’leɪʃ(ə)n]<br>n. 操纵；操作；处理；篡改<br>778, manner  [‘mænə]<br>n. 方式；习惯；种类；规矩；风俗;<br>n. (Manner)人名；(德、芬、瑞典)曼纳<br>779, manufacture  [mænjʊ’fæktʃə]<br>n. 制造；产品；制造业<br>vt. 制造；加工；捏造<br>vi. 制造<br>780, margin  [‘mɑːdʒɪn]<br>n. 边缘；利润，余裕；页边的空白;<br>vt. 加边于；加旁注于;<br>n. (Margin)人名；(俄、意)马尔金<br>781, marginally  [‘mɑrdʒɪnəli]<br>adv. 少量地；最低限度地；在栏外；在页边<br>782, Markup  [‘mɑːkʌp]<br>n. 涨价；利润；审定;<br>n. (Markup)人名；(捷、匈)马尔库普<br>783, marshall<br>n. 元帅；典礼官；执法官；法官的随行官员（等于judge’s marshal）<br>vt. 安排；引领；统帅<br>vi. 各就各位；按次序排列成形（等于marshal）<br>784, marshalled  [marshalled]<br>整理（marshal的过去式与过去分词形式）<br>使排列（marshal的过去式与过去分词形式）<br>785, maskable<br>adj. 可屏蔽的<br>786, master  [‘mɑːstə]<br>vt. 控制；精通；征服;<br>n. 硕士；主人；大师；教师;<br>adj. 主人的；主要的；熟练的;<br>n. (Master)人名；(英)马斯特<br>787, mate  [meɪt]<br>n. 助手，大副；配偶；同事；配对物<br>vt. 使配对；使一致；结伴<br>vi. 交配；成配偶；紧密配合<br>n. (Mate)人名；(日)蛏(姓)；(西、意、塞)马特；(波黑)马特；(罗、俄)马泰<br>788, material  [mə’tɪrɪəl]<br>adj. 重要的；物质的，实质性的；肉体的<br>n. 材料，原料；物资；布料<br>789, matrix  [‘metrɪks]<br>n. [数] 矩阵；模型；[生物][地质] 基质；母体；子宫；[地质] 脉石<br>790, Matrix  [‘meɪtrɪks]<br>n. [数] 矩阵；模型；[生物][地质] 基质；母体；子宫；[地质] 脉石<br>791, mean  [min]<br>adj. 平均的；卑鄙的；低劣的；吝啬的<br>vt. 意味；想要；意欲<br>n. 平均值<br>vi. 用意<br>n. (Mean)人名；(柬)棉<br>792, Measurable  [‘meʒ(ə)rəb(ə)l]<br>adj. 可测量的；重要的；重大的<br>793, mechanism  [‘mek(ə)nɪz(ə)m]<br>n. 机制；原理，途径；进程；机械装置；技巧<br>794, mechanisms  [‘mɛkənɪzəmz]<br>n. 机制；[机] 机构（mechanism的复数）；机械；[机] 机构学<br>795, median  [‘midɪən]<br>n. n. 中值，中位数；三角形中线；梯形中位线<br>adj. 中值的；中央的<br>n. (Median)人名；(阿拉伯)迈迪安；(罗)梅迪安<br>796, mediocre  [,miːdɪ’əʊkə]<br>adj. 普通的；平凡的；中等的<br>797, mediocrity  [miːdɪ’ɒkrɪtɪ]<br>n. 平庸之才；平常<br>798, mega  [‘mɛɡə]<br>n. 百万<br>adj. 许多；宏大的<br>adv. 非常<br>n. (Mega)人名；(葡、意、捷、塞)梅加<br>799, megabyte  [‘megəbaɪt]<br>n. [计] 兆字节<br>800, melon  [‘melən]<br>n. 瓜；甜瓜；大肚子；圆鼓鼓像瓜似的东西</p><p>n. (Melon)人名；(意、西、葡)梅隆<br>801, memorization  [,mɛmərɪ’zeʃən]<br>n. 记住；暗记<br>802, mentor  [‘mɛn’tɔr]<br>n. 指导者，良师益友;<br>vt. 指导<br>803, merchant  [‘mɝtʃənt]<br>n. 商人，批发商；店主<br>adj. 商业的，商人的<br>n. (Merchant)人名；(英)麦钱特<br>804, merry  [‘mɛri]<br>adj. 愉快的；微醉的；嬉戏作乐的 n. 甜樱桃 n. (Merry)人名；(英、法、西)梅里<br>805, mesh  [mɛʃ]<br>n. 网眼；网丝；圈套<br>vi. 相啮合<br>vt. [机] 啮合；以网捕捉<br>806, mess  [mes]<br>n.混乱；食堂，伙食团；困境；脏乱的东西<br>vt.弄乱，弄脏；毁坏；使就餐<br>vi.把事情弄糟；制造脏乱；玩弄<br>n.(Mess)人名；(德、罗)梅斯<br>807, messy  [‘mesɪ]<br>adj. 凌乱的，散乱的；肮脏的，污秽的；麻烦的<br>808, metric  [‘mɛtrɪk]<br>adj. 公制的；米制的；公尺的<br>n. 度量标准<br>809, metrics  [‘mɛtrɪks]<br>n. 度量；作诗法；韵律学<br>810, Metrics  [‘metrɪks]<br>n. 度量；作诗法；韵律学<br>811, migrate  [maɪ’greɪt; ‘maɪgreɪt]<br>vi. 移动；随季节而移居；移往<br>vt. 使移居；使移植<br>812, Migrate  [maɪ’greɪt; ‘maɪgreɪt]<br>vi. 移动；随季节而移居；移往;<br>vt. 使移居；使移植<br>813, migration  [maɪ’greɪʃ(ə)n]<br>n. 迁移；移民；移动<br>814, milestones<br>n. 里程碑；时间表<br>815, mimic  [‘mɪmɪk]<br>vt. 模仿，摹拟<br>n. 效颦者，模仿者；仿制品；小丑<br>adj. 模仿的，模拟的；假装的<br>816, mind  [maɪnd]<br>n. 理智，精神；意见；智力；记忆力<br>vt. 介意；专心于；照料<br>vi. 介意；注意<br>817, minify  [‘mɪnɪfaɪ]<br>vt. 使变小；贬低<br>818, minor  [‘maɪnə]<br>adj. 未成年的；次要的；较小的；小调的；二流的;<br>n. 未成年人；小调；副修科目;<br>vi. 副修;<br>n. (Minor)人名；(英)迈纳；(德、法、波、俄)米诺尔<br>819, Misc  [‘mɪsk]<br>abbr. 混杂的；各色各样混在一起；多才多艺的（miscellaneous）<br>820, miscellaneous  [‘mɪsə’lenɪəs]<br>adj. 混杂的，各种各样的；多方面的，多才多艺的<br>821, misconception  [mɪskən’sepʃ(ə)n]<br>n. 误解；错觉；错误想法<br>822, misfire  [‘mɪs’faɪr]<br>vi. 失败；不发火<br>n. 失败；不发火<br>823, mitigated  [‘mɪtɪgeɪt]<br>vt. 使缓和，使减轻</p><p>vi. 减轻，缓和下来<br>824, mitigation  [mɪtɪ’geɪʃ(ə)n]<br>n. 减轻；缓和；平静<br>825, mix  [mɪks]<br>vt. 配制；混淆；使混和；使结交<br>vi. 参与；相混合；交往<br>n. 混合；混合物；混乱<br>n. (Mix)人名；(德、英)米克斯<br>826, mock  [mɒk]<br>n. 英国模拟考试（mocks）<br>vt. 愚弄，嘲弄<br>adj. 仿制的，模拟的，虚假的，不诚实的<br>vt. 不尊重，蔑视<br>827, Modal  [‘məʊd(ə)l]<br>adj. 模式的；情态的；形式的;<br>n. 莫代尔（一种新型纤维素纤维）<br>828, Mon amour  []<br>我的爱<br>829, monial  [‘məuniəl]<br>n.竖框（等于mullion）<br>830, monolith  [‘mɒn(ə)lɪθ]<br>n. 整块石料；庞然大物<br>831, monolithic  [mɒnə’lɪθɪk]<br>adj. 整体的；巨石的，庞大的；完全统一的</p><p>n. 单块集成电路，单片电路<br>832, monopolize  [mə’nɑpə’laɪz]<br>vt. 垄断；独占；拥有…的专卖权<br>833, monotonically  [mɒnə’tɒnɪklɪ]<br>adv. 单调地<br>834, monotonicity  [,mɔnətə’nisəti]<br>n. [数] 单调性<br>835, mood  [muːd]<br>n. 情绪，语气；心境；气氛;n. (Mood)人名；(英)穆德；(瑞典)莫德<br>836, Moreover  [mɔːr’əʊvə]<br>adv. 而且；此外<br>837, mount  [maʊnt]<br>vt. 增加；爬上；使骑上马；安装，架置；镶嵌，嵌入；准备上演；成立（军队等）;<br>vi. 爬；增加；上升;<br>n. 山峰；底座；乘骑用马；攀，登；运载工具；底座;<br>n. （英）芒特（人名）;<br>v. 登上；骑上<br>838, mprotect  </p><p>839, mule  [mjuːl]<br>n. 骡；倔强之人，顽固的人；杂交种动物;<br>n. (Mule)人名；(意)穆莱；(英)米尔<br>840, multiplexer  [‘mʌltɪ,plɛksɚ]<br>n. [计][通信] 多工器；多路器；[通信] 多路转接器<br>841, multiplicity  [,mʌltɪ’plɪsəti]<br>n. 多样性；[物] 多重性<br>842, mutable  [‘mjutəbl]<br>adj. 易变的，不定的；性情不定的<br>843, mutate  [‘mjutet]<br>vi. 变化，产生突变<br>vt. 改变，使突变<br>844, mutative  [‘mjuːtətɪv]<br>adj. 变化的；生物突变的<br>845, mutator  [‘mju:teitə]<br>n. 增变基因<br>846, mute  [mjuːt]<br>adj. 哑的；沉默的；无声的;<br>vt. 减弱……的声音；使……柔和;<br>n. 哑巴；弱音器；闭锁音;<br>n. (Mute)人名；(塞)穆特<br>847, mutex  []<br>n. 互斥；互斥元，互斥体；互斥量<br>848, mutual  [‘mjutʃuəl]<br>adj. 共同的；相互的，彼此的<br>849, mutually  [ˈmjuːtʃuəli]<br>adv. 互相地；互助<br>850, negate  [nɪ’geɪt]<br>vt. 否定；取消；使无效;<br>vi. 否定；否认；无效;<br>n. 对立面；反面<br>851, negligible  [‘neglɪdʒɪb(ə)l]<br>adj. 微不足道的，可以忽略的<br>852, Negotiate  [nɪ’gəʊʃɪeɪt]<br>vt. 谈判，商议；转让；越过;<br>vi. 谈判，交涉<br>853, nest  [nest]<br>n. 巢，窝；安乐窝；温床;<br>vt. 筑巢；嵌套;<br>vi. 筑巢；找鸟巢;<br>n. (Nest)人名；(德)内丝特；(英)内丝特(女子教名 Agnes 威尔士语的昵称)<br>854, newbie  [‘njuːbɪ]<br>n. 网络新手；新兵<br>855, nick  [nɪk]<br>vt. 刻痕于；挑毛病；用刻痕记 n. 刻痕；缺口 vi. 刻痕；狙击<br>856, nimbus  [‘nɪmbəs]<br>n. （人和物产生的）灵气；光轮；[气象] 雨云；光辉灿烂的气氛<br>857, noisy  [ˈnɔɪzɪ]<br>adj. 嘈杂的；喧闹的；聒噪的<br>n. 响声；嘈杂声<br>858, nonce  [nɒns]<br>n. 目前；特定场合；强奸犯</p><p>adj. 临时的；特定场合的<br>859, nope  [nəʊp]<br>adv. 不是，没有；不<br>860, norm  [nɔrm]<br>n. 标准，规范<br>861, notably  [‘notəbli]<br>adv. 显著地；尤其<br>862, notation  [no’teʃən]<br>n. 符号；乐谱；注释；记号法<br>863, Notation  [nəʊ’teɪʃ(ə)n]<br>n. 符号；乐谱；注释；记号法<br>864, noticeable  [‘nəʊtɪsəb(ə)l]<br>adj. 显而易见的，显著的；值得注意的<br>865, notoriously  [noˈtɔːriəsli]<br>adv. 众所周知地；声名狼藉地；恶名昭彰地<br>866, noverflow  </p><p>867, obey  [ə’be]<br>vt. 服从，听从；按照……行动<br>vi. 服从，顺从；听话<br>n. (Obey)人名；(英、法)奥贝<br>868, obligation  [,ɑblɪ’ɡeʃən]<br>n. 义务；职责；债务<br>869, observer  [əb’zɜːvə]<br>n. 观察者；[天] 观测者；遵守者<br>870, obsession  [əb’seʃ(ə)n]<br>n. 痴迷；困扰；[内科][心理] 强迫观念<br>871, obtain  [əb’teɪn]<br>vi. 获得；流行;<br>vt. 获得<br>872, obtuse  [əb’tjuːs]<br>adj. 迟钝的；圆头的；不锋利的<br>873, occupied  [‘ɒkjʊpaɪd]<br>adj. 已占用的；使用中的；无空闲的<br>v. 占有（occupy的过去分词）<br>874, occurrence  [ə’kʌr(ə)ns]<br>n. 发生；出现；事件；发现<br>875, odevity  [odevity]<br>奇偶性<br>876, offloading  []<br>n. 卸载；卸货;<br>vt. 卸载（offload的现在分词形式）<br>877, omit  [ə(ʊ)’mɪt]<br>vt. 省略；遗漏；删除；疏忽<br>878, Onboarding<br>adv. 在船上；在飞机上；在板上<br>adj. 随车携带的<br>879, onset  [‘ɑnsɛt]<br>n. 开始，着手；发作；攻击，进攻<br>880, onwards  [‘ɒnwədz]<br>adv. 向前；在前面<br>881, opaque  [o’pek]<br>adj. 不透明的；不传热的；迟钝的<br>n. 不透明物<br>vt. 使不透明；使不反光<br>882, opinion  [ə’pɪnjən]<br>n. 意见；主张<br>883, opinionated  [ə’pɪnjənetɪd]<br>adj. 固执己见的；武断的<br>884, optimized  [‘ɒptɪmaɪzd]<br>adj. 最佳化的；尽量充分利用<br>885, optimizer  [‘ɒptɪmaɪzə]<br>n. [计] 优化程序；最优控制器<br>886, orchestrating<br>精心策划</p><p>给 … 配管弦乐曲</p><p>使协调地结合在一起<br>887, orchestration  [,ɔkɛs’treʃən]<br>n. 管弦乐编曲；和谐的结合<br>888, orchestrator<br>n. 管弦乐演奏家；管弦乐编曲家<br>889, ordinarily  [‘ɔːd(ə),n(ə)rɪlɪ; ,ɔːdɪ’nerɪlɪ]<br>adv. 通常地；一般地<br>890, Oriented  [‘ɔːrɪentɪd]<br>adj. 导向的；定向的；以…为方向的;<br>v. 调整；使朝向（orient的过去分词）；确定…的方位<br>891, orphans  [‘ɔrfən]<br>n. 孤儿（orphan的复数）<br>v. 成为孤儿（orphan的三单形式）<br>892, outage  [‘aʊtɪdʒ]<br>n. 储运损耗；中断供应；运行中断<br>893, outgoing  [‘aʊtgəʊɪŋ]<br>adj. 对人友好的，开朗的；出发的，外出的；即将离职的；乐于助人的;<br>n. 外出；流出；开支;<br>v. 超过；优于（outgo的ing形式）<br>894, outnumber  [aʊt’nʌmbə]<br>vt. 数目超过；比…多<br>895, outright  [‘aʊtraɪt]<br>adv. 全部地；立刻地；率直地；一直向前；痛快地<br>adj. 完全的，彻底的；直率的；总共的<br>896, outstanding  [aʊt’stændɪŋ]<br>adj. 杰出的；显著的；未解决的；未偿付的;<br>n. 未偿贷款<br>897, overlap  [əʊvə’læp]<br>n. 重叠；重复</p><p>vi. 部分重叠；部分的同时发生</p><p>vt. 与…重叠；与…同时发生<br>898, overlay  [‘ovəlɛi]<br>n. 覆盖图；覆盖物<br>vt. 在表面上铺一薄层，镀<br>899, overpopulate  [əʊvə’pɒpjʊleɪt]<br>vt. 使人口过剩；使人口过密<br>900, overwhelm  [ovɚˈhwɛlm]<br>vt. 淹没；压倒；受打击；覆盖；压垮<br>901, pacesetter  [‘pessɛtɚ]<br>n. 标兵；先导者，步调调整者<br>902, pad  [pæd]<br>n. 衬垫；护具；便笺簿；填补<br>vi. 步行；放轻脚步走<br>vt. 填补；走<br>n. (Pad)人名；(英)帕德(男子教名 Patrick 的昵称)<br>903, padding  [‘pædɪŋ]<br>n. 填料；垫料;<br>v. 填补（pad的ing形式）<br>904, paddle  [‘pædl]<br>n. 划桨；明轮翼<br>vt. 拌；搅；用桨划<br>vi. 划桨；戏水；涉水<br>905, padlock  [‘pædlɒk]<br>n. 挂锁；关闭；禁止进入;<br>vt. 用挂锁锁上；关闭<br>906, Page View<br>访问量<br>907, Pagination  [,pædʒɪ’neɪʃ(ə)n]<br>n. 标记页数；页码<br>908, painful  [‘penfl]<br>adj. 痛苦的；疼痛的；令人不快的<br>909, palette  [‘pælət]<br>n. 调色板；颜料<br>n. (Palette)人名；(法)帕莱特<br>910, pampas  [‘pæmpəs]<br>n. 草原；蒲苇（pampa的复数形式）<br>n. (Pampas)人名；(瑞典)潘帕斯<br>911, pan  [美/pæn/]<br>n. 平底锅；盘状的器皿；淘盘子，金盘，秤盘;<br>vt. 淘金；在浅锅中烹调（食物）；[非正式用语]严厉的批评;<br>vi. 淘金；在淘洗中收获金子;<br>912, pane  [peɪn]<br>n. 窗格；边；面；窗格玻璃；嵌板;<br>vt. 装窗玻璃于；镶嵌板于;<br>n. (Pane)人名；(老)班；(英)潘恩；(德、西、意、塞、印尼)帕内<br>913, panic  [‘pænɪk]<br>n. 恐慌，惊慌；大恐慌;<br>adj. 恐慌的；没有理由的;<br>vt. 使恐慌;<br>vi. 十分惊慌;<br>n. (Panic)人名；(罗)帕尼克<br>914, paradise  [‘pærədaɪs]<br>n. 天堂<br>至福境地<br>915, Paradise  [‘pærədaɪs]<br>n. 天堂;<br>至福境地<br>916, paramount  [‘pærəmaʊnt]<br>adj. 最重要的，主要的；至高无上的</p><p>n. 最高统治者<br>917, parasitic  [,pærə’sɪtɪk]<br>adj. 寄生的（等于parasitical）<br>918, parentheses  [pə’rɛnθəsɪz]<br>n. parenthesis的复数形式<br>919, parenthesis  [pə’rɛnθəsɪs]<br>n. 插入语,插入成分<br>n. 圆括号<br>n. 间歇，插曲<br>920, parlance  [‘pɑːl(ə)ns]<br>n. 说法；用语；语调；发言<br>921, participant  [pɑː’tɪsɪp(ə)nt]<br>n. 参与者；关系者<br>adj. 参与的；有关系的<br>922, passenger  [‘pæsɪndʒə]<br>n. 旅客；乘客；过路人；碍手碍脚的人<br>923, passive  [‘pæsɪv]<br>adj. 被动的，消极的；被动语态的</p><p>n. 被动语态<br>924, passphrase  [passphrase]<br>n. 密码；通行码；口令短语<br>925, peculiar  [pɪ’kjulɪɚ]<br>adj. 特殊的；独特的；奇怪的；罕见的<br>n. 特权；特有财产<br>926, peek  [pik]<br>n. 偷看；一瞥，看一眼<br>vi. 窥视，偷看<br>n. (Peek)人名；(英)皮克<br>927, peer  [pɪə]<br>n. 贵族；同等的人；同龄人</p><p>vi. 凝视，盯着看；窥视</p><p>vt. 封为贵族；与…同等</p><p>n. (Peer)人名；(英、巴基)皮尔<br>928, pending  [‘pendɪŋ]<br>adj. 未决定的；行将发生的;<br>prep. 在…期间；直到…时为止；在等待…之际;<br>v. 待定；悬而不决（pend的ing形式）;<br>n. (Pending)人名；(瑞典)彭丁<br>929, Pending  []</p><p>930, percentile  [pɚ’sɛntaɪl]<br>adj. 百分率的；按百等分排列的<br>n. 百分位<br>931, percolate  [‘pɜːkəleɪt]<br>vi. 过滤；渗出；浸透</p><p>vt. 使渗出；使过滤</p><p>n. 滤过液；渗出液<br>932, percolator  [‘pɜːkəleɪtə]<br>n. 过滤器；渗滤器；咖啡渗滤壶<br>933, perform  [pə’fɔːm]<br>vt. 执行；完成；演奏<br>vi. 执行，机器运转；表演<br>perform: 执行  表演  履行<br>934, Perform  [pə’fɔːm]<br>vt. 执行；完成；演奏;<br>vi. 执行，机器运转；表演<br>935, performance  [pə’fɔːm(ə)ns]<br>n. 性能；绩效；表演；执行<br>936, performing  [pə’fɔːmɪŋ]<br>v. 表演（perform的ing形式）；履行<br>adj. 表演的；履行的<br>performing: 执行  表演性  表现<br>937, period  [‘pɪərɪəd]<br>n. 周期，期间；时期；月经；课时；（语法学）句点，句号</p><p>adj. 某一时代的<br>938, periodic  [,pɪərɪ’ɒdɪk]<br>adj. 周期的；定期的<br>939, periodically  [pɪrɪˈɑdɪklɪ]<br>adv. 定期地；周期性地；偶尔；间歇<br>940, peripheral  [pə’rɪfərəl]<br>adj. 外围的；次要的；（神经）末梢区域的<br>n. 外部设备<br>941, permanent  [‘pɜːm(ə)nənt]<br>adj.永久的，永恒的；不变的<br>n.烫发（等于permanent wave）<br>942, permission  [pə’mɪʃ(ə)n]<br>n. 允许，许可<br>943, Permission  [pə’mɪʃ(ə)n]<br>n. 允许，许可<br>944, permutation  [‘pɝmjʊ’teʃən]<br>n. [数] 排列；[数] 置换<br>945, perpetual  [pɚ’pɛtʃuəl]<br>adj. 永久的；不断的；四季开花的；无期限的<br>946, personality  [pɜːsə’nælɪtɪ]<br>n. 个性；品格；名人<br>947, perspective  [pə’spektɪv]<br>n. 观点；远景；透视图;<br>adj. 透视的<br>948, pertain  [pə’teɪn]<br>vi. 属于；关于；适合<br>949, phantom  [‘fæntəm]<br>n. 幽灵；幻影；虚位</p><p>adj. 幽灵的；幻觉的；有名无实的<br>950, Phantom  [‘fæntəm]<br>n. 幽灵；幻影；虚位;<br>adj. 幽灵的；幻觉的；有名无实的<br>951, phase  [feɪz]<br>n. 相；阶段；[天] 位相;<br>vt. 使定相；逐步执行;<br>vi. 逐步前进<br>952, phases  [‘feɪsiːz]<br>n. 阶段，时期（phase的复数形式）;<br>v. 逐步实行（phase的三单形式）<br>953, philosophies  [fɪ’lɒsəfɪ]<br>n. 哲学；哲理；人生观<br>954, phrase  [frez]<br>n. 短语, 习语, 措辞, 乐句<br>vt. 措词, 将(乐曲)分成乐句<br>955, PHRASE  [freɪz]<br>n. 短语, 习语, 措辞, 乐句;<br>vt. 措词, 将(乐曲)分成乐句<br>956, pier  [pɪr]<br>n. 码头，直码头；桥墩；窗间壁<br>n. (Pier)人名；(英、德)皮尔；(西)彼尔；(意)皮耶尔<br>957, piggyback  [‘pɪɡɪbæk]<br>adj. 背着的；[航] 在背肩上的<br>adv. 在背肩上<br>n. 肩扛；背负式运输<br>vt. 背负式装运<br>958, pilot  [kə’lekt]<br>vt. 收集；募捐<br>vi. 收集；聚集；募捐<br>adv. 由收件人付款地<br>adj. 由收件人付款的<br>n. (Collect)人名；(英)科莱克特<br>959, pin  [pɪn]<br>n. 大头针，别针，针；栓；琐碎物<br>vt. 钉住；压住；将……用针别住<br>960, pinned  [‘pind]<br>adj. 用针别住的；被压制的<br>v. 牵制；用针别住；刺穿（pin的过去分词）<br>961, pipeline  [‘paɪplaɪn]<br>n. 管道；输油管；传递途径<br>过去式:pipelined; 过去分词:pipelined; 现在分词:pipelining<br>962, placement  [‘pleɪsmənt]<br>n. 布置；定位球；人员配置<br>963, plain  [plen]<br>adj. 平的；简单的；朴素的；清晰的<br>n. 平原；无格式；朴实无华的东西<br>adv. 清楚地；平易地<br>n. (Plain)人名；(英)普莱恩；(法)普兰<br>964, planet  [‘plænɪt]<br>n. 行星<br>n. (Planet)人名；(法)普拉内；(西、葡)普拉内特<br>965, Plastic  [‘plæstɪk]<br>adj. 塑料的；（外科）造型的；可塑的<br>n. 塑料制品；整形；可塑体<br>966, plenty  [‘plentɪ]<br>n. 丰富，大量；充足;<br>adj. 足够的，很多的;<br>adv. 足够;<br>n. (Plenty)人名；(英)普伦蒂<br>967, plot  [plɑt]<br>n. 情节；图；阴谋<br>vt. 密谋；绘图；划分；标绘<br>vi. 密谋；策划；绘制<br>n. (Plot)人名；(捷)普洛特；(法)普洛<br>968, plotted  [plotted]<br>adj. 标绘的<br>v. 策划（plot的过去分词）；划分；绘制…的地图<br>969, plug  [plʌg]<br>n. 插头；塞子；栓;<br>vi. 塞住；用插头将与电源接通;<br>vt. 插入；塞住；接插头<br>970, plug in  []<br>插入；插上电源<br>971, pluggable  [plʌgəbl]<br>adj. 插接式连接，[电] 可插的<br>972, Pluggable  [plʌgəbl]<br>adj. 插接式连接，[电] 可插的<br>973, Plugin  [plʌgɪn]<br>n. 插件；相关插件;<br>n. (Plugin)人名；(俄)普卢金<br>974, plural  [‘plʊrəl]<br>adj. 复数的<br>n. 复数<br>975, poet  [‘pəʊɪt]<br>n. 诗人<br>976, poetry  [‘pəʊɪtrɪ]<br>n. 诗；诗意，诗情；诗歌艺术<br>977, poison  [‘pɔɪzn]<br>vt. 污染；使中毒，放毒于；败坏；阻碍<br>vi. 放毒，下毒<br>n. 毒药，毒物；酒；有毒害的事物；[助剂] 抑制剂<br>adj. 有毒的<br>n. (Poison)人名；(西)波伊松<br>978, polar  [‘pəʊlə]<br>adj. 极地的；两极的；正好相反的</p><p>n. 极面；极线</p><p>n. (Polar)人名；(德、西)波拉尔<br>979, pollution  [pə’luʃən]<br>n. 污染<br>污染物<br>980, polymorphism  [,pɑlɪ’mɔrfɪzm]<br>n. 多态性；多形性；同质多晶<br>981, popover  [‘pɒpəʊvə]<br>n. 一种淡烤的酥饼<br>982, populated  [ˈpɑːpjuleɪtid]<br>adj. 粒子数增加的;<br>v. 居住于…中；构成…的人口（populate的过去分词）<br>983, portable  [‘pɔrtəbl]<br>adj. 手提的，便携式的；轻便的<br>n. 手提式打字机<br>984, portal  [‘pɔːt(ə)l]<br>n. 大门，入口;<br>n. (Portal)人名；(法、西、葡)波塔尔；(英)波特尔<br>985, portion  [‘pɔːʃ(ə)n]<br>n. 部分；一份；命运</p><p>vt. 分配；给…嫁妆<br>986, portrait  [‘pɔrtrɪt]<br>n. 肖像；描写；半身雕塑像<br>n. (Portrait)人名；(法)波特雷<br>987, postpone  [pəʊs(t)’pəʊn; pə’spəʊn]<br>vt. 使…延期；把…放在次要地位；把…放在后面;<br>vi. 延缓，延迟；延缓发作<br>988, pot  [美/pɑt/]<br>n. 壶；盆；罐;<br>vt. 把…装罐；射击；节略;<br>vi. 随手射击;<br>n. (Pot)人名；(柬)布特；(捷)波特；(法)波;<br>989, potentially  [pə’tɛnʃəli]<br>adv.可能地，潜在地<br>990, practical  [‘præktɪk(ə)l]<br>adj. 实际的；实用性的<br>991, pragmatic  [præg’mætɪk]<br>adj. 实际的；实用主义的；国事的<br>992, prank  [præŋk]<br>n. 恶作剧，开玩笑；戏谑;<br>vt. 装饰；打扮;<br>vi. 炫耀自己；胡闹<br>993, precaution  [prɪ’kɔːʃ(ə)n]<br>n. 预防，警惕；预防措施;<br>vt. 警惕；预先警告<br>994, precede  [prɪ’siːd]<br>vt. 领先，在…之前；优于，高于;<br>vi. 领先，在前面<br>995, precedence  [‘presɪd(ə)ns; prɪ’siːd(ə)ns]<br>n. 优先；居先<br>996, precision  [prɪ’sɪʒn]<br>n. 精度，[数] 精密度；精确<br>adj. 精密的，精确的<br>997, preclude  [prɪ’kluːd]<br>vt. 排除；妨碍；阻止<br>998, predecessor  [‘priːdɪsesə]<br>n. 前任，前辈<br>999, predictability  [pri,diktə’biliti]<br>n. 可预测性；可预言<br>1000, preempt  [,primpt]<br>vt. 先占；先取；以先买权获得<br>1001, preference  [‘pref(ə)r(ə)ns]<br>n. 偏爱，倾向；优先权<br>1002, prefetch  [prefetch]<br>v. 预取<br>1003, preliminary  [prɪ’lɪmɪn(ə)rɪ]<br>n. 准备；预赛；初步措施<br>adj. 初步的；开始的；预备的<br>1004, premiered  []<br>（戏剧、电影等）首次公演（premiere的过去式和过去分词）<br>1005, premises  [‘premɪsɪz]<br>n.前提；经营场址；上述房屋；契约前言（premise的复数） v.提出…为前提；预述（premise的第三人称单数）<br>1006, premium  [‘priːmɪəm]<br>n. 额外费用；奖金；保险费;(商)溢价;<br>adj. 高价的；优质的<br>1007, preppy  [‘prɛpi]<br>n. 预科生（等于preppie）<br>1008, prerequisite  [priː’rekwɪzɪt]<br>n. 先决条件;<br>adj. 首要必备的<br>1009, present  [‘prez(ə)nt]<br>vt. 提出；介绍；呈现；赠送;<br>vi. 举枪瞄准;<br>adj. 现在的；出席的;<br>n. 现在；礼物；瞄准<br>1010, presentation  [prez(ə)n’teɪʃ(ə)n]<br>n. 展示；描述，陈述；介绍；赠送<br>1011, Presentation  [prez(ə)n’teɪʃ(ə)n]<br>n. 描述，陈述；介绍；赠送<br>1012, presenter  [prɪ’zɛntɚ]<br>n. 提出者；推荐者；赠送者；任命者；主持人<br>1013, prevent  [prɪ’vent]<br>vt. 预防，防止；阻止;<br>vi. 妨碍，阻止<br>1014, primary  [‘praɪmɛri]<br>adj. 主要的；初级的；基本的<br>n. 原色；最主要者<br>1015, Primordial  [praɪ’mɔːdɪəl]<br>adj. 原始的；根本的；原生的<br>1016, principal  [‘prɪnsəp(ə)l]<br>adj. 主要的；资本的;<br>n. 首长；校长；资本；当事人<br>1017, Principal  [‘prɪnsəp(ə)l]<br>adj. 主要的；资本的;<br>n. 首长；校长；资本；当事人<br>1018, principle  [‘prɪnsɪp(ə)l]<br>n. 原理，原则；主义，道义；本质，本义；根源，源泉<br>1019, Principle  [‘prɪnsɪp(ə)l]<br>n. 原理，原则；主义，道义；本质，本义；根源，源泉<br>1020, principle engineer<br>【网络】首席工程师<br>1021, priority  [praɪ’ɔrəti]<br>n. 优先；优先权；[数] 优先次序；优先考虑的事<br>1022, Priority  [praɪ’ɒrɪtɪ]<br>n. 优先；优先权；[数] 优先次序；优先考虑的事<br>1023, proactive  [prəʊ’æktɪv]<br>adj. 前摄的（前一活动中的因素对后一活动造成影响的）；有前瞻性的，先行一步的；积极主动的<br>1024, probe  [prəʊb]<br>n. 探针；调查<br>vi. 调查；探测<br>vt. 探查；用探针探测<br>n. (Probe)人名；(法)普罗布<br>1025, proceed  [pro’sid]<br>vi. 开始；继续进行；发生；行进<br>n. 收入，获利<br>1026, Processing  [‘prɑsɛs]<br>v. 加工；[自] 处理；对…起诉（process的ing形式）<br>1027, Processors  [prɔ:’sesəz]<br>n. [计] 处理器，[计] 处理机（processor复数）<br>1028, profile  [‘profaɪl]<br>n. 侧面；轮廓；外形；剖面；简况<br>vt. 描…的轮廓；扼要描述<br>vi. 给出轮廓<br>1029, profiled  []<br>v.描绘…轮廓，评论人物（profile的过去式）<br>1030, progressively  [prə’ɡrɛsɪvli]<br>adv. 渐进地；日益增多地<br>1031, projection  [prə’dʒɛkʃən]<br>n. 投射；规划；突出；发射；推测<br>1032, promote  [prə’məʊt]<br>vt. 促进；提升；推销；发扬<br>vi. 成为王后或其他大于卒的子<br>1033, pronounce  [prə’naʊns]<br>vt. 发音；宣判；断言;<br>vi. 发音；作出判断<br>1034, propagation  [,prɒpə’ɡeɪʃən]<br>n. 传播；繁殖；增殖<br>1035, PROPAGATION  [,prɒpə’ɡeɪʃən]<br>n. 传播；繁殖；增殖<br>1036, proper  [‘prɑpɚ]<br>adj. 适当的；本身的；特有的；正派的<br>adv. 完全地<br>n. (Proper)人名；(英、德)普罗珀<br>1037, proportional  [prə’pɔːʃ(ə)n(ə)l]<br>adj. 比例的，成比例的；相称的，均衡的;<br>n. [数] 比例项<br>1038, proposal  [prə’pəʊz(ə)l]<br>n. 提议，建议；求婚<br>1039, prospector  [prəʊ’spektə]<br>n. 探勘者；采矿者<br>1040, protocol  [‘prəʊtəkɒl]<br>n. 协议；草案；礼仪;<br>vt. 拟定;<br>vi. 拟定<br>1041, Protocol  [‘prəʊtəkɒl]<br>n. 协议；草案；礼仪;<br>vt. 拟定;<br>vi. 拟定<br>1042, provision  [prə’vɪʒ(ə)n]<br>n. 规定；条款；准备；[经] 供应品<br>vt. 供给…食物及必需品<br>1043, proxy  [‘prɒksɪ]<br>n. 代理人；委托书；代用品<br>1044, prune  [pruːn]<br>vi. 删除；减少<br>vt. 修剪；删除；剪去<br>n. 深紫红色；傻瓜；李子干<br>n. (Prune)人名；(罗)普鲁内<br>1045, pseudo  [‘sjuːdəʊ]<br>n. 伪君子；假冒的人;<br>adj. 冒充的，假的<br>1046, pump  [pʌmp]<br>vt. 打气；用抽水机抽…</p><p>n. 泵，抽水机；打气筒</p><p>vi. 抽水</p><p>n. (Pump)人名；(捷)蓬普；(英)庞普<br>1047, punch above  [punch+above]<br>超越<br>1048, punctuation  [‘pʌŋktʃʊ’eʃən]<br>n. 标点；标点符号<br>1049, puppet  [‘pʌpɪt]<br>n. 木偶；傀儡；受他人操纵的人<br>1050, Purchase  [‘pɜ:tʃəs]<br>n. 购买；紧握；起重装置;<br>vt. 购买；赢得;<br>vi. 购买东西<br>1051, purge  [pɝdʒ]<br>vi. 净化；通便<br>vt. 净化；清洗；通便<br>n. 净化；泻药<br>1052, puzzle  [‘pʌzl]<br>vt. 使…困惑；使…为难；苦思而得出<br>vi. 迷惑；冥思苦想<br>n. 谜；难题；迷惑<br>1053, quack  [kwæk]<br>n. 庸医；鸭叫声<br>vi. （鸭子）嘎嘎叫；吹嘘；大声闲聊<br>adj. 骗人的；冒牌医生的<br>n. (Quack)人名；(德)夸克<br>1054, qualifier  [‘kwɒlɪfaɪə(r)]<br>n. [语] 修饰语<br>n. 资格赛，预选赛；取得资格的人<br>1055, quantile<br>n. [计] 分位数；分位点<br>1056, Quantity  [‘kwɒntɪtɪ]<br>n. 量，数量；大量；总量<br>1057, quiescent  [kwɪ’ɛsnt]<br>adj. 静止的；不活动的；沉寂的<br>1058, quorum  [‘kwɔrəm]<br>n. 法定人数<br>1059, rack  [ræk]<br>n. [机] 齿条；架子；拷问台</p><p>vi. 变形；随风飘；小步跑</p><p>vt. 折磨；榨取</p><p>n. (Rack)人名；(法、德、意、匈)拉克<br>1060, radically  [‘rædɪkli]<br>adv. 根本上；彻底地；以激进的方式<br>1061, radius  [‘reɪdɪəs]<br>n. 半径，半径范围；[解剖] 桡骨；辐射光线；有效航程;<br>n. (Radius)人名；(意、印尼)拉迪乌斯；(英)雷迪厄斯；(法)拉迪于斯<br>1062, raft  [rɑːft]<br>n. 筏；救生艇；（美）大量<br>vt. 筏运；制成筏<br>vi. 乘筏<br>n. (Raft)人名；(匈、瑞典)拉夫特<br>1063, raid  [reɪd]<br>n. 袭击；突袭；搜捕；抢劫<br>vi. 突袭<br>vt. 袭击，突袭<br>n. (Raid)人名；(阿拉伯)拉伊德<br>1064, rake  [rek]<br>vi. 搜索；用耙子耙；掠过，擦过<br>vt. 倾斜；搜索；掠过；用耙子耙<br>n. 耙子；斜度；钱耙；放荡的人，浪子<br>n. (Rake)人名；(英)雷克；(塞)拉凯<br>1065, rally  [‘rælɪ]<br>vi. 团结；重整；恢复；（网球等）连续对打</p><p>vt. 团结；集合；恢复健康、力量等</p><p>n. 集会；回复；公路赛车会</p><p>n. (Rally)人名；(罗)拉利<br>1066, rancher  [‘ræntʃɚ]<br>n. 大农场经营者；大农场工人<br>n. (Rancher)人名；(意)兰凯尔<br>1067, Range  [reɪn(d)ʒ]<br>n. 范围；幅度；排；山脉;<br>vi. 平行，列为一行；延伸；漫游；射程达到;<br>vt. 漫游；放牧；使并列；归类于；来回走动;<br>n. (Range)人名；(葡)兰热；(瑞典、德)朗格<br>1068, rare  [reə]<br>adj. 稀有的；稀薄的；半熟的<br>adj. 杰出的；极度的；非常好的<br>adv. 非常；极其<br>vi. 用后腿站起；渴望<br>1069, rather  [‘rɑːðə]<br>adv. 宁可，宁愿；相当;<br>int. 当然啦（回答问题时用）;<br>n. (Rather)人名；(英)拉瑟<br>1070, raw  [rɔː]<br>adj. 生的；未加工的；阴冷的；刺痛的；擦掉皮的；无经验的；（在艺术等方面）不成熟的;<br>n. 擦伤处;<br>vt. 擦伤;<br>n. (Raw)人名；(英)罗<br>1071, Raw  [rɔː]<br>adj. 生的；未加工的；阴冷的；刺痛的；擦掉皮的；无经验的；（在艺术等方面）不成熟的;<br>n. 擦伤处;<br>vt. 擦伤;<br>n. (Raw)人名；(英)罗<br>1072, react  [rɪ’ækt]<br>vi. 反应；影响；反抗；起反作用;<br>vt. 使发生相互作用；使起化学反应<br>1073, Reactive  [rɪ’æktɪv]<br>adj. 反应的；电抗的；反动的<br>1074, realistic  [rɪə’lɪstɪk]<br>adj. 现实的；现实主义的；逼真的；实在论的<br>1075, realm  [relm]<br>n. 领域，范围；王国<br>1076, Realm  [relm]<br>n. 领域，范围；王国<br>1077, receiver  [rɪ’siːvə]<br>n. 接收器；接受者；收信机；收款员，接待者<br>1078, reciprocate  [rɪ’sɪprəkeɪt]<br>vt. 报答；互换；互给<br>vi. 往复运动；互换；酬答；互给<br>1079, reclamation  [,reklə’meɪʃən]<br>n. 开垦；收回；再利用；矫正<br>1080, recognition  [rekəg’nɪʃ(ə)n]<br>n. 识别；承认，认出；重视；赞誉；公认<br>1081, recommend  [rekə’mend]<br>vt. 推荐，介绍；劝告；使受欢迎；托付;<br>vi. 推荐；建议<br>1082, reconcile  [‘rɛkənsaɪl]<br>vt. 使一致；使和解；调停，调解；使顺从<br>1083, recruiter  [rɪ’kruːtə]<br>n. 招聘人员，征兵人员<br>1084, rectangle  [‘rektæŋg(ə)l]<br>n. 矩形；长方形<br>1085, rectify  [‘rektɪfaɪ]<br>vt. 改正；精馏；整流<br>1086, recurse<br>n. 递归（算法）<br>v. 递归<br>1087, recursion  [rɪ’kɜːʃ(ə)n]<br>n. [数] 递归，循环；递归式<br>1088, recursive  [rɪ’kɜːsɪv]<br>adj. [数] 递归的；循环的<br>1089, Reduce  [rɪ’djuːs]<br>vt. 减少；降低；使处于；把…分解;<br>vi. 减少；缩小；归纳为<br>1090, redundant  [rɪ’dʌnd(ə)nt]<br>adj. 多余的，过剩的；被解雇的，失业的；冗长的，累赘的<br>1091, ReentrantLock<br>重入锁<br>1092, reflexive  [rɪ’fleksɪv]<br>n. 反身代词；反身动词;<br>adj. 反身的；[物] 反射的<br>1093, regardless  [rɪ’gɑːdlɪs]<br>adj. 不管的；不顾的；不注意的;<br>adv. 不顾后果地；不管怎样，无论如何；不惜费用地<br>1094, regardless of<br>不顾，不管<br>regardless of: 不顾 | 不管 | 不惜<br>1095, register  [‘rɛdʒɪstɚ]<br>vt. 登记；注册；记录；挂号邮寄；把…挂号；正式提出 vi. 登记；注册；挂号 n. 登记；注册；记录；寄存器；登记簿 n. (Register)人名；(英)雷吉斯特<br>1096, registry  [‘rɛdʒɪstri]<br>n. 注册；登记处；挂号处；船舶的国籍<br>1097, regular  [‘regjʊlə]<br>adj. 定期的；有规律的；合格的；整齐的；普通的</p><p>n. 常客；正式队员；中坚分子</p><p>adv. 定期地；经常地</p><p>n. (Regular)人名；(以)雷古拉尔<br>1098, reinforce  [riːɪn’fɔːs]<br>vt. 加强，加固；强化；补充;<br>vi. 求援；得到增援；给予更多的支持;<br>n. 加强；加固物；加固材料<br>1099, relevance  [‘rɛləvəns]<br>n. 关联；适当；中肯<br>1100, remedy  [‘remɪdɪ]<br>vt. 补救；治疗；纠正</p><p>n. 补救；治疗；赔偿<br>1101, render  [‘rendə]<br>vt. 致使；提出；实施；着色；以…回报;<br>vi. 给予补偿;<br>n. 打底；交纳；粉刷;<br>n. (Render)人名；(英、德)伦德尔<br>1102, rendering  [‘rend(ə)rɪŋ]<br>n. 翻译；表现；表演；描写；打底；（建筑物等）透视图<br>vt. 致使；表演；打底（render的ing形式）<br>vi. 给予补偿（render的ing形式）<br>1103, renouncement  [renouncement]<br>n. 否认；拒绝；放弃<br>1104, replica  [‘rɛplɪkə]<br>n. 复制品，复制物<br>1105, replicas  [replicas]<br>[古] 复制品<br>复型<br>1106, repository  [rɪ’pɒzɪt(ə)rɪ]<br>n. 贮藏室，仓库；知识库；智囊团<br>1107, represent  [reprɪ’zent]<br>vt. 代表；表现；描绘；回忆；再赠送<br>vi. 代表；提出异议<br>1108, representation  [,reprɪzen’teɪʃ(ə)n]<br>n. 代表；表现；表示法；陈述<br>1109, REQUIRED  [rɪ’kwaɪəd]<br>adj. 必需的；（美）必修的;<br>v. 需要（require的过去式及过去分词形式）；要求<br>1110, reroute  [riː’ruːt]<br>vt. 变更旅程；按新的特定路线运送<br>1111, rescue  [‘reskjuː]<br>vt. 营救；援救;<br>n. 营救；援救；解救<br>1112, reservation  [rezə’veɪʃ(ə)n]<br>n. 预约，预订；保留<br>1113, reservoir  [‘rɛzɚ,vɔr]<br>n. 水库；蓄水池<br>1114, resilience  [rɪ’zɪlɪəns]<br>n. 恢复力；弹力；顺应力<br>1115, resiliency  [rɪ’zɪlɪənsɪ]<br>n. 弹性；跳回<br>1116, Resiliency  [rɪ’zɪlɪənsɪ]<br>n. 弹性；跳回<br>1117, resilient  [rɪ’zɪlɪənt]<br>adj. 弹回的，有弹力的<br>adj. 能复原的；有复原力的<br>1118, resist  [rɪ’zɪst]<br>vi. 抵抗，抗拒；忍耐;<br>vt. 抵抗；忍耐，忍住;<br>n. [助剂] 抗蚀剂；防染剂<br>1119, resolute  [‘rezəluːt]<br>adj. 坚决的；果断的<br>1120, resolution  [,rɛzə’luʃən]<br>n. [物] 分辨率；决议；解决；决心<br>1121, resolve  [rɪ’zɒlv]<br>vt. 决定；溶解；使…分解；决心要做…;<br>vi. 解决；决心；分解;<br>n. 坚决；决定要做的事<br>1122, resolved  [rɪ’zɒlvd]<br>adj. 下定决心的；已解决的；断然的;<br>v. 解决；决定；分解；转变（resolve的过去分词）<br>1123, Resolved  [rɪ’zɒlvd]<br>adj. 下定决心的；已解决的；断然的;<br>v. 解决；决定；分解；转变（resolve的过去分词）<br>1124, Resolver  [riː’zɒlvə]<br>n. 溶剂；[电子] 分解器；下决心者<br>1125, respect  [rɪ’spekt]<br>n. 尊敬，尊重；方面；敬意;<br>vt. 尊敬，尊重；遵守<br>1126, response  [rɪ’spɒns]<br>n. 响应；反应；回答<br>1127, responsible  [rɪ’spɒnsɪb(ə)l]<br>adj. 负责的，可靠的；有责任的<br>1128, responsive  [rɪ’spɒnsɪv]<br>adj. 响应的；应答的；回答的<br>1129, restored  [ri’stɔ:d]<br>adj. 精力充沛的；精力恢复的;<br>v. 修复（restore的过去式）；恢复健康<br>1130, restrict  [rɪ’strɪkt]<br>vt. 限制；约束；限定<br>1131, restriction  [rɪ’strɪkʃ(ə)n]<br>n. 限制；约束；束缚<br>1132, retention  [rɪ’tenʃ(ə)n]<br>n. 保留；扣留，滞留；记忆力；闭尿<br>1133, Retention  [rɪ’tenʃ(ə)n]<br>n. 保留；扣留，滞留；记忆力；闭尿<br>1134, retrieval  [rɪ’triːvl]<br>n. 检索；恢复；取回；拯救<br>1135, retrieve  [rɪ’triːv]<br>vt. [计] 检索；恢复；重新得到;<br>vi. 找回猎物;<br>n. [计] 检索；恢复，取回<br>1136, Retype  [ri:’taip]<br>vt. 重新输入<br>1137, Reuse  [riː’juːz]<br>n. 重新使用，再用;<br>vt. 再使用<br>1138, revision  [rɪ’vɪʒ(ə)n]<br>n. [印刷] 修正；复习；修订本<br>1139, revisions  []<br>n. 校订，[印刷] 修正；复习（revision的复数形式）<br>1140, revoke  [rɪ’vəʊk]<br>vt. 撤回，取消；废除</p><p>vi. 有牌不跟</p><p>n. 有牌不跟<br>1141, rewind  [,ri’waɪnd]<br>n. 重绕；倒带器<br>vt. 倒回；重绕<br>vi. 倒回；重绕<br>1142, rid  [rɪd]<br>vt. 使摆脱；使去掉;<br>n. (Rid)人名；(英)里德<br>1143, riddle  [‘rɪdl]<br>vt. 解谜；给…出谜；充满于<br>n. 谜语；粗筛；谜一般的人、东西、事情等<br>vi. 出谜<br>n. (Riddle)人名；(英)里德尔<br>1144, ridiculous  [rɪ’dɪkjʊləs]<br>adj. 可笑的；荒谬的<br>1145, rigid  [‘rɪdʒɪd]<br>adj. 严格的；僵硬的，死板的；坚硬的；精确的<br>1146, rigorously  [‘rigərəsli]<br>adv.严厉地；残酷地<br>1147, ripped  [rɪpt]<br>adj. 喝醉的；受毒品麻醉的;<br>v. 撕；扯（rip的过去分词）<br>1148, rival  [‘raɪvl]<br>n. 对手；竞争者;<br>vt. 与…竞争；比得上某人;<br>vi. 竞争;<br>adj. 竞争的;<br>n. (Rival)人名；(英、法、西)里瓦尔<br>1149, robust  [rə(ʊ)’bʌst]<br>adj. 强健的；健康的；粗野的；粗鲁的<br>1150, role  [rəʊl]<br>n. 角色；任务;<br>n. (Role)人名；(意、塞、赤几)罗莱<br>1151, rollover  [‘rolovɚ]<br>n. 翻转；（车）翻覆；延期付款<br>1152, rotate  [ˌæplɪ’keɪʃ(ə)n]<br>n. 应用；申请；应用程序；敷用；（对事物、学习等）投入<br>1153, rotation  [ro’teʃən]<br>n. 旋转；循环，轮流<br>1154, routes<br>n. [计] 路由，[通信] 路径；[交] 线路<br>1155, rush  [rʌʃ]<br>n. 冲进；匆促；急流；灯心草</p><p>adj. 急需的</p><p>vt. 使冲；突袭；匆忙地做；飞跃</p><p>vi. 冲；奔；闯；赶紧；涌现</p><p>n. (Rush)人名；(英)拉什<br>1156, saber  [‘seɪbə]<br>n. 军刀；佩剑；骑兵<br>vt. 用马刀砍或杀<br>n. (Saber)人名；(法)萨贝；(阿拉伯)萨比尔<br>1157, sacrifice  [‘sækrɪfaɪs]<br>n. 牺牲；祭品；供奉<br>vt. 牺牲；献祭；亏本出售<br>vi. 献祭；奉献<br>1158, sage  [seɪdʒ]<br>n.圣人；贤人；哲人<br>adj.明智的；贤明的；审慎的<br>n.(Sage)人名；(日)三下(姓)；(英)塞奇；(意)萨杰；(德)扎格；(法)萨热<br>1159, sake  [seɪk]<br>n. 目的；利益；理由；日本米酒<br>n. (Sake)人名；(罗)萨克；(日)酒(姓)<br>1160, salt  [sɔlt]<br>n. 盐；风趣，刺激性<br>adj. 咸水的；含盐的，咸味的；盐腌的；猥亵的<br>vt. 用盐腌；给…加盐；将盐撒在道路上使冰或雪融化<br>n. (Salt)人名；(西)萨尔特；(英)索尔特<br>1161, salty  [‘sɔːltɪ; ‘sɒ-]<br>adj. 咸的；含盐的<br>1162, salute  [sə’l(j)uːt]<br>n. 致敬，欢迎；敬礼;<br>vt. 行礼致敬，欢迎;<br>vi. 致意，打招呼；行礼<br>1163, sanitize<br>vt. 使…无害；给…消毒；对…采取卫生措施<br>1164, sanitized  [sanitized]<br>v. 消毒；使清洁（sanitize的过去式）<br>1165, sanity  [‘sænɪtɪ]<br>n. 明智；头脑清楚；精神健全；通情达理<br>1166, saturate  [‘sætʃərɪt]<br>vt. 浸透，使湿透；使饱和，使充满<br>adj. 浸透的，饱和的；深颜色的<br>1167, saturated  [‘sætʃəreɪtɪd]<br>adj. 饱和的；渗透的；深颜色的</p><p>v. 使渗透，使饱和（saturate的过去式）<br>1168, saturation  [‘sætʃə’reʃən]<br>n. 饱和；色饱和度；浸透；磁化饱和<br>1169, scalability  [,skeilə’biliti]<br>n. 可扩展性；可伸缩性；可量测性<br>1170, scalable  [‘skeləbl]<br>adj. 可攀登的；可去鳞的；可称量的<br>1171, scale  [skeɪl]<br>n. 规模；比例；鳞；刻度；天平；数值范围;<br>vi. 衡量；攀登；剥落；生水垢;<br>vt. 测量；攀登；刮鳞；依比例决定;<br>n. (Scale)人名；(意)斯卡莱<br>1172, scarf  [skɑːf]<br>n. 围巾；嵌接，嵌接处；头巾领巾;<br>vt. 披嵌接；用围巾围;<br>n. (Scarf)人名；(英)斯卡夫<br>1173, scenario  [sɪ’nɑːrɪəʊ]<br>n. 方案；情节；剧本；设想<br>1174, scenarios  [sɪ’nɛrɪ,o]<br>n. 情节；脚本；情景介绍（scenario的复数）<br>1175, scope  [skəʊp]<br>n. 范围；余地；视野；眼界；导弹射程;<br>vt. 审视<br>1176, Scope  [skəʊp]<br>n. 范围；余地；视野；眼界；导弹射程;<br>vt. 审视<br>1177, SCOPE  [skəʊp]<br>n. 范围；余地；视野；眼界；导弹射程;<br>vt. 审视<br>1178, scrape  [skrep]<br>n. 刮掉；擦痕；困境；刮擦声<br>vt. 刮；擦伤；挖成<br>vi. 刮掉；刮出刺耳声<br>1179, scratch  [skrætʃ]<br>n. 擦伤；抓痕；刮擦声；乱写;<br>adj. 打草稿用的；凑合的；碰巧的;<br>vt. 抓；刮；挖出；乱涂;<br>vi. 抓；搔；发刮擦声；勉强糊口；退出比赛<br>1180, screened  [screened]<br>adj. 筛过的，屏蔽的<br>1181, screw  [skruː]<br>vt. 旋，拧；压榨；强迫<br>n. 螺旋；螺丝钉；吝啬鬼<br>vi. 转动，拧<br>1182, scroll  [skrəʊl]<br>n. 卷轴，画卷；名册；卷形物;<br>vi. 成卷形;<br>vt. 使成卷形<br>1183, scum  [skʌm]<br>n. 浮渣；泡沫；糟粕<br>vi. 产生泡沫；被浮渣覆盖<br>vt. 将浮渣去除掉<br>1184, segment  [‘segm(ə)nt]<br>vi. 分割;<br>n. 段；部分;<br>vt. 分割<br>1185, selfie  []<br>n. 自拍照<br>1186, semantics  [sɪ’mæntɪks]<br>n. [语] 语义学；语义论<br>1187, semaphore  [‘seməfɔː]<br>vi. 打旗语；发信号;<br>n. 信号；旗语；臂板信号机;<br>vt. 用信号联络<br>1188, semicolon  [‘sɛmɪkolən]<br>n. 分号<br>1189, sensation  [sen’seɪʃ(ə)n]<br>n. 感觉；轰动；感动<br>1190, sensibly  [‘sɛnsəbli]<br>adv. 明显地；容易感知地；聪明地<br>1191, sentinel  [‘sɛntɪnl]<br>n. 哨兵<br>vt. 守卫，放哨<br>1192, serial  [‘sɪərɪəl]<br>adj. 连续的；连载的；分期偿还的;<br>n. 电视连续剧；[图情] 期刊；连载小说<br>1193, severely  [sɪ’vɪəlɪ]<br>adv. 严重地；严格地，严厉地；纯朴地<br>1194, severity  [sɪ’verɪtɪ]<br>n. 严重；严格；猛烈<br>1195, shell  [ʃel]<br>n. 壳，贝壳；炮弹；外形<br>vi. 剥落；设定命令行解释器的位置<br>vt. 剥皮；炮轰<br>1196, shelter  [‘ʃɛltɚ]<br>n. 庇护；避难所；遮盖物<br>vt. 保护；使掩蔽<br>vi. 躲避，避难<br>n. (Shelter)人名；(英)谢尔特<br>1197, shelve  [ʃɛlv]<br>vt. 将（书等）放置在架子上；搁置，将某事放到一旁不予考虑；将…搁在一边；装搁架于；罢免<br>vi. （陆地）逐渐倾斜<br>1198, shenandoah  [,ʃenən’dəuə]<br>n. 谢南多厄河（美国弗吉尼亚州河流）；谢南多厄河谷（地名）；情人渡，水手瑶（歌曲名）<br>1199, shield  [ʃild]<br>n. 盾；防护物；保护者<br>vt. 遮蔽；包庇；避开；保卫<br>vi. 防御；起保护作用<br>n. (Shield)人名；(英)希尔德<br>1200, Shield  [ʃiːld]<br>n. 盾；防护物；保护者</p><p>vt. 遮蔽；包庇；避开；保卫</p><p>vi. 防御；起保护作用</p><p>n. (Shield)人名；(英)希尔德<br>1201, shim  [ʃɪm]<br>vt. 用木片或夹铁填；夹铁 n. 填隙用木片；夹铁 n. (Shim)人名；(朝)沈<br>1202, shipper  [‘ʃɪpɚ]<br>n. 托运人；发货人；货主<br>1203, shoehorn<br>n. 鞋拔</p><p>vt. 硬塞进<br>1204, shot  [ʃɒt]<br>n. 发射；炮弹；射手；镜头;<br>adj. 用尽的；破旧的；杂色的，闪光的;<br>v. 射击（shoot的过去式和过去分词）<br>1205, shrimp  [ʃrɪmp]<br>n. 虾；小虾；矮小的人<br>vi. 捕虾<br>adj. 有虾的；虾制的<br>1206, shrink  [ʃrɪŋk]<br>n. 收缩；畏缩；&lt;俚&gt;精神病学家</p><p>vt. 使缩小，使收缩</p><p>vi. 收缩；畏缩<br>1207, shuffle  [‘ʃʌfl]<br>v. 洗牌；推诿，推卸；拖曳，慢吞吞地走；搅乱<br>n. 洗牌，洗纸牌；混乱，蒙混；拖着脚走<br>1208, sidecar  [‘saɪdkɑr]<br>n. 轻快的双轮马车；跨斗<br>1209, sidetrack  [‘saɪdtræk]<br>vt. 将（火车）[建] 转到侧线；转变（话题）<br>n. （铁路）侧线；次要地位<br>vi. [建] 转到侧线；转变话题<br>1210, sierra  [sɪ’erə; sɪ’eərə]<br>n. [地理] 锯齿山脊；呈齿状起伏的山脉<br>n. (Sierra)人名；(意、西)谢拉；(英)西拉<br>1211, significant  [sɪɡ’nɪfɪkənt]<br>adj. 重大的；有效的；有意义的；值得注意的；意味深长的<br>n. 象征；有意义的事物<br>1212, silhouette  [,sɪlu’ɛt]<br>n. 轮廓，剪影<br>vt. 使…照出影子来；使…仅仅显出轮廓<br>n. (Silhouette)人名；(法)西卢埃特<br>1213, Silly  [‘sɪlɪ]<br>adj. 愚蠢的<br>n. 傻瓜<br>n. (Silly)人名；(匈)希伊；(法)西利<br>1214, simulate  [‘sɪmjʊleɪt]<br>vt. 模仿；假装；冒充</p><p>adj. 模仿的；假装的<br>1215, simultaneous  [,saɪml’tenɪəs]<br>adj. 同时的；联立的；同时发生的<br>n. 同时译员<br>1216, simultaneously  [saɪməl’tenɪəsli]<br>adv. 同时地<br>1217, single-minded  [‘siŋɡl,’maindid]<br>adj. 专心的；纯真的；真诚的；率直的<br>1218, singular  [‘sɪŋgjʊlə]<br>adj. 单数的；单一的；非凡的；异常的</p><p>n. 单数<br>1219, singularity  [sɪŋgjʊ’lærɪtɪ]<br>n. 奇异；奇点；突出；稀有<br>1220, sink  [sɪŋk]<br>vi. 下沉；消沉；渗透<br>vt. 使下沉；挖掘；使低落<br>n. 水槽；洗涤槽；污水坑<br>n. (Sink)人名；(英、瑞典)辛克<br>1221, slack  [slæk]<br>adj. 松弛的；疏忽的；不流畅的<br>vi. 松懈；减弱<br>n. 煤末；峡谷<br>vt. 放松；使缓慢<br>adv. 马虎地；缓慢地<br>n. (Slack)人名；(英)斯莱克<br>1222, slash  [slæʃ]<br>vt. 猛砍；鞭打；严厉批评；大幅度裁减或削减;<br>vi. 猛砍；严厉批评;<br>n. 削减；斜线；猛砍；砍痕；沼泽低地<br>1223, slave  [sleɪv]<br>n. 奴隶；从动装置;<br>vi. 苦干；拼命工作;<br>n. (Slave)人名；(塞、罗)斯拉韦<br>1224, slavishly  [‘slevɪʃli]<br>adv. 奴隶般地<br>1225, sleuth  [sluːθ]<br>n. 侦探；警犬</p><p>vi. 做侦探；侦查<br>1226, slice  [slaɪs]<br>n. 薄片；部分；菜刀，火铲;<br>vt. 切下；把…分成部分；将…切成薄片;<br>vi. 切开；割破<br>1227, slide  [slaɪd]<br>n. 滑动；幻灯片；滑梯；雪崩;<br>vi. 滑动；滑落；不知不觉陷入;<br>vt. 滑动；使滑动；悄悄地迅速放置<br>1228, sloped  []<br>adj. 倾斜的;<br>v. 倾斜；使倾斜（slope的过去式）;<br>1229, slot  [slɒt]<br>n. 位置；狭槽；水沟；硬币投币口;<br>vt. 跟踪；开槽于;<br>n. (Slot)人名；(英、荷)斯洛特<br>1230, slurp  [slɜːp]<br>vt. 出声地吃或喝</p><p>vi. 出声地吃或喝</p><p>n. 吃的声音；啜食声<br>1231, snack  [snæk]<br>n. 小吃，快餐；一份，部分;<br>vi. 吃快餐，吃点心<br>1232, snap  [snæp]<br>vt. 突然折断，拉断；猛咬；啪地关上;<br>vi. 咬；厉声说；咯嗒一声关上;<br>n. 猛咬；劈啪声；突然折断;<br>adj. 突然的<br>1233, SNAPSHOT  [‘snæpʃɒt]<br>n. 快照，快相；急射，速射；简单印象;<br>vt. 给…拍快照;<br>vi. 拍快照<br>1234, sneaker  [‘sniːkə]<br>n. 运动鞋；卑鄙者；鬼鬼祟祟做事的人<br>1235, sneaky  [‘sniki]<br>adj. 鬼鬼祟祟的；暗中的，卑鄙的<br>1236, sniffer  [snɪfə]<br>n. 嗅探器；嗅探犬；以鼻吸毒者<br>1237, snippet  [‘snɪpɪt]<br>n. 小片；片断；不知天高地厚的年轻人<br>1238, soap  [səʊp]<br>n. 肥皂;<br>vt. 将肥皂涂在……上；对……拍马屁（俚语）;<br>vi. 用肥皂擦洗<br>1239, sock  [sɑk]<br>n. 短袜；一击<br>vt. 重击；给……穿袜<br>adv. 正着地；不偏不倚地<br>adj. 非常成功的<br>n. (Sock)人名；(德)佐克<br>1240, sole  [sol]<br>n. 鞋底；脚底；基础；鳎目鱼<br>adj. 唯一的；单独的；仅有的<br>vt. 触底；上鞋底<br>n. (Sole)人名；(意、西、芬、塞、罗、南非)索莱<br>1241, solid  [‘sɒlɪd]<br>adj. 固体的；可靠的；立体的；结实的；一致的;<br>n. 固体；立方体;<br>n. (Solid)人名；(瑞典)索利德<br>1242, sophisticated  [sə’fɪstɪkeɪtɪd]<br>adj. 复杂的；精致的；久经世故的；富有经验的;<br>v. 使变得世故；使迷惑；篡改（sophisticate的过去分词形式）<br>1243, sore  [sɔː]<br>adj. 疼痛的，痛心的；剧烈的，极度的；恼火的，发怒的；厉害的，迫切的<br>n. 溃疡，痛处；恨事，伤心事<br>n. (Sore)人名；(法)索尔；(意)索雷<br>1244, spawn  [spɔn]<br>n. 卵；菌丝；产物<br>vt. 产卵；酿成，造成；大量生产<br>vi. 产卵；大量生产<br>1245, spec  [spɛk]<br>n. 投机；说明书；细则<br>1246, specific  [spə’sɪfɪk]<br>adj. 特殊的，特定的；明确的；详细的；[药] 具有特效的;<br>n. 特性；细节；特效药<br>1247, specification  [,spesɪfɪ’keɪʃ(ə)n]<br>n. 规格；说明书；详述<br>1248, Specification  [,spesɪfɪ’keɪʃ(ə)n]<br>n. 规格；说明书；详述<br>1249, spike  [spaɪk]<br>n. 长钉，道钉；钉鞋；细高跟<br>vt. 阻止；以大钉钉牢；用尖物刺穿<br>n. (Spike)人名；(瑞典)斯皮克<br>1250, Spinlock  [Spinlock]<br>自旋锁<br>1251, split  [splɪt]<br>vt. 分离；使分离；劈开；离开；分解;<br>vi. 离开；被劈开；断绝关系;<br>n. 劈开；裂缝;<br>adj. 劈开的<br>1252, sponsor  [‘spɒnsə]<br>n. 赞助者；主办者；保证人</p><p>vt. 赞助；发起<br>1253, spouse  [spaʊz; -s]<br>n. 配偶<br>vt. 和…结婚<br>n. (Spouse)人名；(英)斯波斯<br>1254, spout  [spaʊt]<br>n. 喷口；水龙卷；水落管；水柱<br>vt. 喷出；喷射；滔滔不绝地讲；把…典当掉<br>vi. 喷出；喷射；滔滔不绝地讲<br>1255, spurious  [‘spjʊərɪəs]<br>adj. 假的；伪造的；欺骗的<br>1256, squash  [skwɔʃ]<br>vt. 镇压；把…压扁；使沉默<br>vi. 受挤压；发出挤压声；挤入<br>n. 壁球；挤压；咯吱声；南瓜属植物；（英）果汁饮料<br>1257, stacked  [stækt]<br>adj. 妖艳的；（女人）身材丰满匀称的<br>v. 堆放（stack的过去分词）<br>1258, stage  [steɪdʒ]<br>n. 阶段；舞台；戏剧；驿站</p><p>vt. 举行；上演；筹划</p><p>vi. 举行；适于上演；乘驿车旅行</p><p>n. (Stage)人名；(英)斯特奇<br>1259, stale  [stel]<br>adj. 陈腐的；不新鲜的<br>vi. 变陈旧；撒尿；变得不新鲜<br>vt. 使变旧；变得不新鲜<br>n. 尿<br>n. (Stale)人名；(塞)斯塔莱<br>1260, Stale  [steɪl]<br>adj. 陈腐的；不新鲜的;<br>vi. 变陈旧；撒尿；变得不新鲜;<br>vt. 使变旧；变得不新鲜;<br>n. 尿;<br>n. (Stale)人名；(塞)斯塔莱<br>1261, staleness  [staleness]<br>n. 腐败；陈腐；不新鲜；泄气<br>1262, stamp  [stæmp]<br>n. 邮票；印记；标志；跺脚<br>vt. 铭记；标出；盖章于…；贴邮票于…；用脚踩踏<br>vi. 跺脚；捣碎；毁掉<br>n. (Stamp)人名；(德)施坦普；(英)斯坦普<br>1263, stamped  [stæmpt]<br>adj. 铭刻的；盖上邮戳的；顿足的</p><p>v. 贴上邮票（stamp的过去式）；顿足<br>1264, stand-alone  [‘stændə,lon]<br>n. 独立；单机<br>adj. 独立的；独立操作的<br>1265, standardization  [,stændədaɪ’zeɪʃən]<br>n. 标准化；[数] 规格化；校准<br>1266, stash<br>n. 藏匿处；藏匿物<br>vt. 存放；贮藏<br>vi. 存放；藏起来<br>1267, statement  [‘steɪtm(ə)nt]<br>n. 声明；陈述，叙述；报表，清单<br>1268, statistic  [stə’tɪstɪk]<br>adj. 统计的，统计学的;<br>n. 统计数值<br>1269, statistician<br>n. 统计学家，统计员<br>1270, stdout<br>abbr. 标准输出（standard output）<br>1271, STEADY  [‘stedɪ]<br>adj. 稳定的；不变的；沉着的;<br>vi. 稳固;<br>vt. 使稳定；稳固；使坚定;<br>adv. 稳定地；稳固地;<br>n. 关系固定的情侣；固定支架<br>1272, stem  [stem]<br>n. 干；茎；船首；血统;<br>vt. 阻止；除去…的茎；给…装柄;<br>vi. 阻止；起源于某事物；逆行<br>1273, stereotype  [‘stɛrɪətaɪp]<br>vt. 使用铅版；套用老套，使一成不变<br>n. 陈腔滥调，老套；铅版<br>1274, sticker  [‘stɪkə]<br>n. 尖刀；难题；张贴物；坚持不懈的人;<br>vt. 给…贴上标签价;<br>adj. 汽车价目标签的；汽车标签价的;<br>n. (Sticker)人名；(德)施蒂克<br>1275, stitch  [stɪtʃ]<br>n. 针脚，线迹；一针</p><p>vt. 缝，缝合</p><p>vi. 缝，缝合<br>1276, straightforward  [streɪt’fɔːwəd]<br>adj. 简单的；坦率的；明确的；径直的</p><p>adv. 直截了当地；坦率地<br>1277, strange  [strendʒ]<br>adj. 奇怪的；陌生的；外行的<br>adv. 奇怪地；陌生地，冷淡地<br>n. (Strange)人名；(英)斯特兰奇；(瑞典、塞)斯特朗格<br>1278, strategist  [‘strætədʒɪst]<br>n. 战略家；军事家<br>1279, strategy  [‘strætɪdʒɪ]<br>n. 战略，策略<br>1280, stratum  [‘strɑːtəm; ‘streɪtəm]<br>n. （组织的）层；[地质] 地层；社会阶层<br>1281, strict  [strɪkt]<br>adj. 严格的；绝对的；精确的；详细的<br>1282, stride  [straɪd]<br>n. 大步；步幅；进展<br>vt. 跨过；大踏步走过；跨坐在…<br>vi. 跨；跨过；大步行走<br>过去式:strode; 过去分词:stridden; 现在分词:striding<br>1283, strip  [strɪp]<br>vt. 剥夺；剥去；脱去衣服<br>n. 带；条状；脱衣舞<br>vi. 脱去衣服<br>1284, striped  [straɪpt]<br>adj. 有条纹的；有斑纹的;<br>v. 被剥去（strip的过去分词）<br>1285, structural  [‘strʌktʃ(ə)r(ə)l]<br>adj. 结构的；建筑的<br>1286, Stub  [stʌb]<br>n. 存根；烟蒂；树桩；断株;<br>vt. 踩熄；连根拔除;<br>n. (Stub)人名；(挪、瑞典)斯图布<br>1287, stuff  [stʌf]<br>n. 东西；材料；填充物；素材资料<br>vt. 塞满；填塞；让吃饱<br>vi. 吃得过多<br>1288, subdivide  [‘sʌbdɪvaɪd]<br>vi. 细分，再分<br>vt. 把……再分，把……细分<br>1289, subject  [‘sʌbdʒekt; ‘sʌbdʒɪkt]<br>n. 主题；科目；[语] 主语；国民;<br>adj. 服从的；易患…的；受制于…的;<br>vt. 使…隶属；使屈从于…<br>1290, subscribe  [səb’skraɪb]<br>vi. 订阅；捐款；认购；赞成；签署 vt. 签署；赞成；捐助<br>1291, Subscription  [səb’skrɪpʃ(ə)n]<br>n. 捐献；订阅；订金；签署<br>1292, subsequent  [‘sʌbsɪkw(ə)nt]<br>adj. 后来的，随后的<br>1293, substitute  [‘sʌbstɪtut]<br>n. 代用品；代替者<br>vi. 替代<br>vt. 代替<br>1294, suddenly  [ˈsʌdnlɪ]<br>adv. 突然地；忽然<br>1295, suit  [suːt]<br>vt. 适合；使适应<br>n. 诉讼；恳求；套装；一套外衣<br>vi. 合适；相称<br>1296, suite  [sut; swit]<br>n. （一套）家具；套房；组曲；（一批）随员，随从<br>1297, summed<br>v. 总计，概括，总结（sum的过去时和过去分词）<br>1298, supercede  [supercede]<br>vt. 取代；延期；紧接着…而到来<br>vi. 推迟行动<br>1299, superseded<br>adj. 作废的；被取代的<br>v. 取代；克制；废弃（supersede的过去分词）<br>1300, superset  [superset]<br>n. [数] 超集<br>1301, supervise  [‘suːpəvaɪz; ‘sjuː-]<br>vt. 监督，管理；指导<br>vi. 监督，管理；指导<br>1302, supervisor  [‘supɚvaɪzɚ]<br>n. 监督人，[管理] 管理人；检查员<br>1303, supplemental  [,sʌplə’mɛntl]<br>adj. 补充的（等于supplementary）；追加的<br>1304, supplier  [sə’plaɪə]<br>n. 供应厂商，供应国；供应者<br>1305, supreme  [suː’priːm]<br>adj.最高的；至高的；最重要的<br>n.至高；霸权<br>1306, survey  [ˈsɜːveɪ]<br>n. 调查；测量；审视；纵览;<br>vt. 调查；勘测；俯瞰;<br>vi. 测量土地<br>1307, survivor  [sə’vaɪvə]<br>n. 幸存者；生还者；残存物<br>1308, susceptible  [sə’septɪb(ə)l]<br>adj. 易受影响的；易感动的；容许…的</p><p>n. 易得病的人<br>1309, symmetric  [sɪ’metrɪk]<br>adj. 对称的；匀称的<br>1310, synonyms  [ˈsɪnənɪm]<br>n. [语] 同义词，同义字；同一性（synonym的复数）<br>1311, synopsis  [sɪ’nɑpsɪs]<br>n. 概要，大纲<br>1312, syntactically  [sɪn’tæktɪkli]<br>adv. 依照句法地；在语句构成上<br>1313, synthetic  [sɪn’θetɪk]<br>adj.综合的；合成的，人造的<br>n.合成物<br>1314, systematic  [sɪstə’mætɪk]<br>adj. 系统的；体系的；有系统的；[图情] 分类的；一贯的，惯常的<br>1315, tactic  [‘tæktɪk]<br>n. 策略，战略<br>adj. 按顺序的，依次排列的<br>1316, tail  [teɪl]<br>n. 尾巴；踪迹；辫子；燕尾服<br>vt. 尾随；装上尾巴<br>vi. 跟踪；变少或缩小<br>adj. 从后面而来的；尾部的<br>1317, taint  [tent]<br>vt. 污染；腐蚀；使感染<br>n. 污点；感染<br>vi. 败坏；被污染<br>1318, tamper  [‘tæmpə]<br>vi. 篡改；干预；损害；削弱；玩弄；贿赂;<br>vt. 篡改;<br>n. 填塞者；捣棒<br>1319, Tarball  [Tarball]<br>n. 原始码；（Linux下最方便的）打包工具<br>1320, tasty  [‘teɪstɪ]<br>adj. 美味的；高雅的；有趣的;<br>n. 可口的东西；引人入胜的东西<br>1321, technique  [tek’niːk]<br>n. 技巧，技术；手法<br>1322, telemetry  [tə’lɛmətri]<br>n. [自] 遥测技术；遥感勘测；自动测量记录传导<br>1323, tempo  [‘tempəʊ]<br>n. 速度，发展速度；拍子<br>n. (Tempo)人名；(意)滕波<br>1324, temptation  [tem(p)’teɪʃ(ə)n]<br>n. 引诱；诱惑物<br>1325, tenant  [‘tɛnənt]<br>n. 承租人；房客；佃户；居住者<br>vt. 租借（常用于被动语态）<br>n. (Tenant)人名；(法)特南<br>1326, tenure  [‘tenjə]<br>n. 任期；占有<br>vt. 授予…终身职位<br>1327, term  [tɝm]<br>n. 术语；学期；期限；条款；(代数式等的)项<br>vt. 把…叫做<br>n. (Term)人名；(泰)丁<br>1328, terminology  [,tɜːmɪ’nɒlədʒɪ]<br>n. 术语，术语学；用辞<br>1329, terminus  [‘tɝmɪnəs]<br>n. 终点；终点站；界标；界石<br>1330, territory  [‘terɪt(ə)rɪ]<br>n. 领土，领域；范围；地域；版图<br>1331, testimonial  [,testɪ’məʊnɪəl]<br>n.证明书；推荐书<br>adj.证明的；褒奖的；表扬的<br>1332, theta  [‘θitə]<br>n. 希腊字母的第八字；时间递耗值<br>1333, thin  [θɪn]<br>adj. 薄的；瘦的；稀薄的；微弱的;<br>vt. 使瘦；使淡；使稀疏;<br>vi. 变薄；变瘦；变淡;<br>adv. 稀疏地；微弱地;<br>n. 细小部分;<br>n. (Thin)人名；(越)辰；(柬)廷<br>1334, threshold  [‘θreʃəʊld; ‘θreʃ,həʊld]<br>n. 入口；门槛；开始；极限；临界值<br>1335, thresholds  [‘θrɛʃhold]<br>n. 阈值；[建] 门槛；临界值值（threshold的复数）<br>1336, thrift  [θrɪft]<br>n. 节俭；节约；[植] 海石竹<br>n. (Thrift)人名；(英)思里夫特<br>1337, thrilled  [θrɪld]<br>adj. 非常兴奋的；极为激动的;<br>v. 激动（thrill的过去式）；[医] 震颤<br>1338, throttle  [‘θrɑtl]<br>n. 节流阀；[车辆] 风门；喉咙<br>vt. 压制，扼杀；使……窒息；使……节流<br>vi. 节流，减速；窒息<br>1339, throughput  [‘θrʊ’pʊt]<br>n. 生产量，生产能力<br>1340, thumbnail  [‘θʌmneɪl]<br>n. 拇指指甲；极小的东西；短文;<br>adj. 极小的，极短的<br>1341, tick  [tɪk]<br>vt. 标记号于；滴答地记录<br>n. 滴答声；扁虱；记号；赊欠<br>vi. 发出滴答声；标以记号<br>n. (Tick)人名；(匈、芬)蒂克<br>1342, tie  [taɪ]<br>vt. 系；约束；打结；与…成平局<br>vi. 打结；不分胜负；被用带（或绳子等）系住<br>n. 领带；平局；鞋带；领结；不分胜负<br>n. (Tie)人名；(东南亚国家华语)治；(英)泰伊；(柬)狄<br>1343, tie-breaking  [tie-breaking]<br>adj. 平局决胜的；打破僵局的<br>1344, tier  [tɪr]<br>n. 层，排；行，列；等级<br>vt. 使层叠<br>vi. 成递升徘列<br>n. (Tier)人名；(英)蒂尔<br>1345, ties<br>n. 结<br>v. 绑；连结<br>1346, toggle  [‘tɒg(ə)l]<br>vt. 拴牢，系紧;<br>n. 开关，触发器；拴扣；[船] 套索钉<br>1347, Tokenizer<br>n. 分词器；编译器<br>1348, tolerable  [‘tɒl(ə)rəb(ə)l]<br>adj. 可以的；可容忍的<br>1349, tolerate  [‘tɒləreɪt]<br>vt. 忍受；默许；宽恕<br>1350, topology  [təˈpɑlədʒi]<br>n. 拓扑学<br>1351, tracker  [‘trækə]<br>n. 拉纤者，纤夫；追踪系统，[自] 跟踪装置；追踪者<br>1352, trade off<br>权衡；卖掉；交替使用；交替换位<br>1353, tradeoff  [‘tred,ɔf]<br>n. 权衡；折衷；（公平）交易（等于trade-off）<br>1354, tradeoffs  [‘tred,ɔf]<br>n. 权衡；折衷；（公平）交易（等于trade-off）<br>1355, transform  [træns’fɔːm; trɑːns-; -nz-]<br>vt. 改变，使…变形；转换;<br>vi. 变换，改变；转化<br>1356, transformation  [trænsfə’meɪʃ(ə)n; trɑːns-; -nz-]<br>n. [遗] 转化；转换；改革；变形<br>1357, transient  [‘trænzɪənt]<br>adj. 短暂的；路过的;<br>n. 瞬变现象；过往旅客；候鸟<br>1358, transition  [træn’zɪʃ(ə)n; trɑːn-; -‘sɪʃ-]<br>n. 过渡；转变；[分子生物] 转换；变调<br>1359, transitive  [‘trænsɪtɪv; ‘trɑːns-; -nz-]<br>adj. 及物的；过渡的；可迁的;<br>n. 传递；及物动词<br>1360, transparently  [‘træns’pɛrəntli]<br>adv. 显然地，易觉察地；明亮地<br>1361, traversal  [trəˈvərs(ə)l]<br>n. [计] 遍历；横越；横断物<br>1362, traverse  [‘trævəs; trə’vɜːs]<br>n. 穿过；横贯；横木</p><p>vt. 穿过；反对；详细研究；在…来回移动</p><p>vi. 横越；旋转；来回移动</p><p>adj. 横贯的</p><p>n. (Traverse)人名；(英)特拉弗斯；(法)特拉韦尔斯<br>1363, traversing  [‘trævɝs]<br>n. 穿越，通过;<br>v. 穿过（traverse的ing形式）；横越<br>1364, Tray  [treɪ]<br>n. 托盘；文件盒；隔底匣；（无线电的）发射箱<br>1365, tremendously  [trɪ’mɛndəsli]<br>adv. 非常地；可怕地；惊人地<br>1366, trends  [trendz]<br>n. 动态，[统计] 趋势<br>1367, trial  [‘traɪəl]<br>n. 试验；审讯；努力；磨炼;<br>adj. 试验的；审讯的;<br>n. (Trial)人名；(法)特里亚尔<br>1368, tribe  [traɪb]<br>n. 部落；族；宗族；一伙<br>n. (Tribe)人名；(英)特赖布<br>1369, tricky  [‘trɪkɪ]<br>adj. 狡猾的；机警的<br>1370, trident  [‘traɪdnt]<br>n. 三叉戟；[数] 三叉线；三齿鱼叉<br>1371, trillion  [‘trɪljən]<br>n. [数] 万亿</p><p>adj. 万亿的</p><p>num. [数] 万亿<br>1372, trivia  [‘trɪvɪə]<br>n. 琐事<br>1373, trivial  [‘trɪvɪəl]<br>adj. 不重要的，琐碎的；琐细的<br>1374, tropic  [‘trɒpɪk]<br>n. 热带；回归线<br>adj. 热带的<br>1375, troubleshooting<br>n. 解决纷争；发现并修理故障<br>v. 检修（troubleshoot的ing形式）；当调解人<br>1376, trunk  [trʌŋk]<br>n. 树干；躯干；象鼻；汽车车尾的行李箱;<br>vt. 把…放入旅行箱内;<br>adj. 干线的；躯干的；箱子的;<br>n. (Trunk)人名；(德、匈、西)特伦克<br>1377, tunable  [‘tjʊnəbl]<br>adj. 可调谐的；可调音的；和谐的；音调美的<br>1378, tune  [tun]<br>n. 曲调；和谐；心情<br>vt. 调整；使一致；为…调音<br>vi. [电子][通信] 调谐；协调<br>n. (Tune)人名；(英)图恩<br>1379, tunnel  [‘tʌnl]<br>n. 隧道；坑道；洞穴通道<br>vt. 挖；在…打开通道；在…挖掘隧道<br>vi. 挖掘隧道；打开通道<br>1380, tutorial  [tjuː’tɔːrɪəl]<br>adj. 辅导的；家庭教师的，个别指导的;<br>n. 个别指导<br>1381, tweak  [twik]<br>n. 扭；拧；焦急<br>vt. 扭；用力拉；开足马力<br>1382, tweet  [twiːt]<br>n. 小鸟叫声；自录音再现装置发出的高音；推特;<br>vi. 吱吱地叫；啾鸣<br>1383, ubiquitous  [juː’bɪkwɪtəs]<br>adj. 普遍存在的；无所不在的<br>1384, unary  [‘juːnərɪ]<br>adj. [数] 一元的<br>1385, unassigned<br>adj. 未派职务的；未赋值的<br>1386, uncle  [‘ʌŋk(ə)l]<br>n. 叔叔；伯父；伯伯；舅父；姨丈；姑父<br>1387, undelivered  [,ʌndɪ’lɪvɚd]<br>adj. 未被释放的；未送达的<br>1388, undergo  [,ʌndɚ’ɡo]<br>vt. 经历，经受；忍受<br>1389, underlying  [ʌndə’laɪɪŋ]<br>adj. 潜在的；根本的；在下面的；优先的;<br>v. 放在…的下面；为…的基础；优先于（underlie的ing形式）<br>1390, underpin  [ʌndə’pɪn]<br>vt. 巩固；支持；从下面支撑；加强…的基础<br>1391, underwear  [‘ʌndəweə]<br>n. 内衣物<br>1392, unfeasible  [ʌn’fiːzɪb(ə)l]<br>adj. 难实施的，不能实行的<br>1393, unified<br>adj. 统一的；一致标准的<br>v. 统一；使一致（unify的过去分词）<br>1394, Unity  [ˈjuːnəti]<br>n. 团结；一致；联合；个体;<br>n. (Unity)人名；(英)尤妮蒂<br>1395, Until  [ən’tɪl]<br>conj. 在…以前；直到…时;<br>prep. 在…以前；到…为止<br>1396, unusual  [ʌn’juːʒʊəl]<br>adj. 不寻常的；与众不同的；不平常的<br>1397, upon  [ə’pɑn]<br>prep. 根据；接近；在…之上<br>1398, usual  [‘juːʒʊəl]<br>adj. 通常的，惯例的；平常的<br>1399, Utility  [juːˈtɪləti]<br>n. 实用；效用；公共设施；功用;<br>adj. 实用的；通用的；有多种用途的<br>1400, vacant  [‘veɪk(ə)nt]<br>adj.空虚的；空的；空缺的；空闲的；茫然的<br>n.(Vacant)人名；(法)瓦康<br>1401, Validation  [,vælɪ’deɪʃən]<br>n. 确认；批准；生效<br>1402, vanilla  [və’nɪlə]<br>n. 香子兰，香草<br>adj. 香草味的<br>1403, variant  [‘vɛrɪənt]<br>adj. 不同的；多样的<br>n. 变体；转化<br>1404, variants<br>n. [计] 变体；变异型（variant的复数）<br>1405, Variation  [veərɪ’eɪʃ(ə)n]<br>n. 变化；[生物] 变异，变种<br>1406, various  [‘veərɪəs]<br>adj. 各种各样的；多方面的<br>1407, vary  [‘veərɪ]<br>vi. 变化；变异；违反;<br>vt. 改变；使多样化；变奏;<br>n. (Vary)人名；(英、法、罗、柬)瓦里<br>1408, vast  [vɑːst]<br>adj. 广阔的；巨大的；大量的；巨额的;<br>n. 浩瀚；广阔无垠的空间;<br>n. (Vast)人名；(法)瓦斯特<br>1409, vastly  [ˈvɑ:stli]<br>adv. 极大地；广大地；深远地<br>1410, vector  [‘vɛktɚ]<br>n. 矢量；带菌者；航线<br>vt. 用无线电导航<br>1411, vehicle  [‘viːɪkl]<br>n. [车辆] 车辆；工具；交通工具；运载工具；传播媒介；媒介物<br>1412, velocity  [vəˈlɒsəti]<br>n. 【物】速度<br>1413, Velocity  [vəˈlɒsəti]<br>n. [力] 速率；迅速；周转率<br>1414, vendor  [‘vɛndɚ]<br>n. 卖主；小贩；供应商；[贸易] 自动售货机<br>1415, Venus  [‘viːnəs]<br>n. [天] 金星；维纳斯（爱与美的女神）<br>1416, verbose  [vɜː’bəʊs]<br>adj. 冗长的；啰嗦的<br>1417, verify  [‘verɪfaɪ]<br>vt. 核实；查证<br>1418, versatile  [‘vɜːsətaɪl]<br>adj. 多才多艺的；通用的，万能的；多面手的<br>1419, versus  [‘vɝsəs]<br>prep. 对；与…相对；对抗<br>1420, vetting  [vetting]<br>n. 审查，审核<br>1421, via  [ˈvaɪə，ˈviːə]<br>prep. 渠道，通过；经由<br>1422, vigorously  [‘vɪgərəsli]<br>adv. 精神旺盛地，活泼地<br>1423, violation  [vaɪə’leɪʃn]<br>n. 违反；妨碍，侵害；违背；强奸<br>1424, virtue  [‘vɜːtjuː; -tʃuː]<br>n. 美德；优点；贞操；功效;<br>n. (Virtue)人名；(英)弗丘<br>1425, visual  [‘vɪʒjʊəl; -zj-]<br>adj. 视觉的，视力的；栩栩如生的<br>1426, Visual  [‘vɪʒjʊəl; -zj-]<br>adj. 视觉的，视力的；栩栩如生的<br>1427, volatile  [‘vɒlətaɪl]<br>adj. [化学] 挥发性的；不稳定的；爆炸性的；反复无常的;<br>n. 挥发物；有翅的动物;<br>n. (Volatile)人名；(意)沃拉蒂莱<br>1428, volatility  [,vɑlə’tɪləti]<br>n. [化学] 挥发性；易变；活泼<br>1429, voltage  [‘voltɪdʒ]<br>n. [电] 电压<br>1430, vulnerabilities<br>n. 缺陷（vulnerability的复数形式）；脆弱点<br>1431, walkthrough<br>n. 预排，预排工作<br>1432, wall-mounted  [,wɔ:l’mauntid]<br>adj. 固定在墙上的；安装在墙上的<br>1433, warranty  [‘wɔrənti]<br>n. 保证；担保；授权；（正当）理由<br>1434, webcasts  []<br>n. 网络广播（webcast的复数）<br>1435, webinar  [‘webɪnɑː]<br>n. 网络研讨会；在线会议<br>1436, weighted  [‘wetɪd]<br>adj. [数] 加权的；加重的；衡量过的<br>v. 加重量于…；重压（weight的过去分词）<br>1437, well-distributed<br>均匀<br>1438, whence  [wens]<br>n. 根源<br>adv. 从何处<br>pron. 何处<br>conj. 由此<br>1439, whoop  [wuːp]<br>n. 大叫；哮喘声；呐喊；一点点<br>vt. 高声说；唤起<br>vi. 叫喊；喘息<br>1440, whore  [hɔː]<br>vi.卖淫，娼妓<br>n.娼妓，淫妇<br>1441, wicked  [‘wɪkɪd]<br>adj. 邪恶的；恶劣的；不道德的；顽皮的<br>1442, widgets  []<br>n. 小工具（widget的复数）；窗体小部件<br>1443, wiggle  [‘wɪɡl]<br>vt. 使……摆动，使……扭动<br>vi. 摆动<br>n. 扭动<br>1444, wildcard  [‘waɪldkɑrd]<br>n. 通配符<br>1445, wipe  [waɪp]<br>vt. 擦；消除；涂上;<br>vi. 擦；打;<br>n. 擦拭；用力打<br>1446, wizard  [‘wɪzəd]<br>n. 男巫；术士；奇才；向导程序</p><p>adj. 男巫的；巫术的<br>1447, Wizard  [‘wɪzəd]<br>n. 男巫；术士；奇才;<br>adj. 男巫的；巫术的<br>1448, workbench  [‘wɝkbɛntʃ]<br>n. 工作台；手工台<br>1449, worthwhile  [wɜːθ’waɪl]<br>adj. 值得做的，值得花时间的<br>1450, wrap  [ræp]<br>vt. 包；缠绕；隐藏；掩护;<br>vi. 包起来；缠绕；穿外衣;<br>n. 外套；围巾<br>1451, WRT  [WRT]<br>abbr. 关于（With Regard To）<br>1452, xenial  [xenial]<br>adj. 异花受粉的；主客关系的；款待的<br>1453, zap  [zæp]<br>n. 活力；意志；杀死；震击</p><p>vt. 攻击；打败；快速推动</p><p>vi. 快速移动</p><p>int. 咝！；糟了！<br>1454, 演示  [yǎn shì]<br>demonstration;<br>show-how;<br>reproduction</p>]]></content>
      
      
      <categories>
          
          <category> Words </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Words </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过IL分析C#中的委托、事件、Func、Action、Predicate之间的区别与联系</title>
      <link href="/csharp-il-delegate-event-func-action-predicate.html"/>
      <url>/csharp-il-delegate-event-func-action-predicate.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>2015年05月04日写的一篇文章。</p></blockquote><a id="more"></a><p>一直以来都是对于事件与委托比较混淆，而且不太会用。找了个时间，总结了一下，感觉清晰了很多。</p><p>先说一下个人理解的结论吧：</p><blockquote><p>delegate是C#中的一种类型，它实际上是一个能够持有对某个方法的引用的类。</p></blockquote><p>delegate声明的变量与delegate声明的事件，并没有本质的区别，事件是在delegate声明变量的基础上包装而成的，类似于变量与属性的关系（在IL代码中可以看到每一个delegate声明的事件都对应是私有的delegate声明的变量），提升了安全性。</p><p>Action 与Func：这两个其实说白了就是系统定义好的Delegate，他有很多重载的方法，便于各种应用情况下的调用。他在系统的System命名空间下，因此全局可见。</p><p>首先了解一下， ILDasm中图标含义：<br><img alt data-src="/images/csharp-delegate/ILDasm.png"><br>该图来自：<a href="http://www.cnblogs.com/zery/p/3366175.html" target="_blank" rel="noopener">http://www.cnblogs.com/zery/p/3366175.html</a></p><p>委托创建步骤：</p><ol><li><font color="DeepPink">用delegate关键字创建一个委托，包括声明返回值和参数类型。</font></li><li><font color="DeepPink">使用的地方接收这个委托。</font></li><li><font color="DeepPink">创建这个委托的实例并指定一个返回值和参数类型匹配的方法传递过去。</font></li></ol><h1 id="一、事件与委托"><a href="#一、事件与委托" class="headerlink" title="一、事件与委托"></a>一、事件与委托</h1><p>新建一个事件委托测试项目：EventDelegateTest。</p><p>具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">namespace EventDelegateTest</span><br><span class="line">&#123;</span><br><span class="line">    public class TestClass</span><br><span class="line">    &#123;</span><br><span class="line">        public delegate int delegateAction();</span><br><span class="line">        public event delegateAction OnActionEvent;</span><br><span class="line">        public delegateAction daNew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译代码后，使用 Visual Studio 2010自带的ILDASM.EXE：<br><img alt data-src="/images/csharp-delegate/IL%E5%8F%8D%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F.png"></p><p>打开该dll，可以看到如下信息：<br><img alt data-src="/images/csharp-delegate/%E5%8F%8D%E7%BC%96%E8%AF%91DLL%E4%BF%A1%E6%81%AF.png"></p><p>从上图可以看出如下几点信息：</p><h2 id="1、delegate"><a href="#1、delegate" class="headerlink" title="1、delegate"></a>1、delegate</h2><p>委托 public delegate int delegateAction();在IL中是以类（delegateAction）的形式存在的<br>.NET将委托定义为一个密封类，派生自基类System.MulticastDelegate，并继承了基类的三个方法:<br><img alt data-src="/images/csharp-delegate/delegateAction.png"></p><h2 id="2、event"><a href="#2、event" class="headerlink" title="2、event"></a>2、event</h2><p>public event delegateAction OnActionEvent;在IL中不仅仅对应event OnActionEvent而且还对应一个field OnActionEvent;而field OnActionEvent与 public delegateAction daNew生成的field daNew是一样的.<br><img alt data-src="/images/csharp-delegate/OnActionEvent.png"><br><img alt data-src="/images/csharp-delegate/daNew.png"><br>都是以字段（field ）的形式存在的。<br>双击event OnActionEvent可以看到如下信息：<br><img alt data-src="/images/csharp-delegate/event-OnActionEvent.png"></p><p>在IL中事件被封装成了包含一个add_前缀和一个remove_前缀的的代码段。<br>其中，add_前缀的方法其实是通过调用Delegate.Combine()方法来实现的，组成了一个多播委托；remove_就是调用Delegate.Remove()方法，用于移除多播委托中的某个委托。</p><blockquote><p>也就是说：事件其实就是一个特殊的多播委托。</p></blockquote><p>那么对于事件进行这一次封装有什么好处呢？<br>1、因为delegate可以支持的操作非常多，比如我们可以写onXXXChanged += aaaFunc，把某个函数指针挂载到这个委托上面，但是我们也可以简单粗暴地直接写onXXXChanged = aaaFunc，让这个委托只包含这一个函数指针。不过这样一来会产生一个安全问题：如果我们用onXXXChanged = aaaFunc这样的写法，那么会把这个委托已拥有的其他函数指针给覆盖掉，这大概不是定义onXXXChanged的程序员想要看到的结果。</p><blockquote><p>小注：虽然事件不能直接=某个函数，也不可以直接=null</p></blockquote><p><img alt data-src="/images/csharp-delegate/event_not_null.png"></p><p>2、还有一个问题就是onXXXChanged这个委托应该什么时候触发（即调用它所包含的函数指针）。从面向对象的角度来说，XXX改变了这个事实（即onXXXChaned的字面含义）应该由包含它的那个对象来决定。但实际上我们可以从这个对象的外部环境调用onXXXChanged，这既产生了安全问题也不符合面向对象的初衷。<br>说到这里对于事件与委托的管理算是说明白了，那么平时常用的Action与Func，与委托又有什么关系呢？</p><h1 id="二、Action-与Func"><a href="#二、Action-与Func" class="headerlink" title="二、Action 与Func"></a>二、Action 与Func</h1><p><strong>Action 委托：封装一个方法，该方法具有参数（0到16个参数）并且不返回值。</strong><br>具体形式如下：<a href="https://msdn.microsoft.com/zh-cn/library/system.action(v=vs.110).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/system.action(v=vs.110).aspx</a><br><img alt data-src="/images/csharp-delegate/Action.png"></p><p><strong>Func&lt;T, TResult&gt; 委托：封装一个具有参数（0到16个参数）并返回 TResult 参数指定的类型值的方法。</strong><br>具体形式如下：<a href="https://msdn.microsoft.com/zh-cn/library/bb534960(v=vs.110).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/bb534960(v=vs.110).aspx</a><br><img alt data-src="/images/csharp-delegate/Func_T_TResult.png"></p><p>那么这Action与Func是怎么实现的呢？<br>1、Action（以Action&lt;T1, T2&gt; 委托：封装一个方法，该方法具有两个参数并且不返回值为例）<br>从微软公布的源码中，可以看到，如下实现：<br><img alt data-src="/images/csharp-delegate/Action_T.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Action&lt;bool,bool&gt;  ac;</span><br></pre></td></tr></table></figure><p>上面这个声明就是：该方法具有两个参数并且不返回值的委托。<br>其余使用方式与委托变量一样。<br>2、Func（以Func&lt;T1, T2, TResult&gt; 委托：封装一个具有两个参数并返回 TResult 参数指定的类型值的方法为例）<br>从微软公布的源码中，可以看到，如下实现：<br><img alt data-src="/images/csharp-delegate/Func_T_TResult_%E6%BA%90%E7%A0%81.png"></p><p>此处，可以看出Func与Action是类似的，唯一的区别就是，Func必须指定返回值的类型，使用方式与委托咱们自己使用委托变量是一样的，直接使用相应参数的Func或者Action声明变量，=或者+=挂载函数（方法即可）<br>这两个其实说白了就是系统定义好的Delegate，他有很多重载的方法，便于各种应用情况下的调用。他在系统的System命名空间下，因此全局可见。</p><h1 id="三、Predicate"><a href="#三、Predicate" class="headerlink" title="三、Predicate"></a>三、Predicate</h1><p><strong>是返回bool型的泛型委托，Predicate有且只有一个参数，返回值固定为bool。表示定义一组条件并确定指定对象是否符合这些条件的方法。</strong></p><p>此方法常在集合（Array 和 List<t>）的查找中被用到，如：数组，正则拼配的结果集中被用到。</t></p><p>官方文档：<br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.predicate-1?redirectedfrom=MSDN&amp;view=netframework-4.8" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/api/system.predicate-1?redirectedfrom=MSDN&amp;view=netframework-4.8</a></p><p>具体用法demo如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.ComponentModel;</span><br><span class="line">using System.Data;</span><br><span class="line">using System.Drawing;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Windows.Forms;</span><br><span class="line"> </span><br><span class="line">namespace IconTest</span><br><span class="line">&#123;</span><br><span class="line">    public partial class Form2 : Form</span><br><span class="line">    &#123;</span><br><span class="line">        Predicate&lt;int&gt; myPredicate;</span><br><span class="line">        int[] myNum = new int[8] &#123; 12, 33, 89, 21, 15, 29, 40, 52 &#125;;</span><br><span class="line">        public int[] myResult;</span><br><span class="line">        public Form2()</span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">            myPredicate = delegate(int curNum) 　　　　　　　　　　　　</span><br><span class="line">            &#123;</span><br><span class="line">                if (curNum % 2 == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        private void Form2_Load(object sender, EventArgs e)</span><br><span class="line">        &#123;</span><br><span class="line">            myResult = Array.FindAll(myNum, myPredicate);</span><br><span class="line">        &#125;          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中说明了Predicate的使用，FindAll方法中，参数2即是一个Predicate，在具体的执行中，每一个数组的元素都会执行指定的方法，如果满足要求返回true，并会被存放在结果集中，不符合的则被剔除，最终返回的集合，即是结果判断后想要的集合。<br>Array.FindAll 泛型方法：<br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.array.findall?redirectedfrom=MSDN&amp;view=netframework-4.8#System_Array_FindAll__1___0___System_Predicate___0" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/api/system.array.findall?redirectedfrom=MSDN&amp;view=netframework-4.8#System_Array_FindAll__1___0___System_Predicate___0</a>__<br>以上代码执行结果为：<br><img alt data-src="/images/csharp-delegate/Form2_Load.png"><br>那么Predicate<t>与委托又有什么关系呢？<br><img alt data-src="/images/csharp-delegate/Predicate_T.png"></t></p><p>从微软源码中可以看出Predicate<t>是返回bool型的泛型委托，从本质上来说与Func、Action、事件、委托变量并无本质区别。</t></p><h1 id="四、资料"><a href="#四、资料" class="headerlink" title="四、资料"></a>四、资料</h1><p>参考文章：<br><a href="http://www.zhihu.com/question/28932542" target="_blank" rel="noopener">http://www.zhihu.com/question/28932542</a></p><p>关于事件部分应用注意可以参考：<br><a href="http://www.cnblogs.com/buptzym/archive/2013/03/15/2962300.html" target="_blank" rel="noopener">http://www.cnblogs.com/buptzym/archive/2013/03/15/2962300.html</a></p><p>.NET Framework 源码：<br><a href="https://referencesource.microsoft.com" target="_blank" rel="noopener">https://referencesource.microsoft.com</a><br>Delegate 类:<br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.delegate?redirectedfrom=MSDN&amp;view=netframework-4.8" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/api/system.delegate?redirectedfrom=MSDN&amp;view=netframework-4.8</a></p><p><img alt data-src="/images/csharp-delegate/%E5%A7%94%E6%89%98%E5%9B%BE%E8%A7%A3.png"></p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Delegate </tag>
            
            <tag> Action </tag>
            
            <tag> Predicate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch 查询的秘密</title>
      <link href="/elasticsearch-query-secret.html"/>
      <url>/elasticsearch-query-secret.html</url>
      
        <content type="html"><![CDATA[<p>最近在参与一个基于Elasticsearch作为底层数据框架提供大数据量(亿级)的实时统计查询的方案设计工作，花了些时间学习Elasticsearch的基础理论知识，整理了一下，希望能对Elasticsearch感兴趣/想了解的同学有所帮助。<br>同时也希望有发现内容不正确或者有疑问的地方，望指明，一起探讨，学习，进步。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>Elasticsearch 是一个分布式可扩展的实时搜索和分析引擎.</p></blockquote><p>Elasticsearch 是一个建立在全文搜索引擎 Apache Lucene(TM) 基础上的搜索引擎.<br>当然 Elasticsearch 并不仅仅是 Lucene 那么简单，它不仅包括了全文搜索功能，还可以进行以下工作:</p><ul><li>分布式实时文件存储，并将每一个字段都编入索引，使其可以被搜索。</li><li>实时分析的分布式搜索引擎。</li><li>可以扩展到上百台服务器，处理PB级别的结构化或非结构化数据。</li></ul><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>先说Elasticsearch的文件存储，Elasticsearch是面向文档型数据库，一条数据在这里就是一个文档，用JSON作为文档序列化的格式，比如下面这条用户数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span> :     <span class="string">"John"</span>,</span><br><span class="line">    <span class="attr">"sex"</span> :      <span class="string">"Male"</span>,</span><br><span class="line">    <span class="attr">"age"</span> :      <span class="number">25</span>,</span><br><span class="line">    <span class="attr">"birthDate"</span>: <span class="string">"1990/05/01"</span>,</span><br><span class="line">    <span class="attr">"about"</span> :    <span class="string">"I love to go rock climbing"</span>,</span><br><span class="line">    <span class="attr">"interests"</span>: [ <span class="string">"sports"</span>, <span class="string">"music"</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用Mysql这样的数据库存储就会容易想到建立一张User表，有balabala的字段等，在Elasticsearch里这就是一个<em>文档</em>，当然这个文档会属于一个User的<em>类型</em>，各种各样的类型存在于一个<em>索引</em>当中。这里有一份简易的将Elasticsearch和关系型数据术语对照表:</p><p>关系数据库     ⇒ 数据库 ⇒ 表    ⇒ 行    ⇒ 列(Columns)</p><p>Elasticsearch  ⇒ 索引   ⇒ 类型  ⇒ 文档  ⇒ 字段(Fields)</p><p>一个 Elasticsearch 集群可以包含多个索引(数据库)，也就是说其中包含了很多类型(表)。这些类型中包含了很多的文档(行)，然后每个文档中又包含了很多的字段(列)。</p><p>Elasticsearch的交互，可以使用Java API，也可以直接使用HTTP的Restful API方式，比如我们打算插入一条记录，可以简单发送一个HTTP的请求：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT /megacorp/employee/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span> :     <span class="string">"John"</span>,</span><br><span class="line">    <span class="attr">"sex"</span> :      <span class="string">"Male"</span>,</span><br><span class="line">    <span class="attr">"age"</span> :      <span class="number">25</span>,</span><br><span class="line">    <span class="attr">"about"</span> :    <span class="string">"I love to go rock climbing"</span>,</span><br><span class="line">    <span class="attr">"interests"</span>: [ <span class="string">"sports"</span>, <span class="string">"music"</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新，查询也是类似这样的操作，具体操作手册可以参见<a href="http://www.learnes.net/data/README.html" target="_blank" rel="noopener">Elasticsearch权威指南</a></p><hr><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>Elasticsearch最关键的就是提供强大的索引能力了，其实InfoQ的这篇<a href="http://www.infoq.com/cn/articles/database-timestamp-02?utm_source=infoq&utm_medium=related_content_link&utm_campaign=relatedContent_articles_clk" target="_blank" rel="noopener">时间序列数据库的秘密(2)——索引</a>写的非常好，我这里也是围绕这篇结合自己的理解进一步梳理下，也希望可以帮助大家更好的理解这篇文章。</p><p>Elasticsearch索引的精髓：</p><blockquote><p>一切设计都是为了提高搜索的性能</p></blockquote><p>另一层意思：为了提高搜索的性能，难免会牺牲某些其他方面，比如插入/更新，否则其他数据库不用混了:)</p><p>前面看到往Elasticsearch里插入一条记录，其实就是直接PUT一个json的对象，这个对象有多个fields，比如上面例子中的<em>name, sex, age, about, interests</em>，那么在插入这些数据到Elasticsearch的同时，Elasticsearch还默默<a href="Elasticsearch默认会为每个字段根据value的类型分别建立索引，如果不想为某些字段建立索引或者不做分词分析的话，需要通过FieldMapping注明">^1</a>的为这些字段建立索引–倒排索引，因为Elasticsearch最核心功能是搜索。</p><h3 id="Elasticsearch是如何做到快速索引的"><a href="#Elasticsearch是如何做到快速索引的" class="headerlink" title="Elasticsearch是如何做到快速索引的"></a>Elasticsearch是如何做到快速索引的</h3><p>InfoQ那篇文章里说Elasticsearch使用的倒排索引比关系型数据库的B-Tree索引快，为什么呢？</p><h4 id="什么是B-Tree索引"><a href="#什么是B-Tree索引" class="headerlink" title="什么是B-Tree索引?"></a>什么是B-Tree索引?</h4><p>上大学读书时老师教过我们，二叉树查找效率是logN，同时插入新的节点不必移动全部节点，所以用树型结构存储索引，能同时兼顾插入和查询的性能。</p><p>因此在这个基础上，再结合磁盘的读取特性(顺序读/随机读)，传统关系型数据库采用了B-Tree/B+Tree这样的数据结构：</p><p><img alt data-src="/images/elasticsearch-query-secret/b-tree.png"></p><p>为了提高查询的效率，减少磁盘寻道次数，将多个值作为一个数组通过连续区间存放，一次寻道读取多个数据，同时也降低树的高度。</p><h4 id="什么是倒排索引"><a href="#什么是倒排索引" class="headerlink" title="什么是倒排索引?"></a>什么是倒排索引?</h4><p><img alt data-src="/images/elasticsearch-query-secret/inverted-index.png"></p><p>继续上面的例子，假设有这么几条数据(为了简单，去掉about, interests这两个field):</p><table><thead><tr><th>ID</th><th align="center">Name</th><th align="right">Age</th><th align="right">Sex</th></tr></thead><tbody><tr><td>1</td><td align="center">Kate</td><td align="right">24</td><td align="right">Female</td></tr><tr><td>2</td><td align="center">John</td><td align="right">24</td><td align="right">Male</td></tr><tr><td>3</td><td align="center">Bill</td><td align="right">29</td><td align="right">Male</td></tr></tbody></table><p>ID是Elasticsearch自建的文档id，那么Elasticsearch建立的索引如下:</p><p><strong>Name:</strong> </p><table><thead><tr><th>Term</th><th align="center">Posting List</th></tr></thead><tbody><tr><td>Kate</td><td align="center">1</td></tr><tr><td>John</td><td align="center">2</td></tr><tr><td>Bill</td><td align="center">3</td></tr></tbody></table><p><strong>Age:</strong></p><table><thead><tr><th>Term</th><th align="center">Posting List</th></tr></thead><tbody><tr><td>24</td><td align="center">[1,2]</td></tr><tr><td>29</td><td align="center">3</td></tr></tbody></table><p><strong>Sex:</strong></p><table><thead><tr><th>Term</th><th align="center">Posting List</th></tr></thead><tbody><tr><td>Female</td><td align="center">1</td></tr><tr><td>Male</td><td align="center">[2,3]</td></tr></tbody></table><h5 id="Posting-List"><a href="#Posting-List" class="headerlink" title="Posting List"></a>Posting List</h5><p>Elasticsearch分别为每个field都建立了一个倒排索引，Kate, John, 24, Female这些叫term，而[1,2]就是<strong>Posting List</strong>。Posting list就是一个int的数组，存储了所有符合某个term的文档id。</p><p>看到这里，不要认为就结束了，精彩的部分才刚开始…</p><p>通过posting list这种索引方式似乎可以很快进行查找，比如要找age=24的同学，爱回答问题的小明马上就举手回答：我知道，id是1，2的同学。但是，如果这里有上千万的记录呢？如果是想通过name来查找呢？</p><h5 id="Term-Dictionary"><a href="#Term-Dictionary" class="headerlink" title="Term Dictionary"></a>Term Dictionary</h5><p>Elasticsearch为了能快速找到某个term，将所有的term排个序，二分法查找term，logN的查找效率，就像通过字典查找一样，这就是<strong>Term Dictionary</strong>。现在再看起来，似乎和传统数据库通过B-Tree的方式类似啊，为什么说比B-Tree的查询快呢？</p><h5 id="Term-Index"><a href="#Term-Index" class="headerlink" title="Term Index"></a>Term Index</h5><p>B-Tree通过减少磁盘寻道次数来提高查询性能，Elasticsearch也是采用同样的思路，直接通过内存查找term，不读磁盘，但是如果term太多，term dictionary也会很大，放内存不现实，于是有了<strong>Term Index</strong>，就像字典里的索引页一样，A开头的有哪些term，分别在哪页，可以理解term index是一颗树：<br><img alt data-src="/images/elasticsearch-query-secret/term-index.png"></p><p>这棵树不会包含所有的term，它包含的是term的一些前缀。通过term index可以快速地定位到term dictionary的某个offset，然后从这个位置再往后顺序查找。<br><img alt data-src="/images/elasticsearch-query-secret/index.png"></p><p>所以term index不需要存下所有的term，而仅仅是他们的一些前缀与Term Dictionary的block之间的映射关系，再结合FST(Finite State Transducers)的压缩技术，可以使term index缓存到内存中。从term index查到对应的term dictionary的block位置之后，再去磁盘上找term，大大减少了磁盘随机读的次数。</p><p>这时候爱提问的小明又举手了:”那个FST是神马东东啊?”</p><p>一看就知道小明是一个上大学读书的时候跟我一样不认真听课的孩子，数据结构老师一定讲过什么是FST。但没办法，我也忘了，这里再补下课：</p><blockquote><p>FSTs are finite-state machines that <strong>map</strong> a <strong>term (byte sequence)</strong> to an arbitrary <strong>output</strong>.</p></blockquote><p>假设我们现在要将mop, moth, pop, star, stop and top(term index里的term前缀)映射到序号：0，1，2，3，4，5(term dictionary的block位置)。最简单的做法就是定义个Map&lt;String, Integer&gt;，大家找到自己的位置对应入座就好了，但从内存占用少的角度想想，有没有更优的办法呢？答案就是：<strong>FST</strong>(<a href="http://www.cs.nyu.edu/~mohri/pub/fla.pdf" target="_blank" rel="noopener">理论依据在此，但我相信99%的人不会认真看完的</a>)</p><p><img alt data-src="/images/elasticsearch-query-secret/fst.png"></p><p>⭕️表示一种状态</p><p>–&gt;表示状态的变化过程，上面的字母/数字表示状态变化和权重</p><p>将单词分成单个字母通过⭕️和–&gt;表示出来，0权重不显示。如果⭕️后面出现分支，就标记权重，最后整条路径上的权重加起来就是这个单词对应的序号。</p><blockquote><p>FSTs are finite-state machines that map a term (<strong>byte sequence</strong>) to an arbitrary output.</p></blockquote><p>FST以字节的方式存储所有的term，这种压缩方式可以有效的缩减存储空间，使得term index足以放进内存，但这种方式也会导致查找时需要更多的CPU资源。</p><p>后面的更精彩，看累了的同学可以喝杯咖啡……</p><hr><h4 id="压缩技巧"><a href="#压缩技巧" class="headerlink" title="压缩技巧"></a>压缩技巧</h4><p>Elasticsearch里除了上面说到用FST压缩term index外，对posting list也有压缩技巧。<br>小明喝完咖啡又举手了:”posting list不是已经只存储文档id了吗？还需要压缩？” </p><p>嗯，我们再看回最开始的例子，如果Elasticsearch需要对同学的性别进行索引(这时传统关系型数据库已经哭晕在厕所……)，会怎样？如果有上千万个同学，而世界上只有男/女这样两个性别，每个posting list都会有至少百万个文档id。<br>Elasticsearch是如何有效的对这些文档id压缩的呢？</p><h5 id="Frame-Of-Reference"><a href="#Frame-Of-Reference" class="headerlink" title="Frame Of Reference"></a>Frame Of Reference</h5><blockquote><p>增量编码压缩，将大数变小数，按字节存储</p></blockquote><p>首先，Elasticsearch要求posting list是有序的(为了提高搜索的性能，再任性的要求也得满足)，这样做的一个好处是方便压缩，看下面这个图例：<br><img alt data-src="/images/elasticsearch-query-secret/frameOfReference.png"></p><p>如果数学不是体育老师教的话，还是比较容易看出来这种压缩技巧的。</p><p>原理就是通过增量，将原来的大数变成小数仅存储增量值，再精打细算按bit排好队，最后通过字节存储，而不是大大咧咧的尽管是2也是用int(4个字节)来存储。</p><h5 id="Roaring-bitmaps"><a href="#Roaring-bitmaps" class="headerlink" title="Roaring bitmaps"></a>Roaring bitmaps</h5><p>说到Roaring bitmaps，就必须先从bitmap说起。Bitmap是一种数据结构，假设有某个posting list：</p><p>[1,3,4,7,10]</p><p>对应的bitmap就是：</p><p>[1,0,1,1,0,0,1,0,0,1]</p><p>非常直观，用0/1表示某个值是否存在，比如10这个值就对应第10位，对应的bit值是1，这样用一个字节就可以代表8个文档id，旧版本(5.0之前)的Lucene就是用这样的方式来压缩的，但这样的压缩方式仍然不够高效，如果有1亿个文档，那么需要12.5MB的存储空间，这仅仅是对应一个索引字段(我们往往会有很多个索引字段)。于是有人想出了Roaring bitmaps这样更高效的数据结构。</p><p>Bitmap的缺点是存储空间随着文档个数线性增长，Roaring bitmaps需要打破这个魔咒就一定要用到某些指数特性：</p><p>将posting list按照65535为界限分块，比如第一块所包含的文档id范围在0<del>65535之间，第二块的id范围是65536</del>131071，以此类推。再用&lt;商，余数&gt;的组合表示每一组id，这样每组里的id范围都在0~65535内了，剩下的就好办了，既然每组id不会变得无限大，那么我们就可以通过最有效的方式对这里的id存储。</p><p><img alt data-src="/images/elasticsearch-query-secret/Roaringbitmaps.png"></p><p>细心的小明这时候又举手了:”为什么是以65535为界限?”</p><p>程序员的世界里除了1024外，65535也是一个经典值，因为它=2^16-1，正好是用2个字节能表示的最大数，一个short的存储单位，注意到上图里的最后一行“If a block has more than 4096 values, encode as a bit set, and otherwise as a simple array using 2 bytes per value”，如果是大块，用节省点用bitset存，小块就豪爽点，2个字节我也不计较了，用一个short[]存着方便。</p><p>那为什么用4096来区分采用数组还是bitmap的阀值呢？</p><p>这个是从内存大小考虑的，当block块里元素超过4096后，用bitmap更剩空间：<br>采用bitmap需要的空间是恒定的: 65536/8 = 8192bytes<br>而如果采用short[]，所需的空间是: 2*N(N为数组元素个数)<br>小明手指一掐N=4096刚好是边界:</p><p><img alt data-src="/images/elasticsearch-query-secret/block-memory.png"></p><hr><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>上面说了半天都是单field索引，如果多个field索引的联合查询，倒排索引如何满足快速查询的要求呢？</p><ul><li>利用跳表(Skip list)的数据结构快速做“与”运算，或者</li><li>利用上面提到的bitset按位“与”</li></ul><p>先看看跳表的数据结构：</p><p><img alt data-src="/images/elasticsearch-query-secret/skiplist.png"></p><p>将一个有序链表level0，挑出其中几个元素到level1及level2，每个level越往上，选出来的指针元素越少，查找时依次从高level往低查找，比如55，先找到level2的31，再找到level1的47，最后找到55，一共3次查找，查找效率和2叉树的效率相当，但也是用了一定的空间冗余来换取的。</p><p>假设有下面三个posting list需要联合索引：</p><p><img alt data-src="/images/elasticsearch-query-secret/combineIndex.png"></p><p>如果使用跳表，对最短的posting list中的每个id，逐个在另外两个posting list中查找看是否存在，最后得到交集的结果。</p><p>如果使用bitset，就很直观了，直接按位与，得到的结果就是最后的交集。</p><hr><h3 id="总结和思考"><a href="#总结和思考" class="headerlink" title="总结和思考"></a>总结和思考</h3><p>Elasticsearch的索引思路:</p><blockquote><p>将磁盘里的东西尽量搬进内存，减少磁盘随机读取次数(同时也利用磁盘顺序读特性)，结合各种奇技淫巧的压缩算法，用及其苛刻的态度使用内存。</p></blockquote><p>所以，对于使用Elasticsearch进行索引时需要注意:</p><ul><li>不需要索引的字段，一定要明确定义出来，因为默认是自动建索引的</li><li>同样的道理，对于String类型的字段，不需要analysis的也需要明确定义出来，因为默认也是会analysis的</li><li>选择有规律的ID很重要，随机性太大的ID(比如java的UUID)不利于查询</li></ul><p>关于最后一点，个人认为有多个因素:</p><p>其中一个(也许不是最重要的)因素: 上面看到的压缩算法，都是对Posting list里的大量ID进行压缩的，那如果ID是顺序的，或者是有公共前缀等具有一定规律性的ID，压缩比会比较高；</p><p>另外一个因素: 可能是最影响查询性能的，应该是最后通过Posting list里的ID到磁盘中查找Document信息的那步，因为Elasticsearch是分Segment存储的，根据ID这个大范围的Term定位到Segment的效率直接影响了最后查询的性能，如果ID是有规律的，可以快速跳过不包含该ID的Segment，从而减少不必要的磁盘读次数，具体可以参考这篇<a href="http://blog.mikemccandless.com/2014/05/choosing-fast-unique-identifier-uuid.html" target="_blank" rel="noopener">如何选择一个高效的全局ID方案</a>(评论也很精彩)</p><p>后续再结合实际开发及调优工作分享更多内容，敬请期待！</p><hr><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://neway6655.github.io/elasticsearch/2015/09/11/elasticsearch-study-notes.html" target="_blank" rel="noopener">Elasticsearch 学习笔记</a></p>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解 Go Channels</title>
      <link href="/go-channels.html"/>
      <url>/go-channels.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、视频信息"><a href="#一、视频信息" class="headerlink" title="一、视频信息"></a>一、视频信息</h1><h2 id="1、视频观看地址"><a href="#1、视频观看地址" class="headerlink" title="1、视频观看地址"></a>1、视频观看地址</h2><p><a href="https://www.youtube.com/watch?v=KBZlN0izeiY" target="_blank" rel="noopener">https://www.youtube.com/watch?v=KBZlN0izeiY</a></p><h2 id="2、PPT下载地址"><a href="#2、PPT下载地址" class="headerlink" title="2、PPT下载地址"></a>2、PPT下载地址</h2><p><a href="http://download.csdn.net/download/xunzaosiyecao/10212884" target="_blank" rel="noopener">http://download.csdn.net/download/xunzaosiyecao/10212884</a></p><h2 id="3、博文"><a href="#3、博文" class="headerlink" title="3、博文"></a>3、博文</h2><p><a href="https://about.sourcegraph.com/go/understanding-channels-kavya-joshi/" target="_blank" rel="noopener">https://about.sourcegraph.com/go/understanding-channels-kavya-joshi/</a></p><h1 id="二、Go-的并发特性"><a href="#二、Go-的并发特性" class="headerlink" title="二、Go 的并发特性"></a>二、Go 的并发特性</h1><ul><li>goroutines: 独立执行每个任务，并可能<font color="DeepPink">并行执行</font></li><li>channels: 用于 goroutines 之间的通讯、同步</li></ul><h2 id="1、一个简单的事务处理的例子"><a href="#1、一个简单的事务处理的例子" class="headerlink" title="1、一个简单的事务处理的例子"></a>1、一个简单的事务处理的例子</h2><p>对于下面这样的非并发的程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">  tasks := getTasks()</span><br><span class="line">  // 处理每个任务</span><br><span class="line">  for _, task := range tasks &#123;</span><br><span class="line">    process(task)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将其转换为 Go 的并发模式很容易，使用典型的 Task Queue 的模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">  //  创建带缓冲的 channel</span><br><span class="line">  ch := make(chan Task, 3)</span><br><span class="line">  //  运行固定数量的 workers</span><br><span class="line">  for i := 0; i &lt; numWorkers; i++ &#123;</span><br><span class="line">    go worker(ch)</span><br><span class="line">  &#125;</span><br><span class="line">  //  发送任务到 workers</span><br><span class="line">  hellaTasks := getTasks()</span><br><span class="line">  for _, task := range hellaTasks &#123;</span><br><span class="line">    ch &lt;- task</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">func worker(ch chan Task) &#123;</span><br><span class="line">  for &#123;</span><br><span class="line">    //  接收任务</span><br><span class="line">    task := &lt;-ch</span><br><span class="line">    process(task)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2、channels-的特性"><a href="#2、channels-的特性" class="headerlink" title="2、channels 的特性"></a>2、channels 的特性</h1><ul><li>goroutine-safe，多个 goroutine 可以同时访问一个 channel。</li><li>可以用于在 goroutine 之间存储和传递值</li><li>其语义是先入先出（FIFO）</li><li>可以导致 goroutine 的 block 和 unblock</li></ul><h1 id="三、解析"><a href="#三、解析" class="headerlink" title="三、解析"></a>三、解析</h1><h2 id="1、构造-channel"><a href="#1、构造-channel" class="headerlink" title="1、构造 channel"></a>1、构造 channel</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//  带缓冲的 channel</span><br><span class="line">ch := make(chan Task, 3)</span><br><span class="line">//  无缓冲的 channel</span><br><span class="line">ch := make(chan Task)</span><br></pre></td></tr></table></figure><p>回顾前面提到的 channel 的特性，特别是前两个。如果忽略内置的 channel，让你设计一个具有 goroutines-safe 并且可以用来存储、传递值的东西，你会怎么做？很多人可能觉得或许可以用一个带锁的队列来做。没错，事实上，channel 内部就是一个带锁的队列。<br><a href="https://golang.org/src/runtime/chan.go" target="_blank" rel="noopener">https://golang.org/src/runtime/chan.go</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type hchan struct &#123;</span><br><span class="line">  ...</span><br><span class="line">  buf      unsafe.Pointer // 指向一个环形队列</span><br><span class="line">  ...</span><br><span class="line">  sendx    uint   // 发送 index</span><br><span class="line">  recvx    uint   // 接收 index</span><br><span class="line">  ...</span><br><span class="line">  lock     mutex  //  互斥量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>buf 的具体实现很简单，就是一个环形队列的实现。sendx 和 recvx 分别用来记录发送、接收的位置。然后用一个 lock 互斥锁来确保无竞争冒险。</p><p>对于每一个 ch := make(chan Task, 3) 这类操作，都会在<font color="DeepPink">堆</font>中，分配一个空间，建立并初始化一个 hchan 结构变量，而 ch 则是指向这个 hchan 结构的<font color="DeepPink">指针</font>。</p><p>因为 ch 本身就是个指针，所以我们才可以在 goroutine 函数调用的时候直接将 ch 传递过去，而不用再 &amp;ch 取指针了，所以所有使用同一个 ch 的 goroutine 都指向了同一个实际的内存空间。</p><h2 id="2、发送、接收"><a href="#2、发送、接收" class="headerlink" title="2、发送、接收"></a>2、发送、接收</h2><p>为了方便描述，我们用 G1 表示 main() 函数的 goroutine，而 G2 表示 worker 的 goroutine。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// G1</span><br><span class="line">func main() &#123;</span><br><span class="line">  ...</span><br><span class="line">  for _, task := range tasks &#123;</span><br><span class="line">    ch &lt;- task</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">// G2</span><br><span class="line">func worker(ch chan Task) &#123;</span><br><span class="line">  for &#123;</span><br><span class="line">    task :=&lt;-ch</span><br><span class="line">    process(task)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-简单的发送、接收"><a href="#2-1-简单的发送、接收" class="headerlink" title="2.1 简单的发送、接收"></a>2.1 简单的发送、接收</h3><p>那么 G1 中的 ch &lt;- task0 具体是怎么做的呢？</p><ul><li>获取锁</li><li>enqueue(task0)（这里是内存复制 task0）</li><li>释放锁</li></ul><p>这一步很简单，接下来看 G2 的 t := &lt;- ch 是如何读取数据的。</p><ul><li>获取锁</li><li>t = dequeue()（同样，这里也是内存复制）</li><li>释放锁</li></ul><p>这一步也非常简单。但是我们从这个操作中可以看到，所有 goroutine 中共享的部分只有这个 hchan 的结构体，而所有通讯的数据都是<font color="DeepPink">内存复制</font>。这遵循了 Go 并发设计中很核心的一个理念：</p><blockquote><p>Do not communicate by sharing memory;instead, share memory by communicating</p></blockquote><p>内存复制指的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// typedmemmove copies a value of type t to dst from src.</span><br><span class="line">// Must be nosplit, see #16026.</span><br><span class="line">//go:nosplit</span><br><span class="line">func typedmemmove(typ *_type, dst, src unsafe.Pointer) &#123;</span><br><span class="line">    if typ.kind&amp;kindNoPointers == 0 &#123;</span><br><span class="line">        bulkBarrierPreWrite(uintptr(dst), uintptr(src), typ.size)</span><br><span class="line">    &#125;</span><br><span class="line">    // There&apos;s a race here: if some other goroutine can write to</span><br><span class="line">    // src, it may change some pointer in src after we&apos;ve</span><br><span class="line">    // performed the write barrier but before we perform the</span><br><span class="line">    // memory copy. This safe because the write performed by that</span><br><span class="line">    // other goroutine must also be accompanied by a write</span><br><span class="line">    // barrier, so at worst we&apos;ve unnecessarily greyed the old</span><br><span class="line">    // pointer that was in src.</span><br><span class="line">    memmove(dst, src, typ.size)</span><br><span class="line">    if writeBarrier.cgo &#123;</span><br><span class="line">        cgoCheckMemmove(typ, dst, src, 0, typ.size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3、阻塞和恢复"><a href="#3、阻塞和恢复" class="headerlink" title="3、阻塞和恢复"></a>3、阻塞和恢复</h1><h2 id="3-1-发送方被阻塞"><a href="#3-1-发送方被阻塞" class="headerlink" title="3.1 发送方被阻塞"></a>3.1 发送方被阻塞</h2><p>假设 G2 需要很长时间的处理，在此期间，G1 不断的发送任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- task1</span><br><span class="line">ch &lt;- task2</span><br><span class="line">ch &lt;- task3</span><br></pre></td></tr></table></figure><p>但是当再一次 ch &lt;- task4 的时候，由于 ch 的缓冲只有 3 个，所以没有地方放了，于是 G1 被 block 了，当有人从队列中取走一个 Task 的时候，G1 才会被恢复。这是我们都知道的，不过我们今天关心的不是发生了什么，而是如何做到的？</p><h2 id="3-2-goroutine-的运行时调度"><a href="#3-2-goroutine-的运行时调度" class="headerlink" title="3.2 goroutine 的运行时调度"></a>3.2 goroutine 的运行时调度</h2><p>首先，goroutine <font color="DeepPink">不是操作系统线程</font>，而是 <font color="DeepPink">用户空间线程</font>。因此 goroutine 是由 Go runtime 来创建并管理的，而不是 OS，所以要比操作系统线程轻量级。</p><p>当然，goroutine 最终还是要运行于某个线程中的，控制 goroutine 如何运行于线程中的是 Go runtime 中的 scheduler （调度器）。</p><p>Go 的运行时调度器是 M:N 调度模型，既 N 个 goroutine，会运行于 M 个 OS 线程中。换句话说，一个 OS 线程中，可能会运行多个 goroutine。</p><p>Go 的 M:N 调度中使用了3个结构：</p><ul><li>M: OS 线程</li><li>G: goroutine</li><li>P: 调度上下文<ul><li>P 拥有一个运行队列，里面是所有可以运行的 goroutine 及其上下文</li></ul></li></ul><h2 id="3-3-goroutine-被阻塞的具体过程"><a href="#3-3-goroutine-被阻塞的具体过程" class="headerlink" title="3.3 goroutine 被阻塞的具体过程"></a>3.3 goroutine 被阻塞的具体过程</h2><p>那么当 ch &lt;- task4 执行的时候，channel 中已经满了，需要 <font color="DeepPink">pause</font> G1。这个时候：</p><ol><li>G1 会调用运行时的 gopark</li><li>然后 Go 的运行时调度器就会接管</li><li>将 G1 的状态设置为 waiting</li><li>断开 G1 和 M 之间的关系（switch out)，因此 G1 脱离 M，换句话说，M 空闲了，可以安排别的任务了。</li><li>从 P 的运行队列中，取得一个可运行的 goroutine G</li><li>建立新的 G 和 M 的关系（Switch in)，因此 G 就准备好运行了。</li><li>当调度器返回的时候，新的 G 就开始运行了，而 G1 则不会运行，也就是 block 了。</li></ol><p>从上面的流程中可以看到，<font color="DeepPink">对于 goroutine 来说，G1 被阻塞了，新的 G 开始运行了；而对于操作系统线程 M 来说，则根本没有被阻塞。</font></p><p>我们知道 OS 线程要比 goroutine 要沉重的多，因此这里尽量避免 OS 线程阻塞，可以提高性能。</p><h2 id="3-4-goroutine-恢复执行的具体过程"><a href="#3-4-goroutine-恢复执行的具体过程" class="headerlink" title="3.4 goroutine 恢复执行的具体过程"></a>3.4 goroutine 恢复执行的具体过程</h2><p>前面理解了阻塞，那么接下来理解一下如何恢复运行。不过，在继续了解如何恢复之前，我们需要先进一步理解 hchan 这个结构。因为，当 channel 不在满的时候，调度器是如何知道该让哪个 goroutine 继续运行呢？而且 goroutine 又是如何知道该从哪取数据呢？</p><p>在 hchan 中，除了之前提到的内容外，还定义有 sendq 和 recvq 两个队列，分别表示等待发送、接收的 goroutine，及其相关信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type hchan struct &#123;</span><br><span class="line">  ...</span><br><span class="line">  buf      unsafe.Pointer // 指向一个环形队列</span><br><span class="line">  ...</span><br><span class="line">  sendq    waitq  // 等待发送的队列</span><br><span class="line">  recvq    waitq  // 等待接收的队列</span><br><span class="line">  ...</span><br><span class="line">  lock     mutex  //  互斥量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 waitq 是一个链表结构的队列，每个元素是一个 sudog 的结构，其定义大致为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type sudog struct &#123;</span><br><span class="line">  g          *g //  正在等候的 goroutine</span><br><span class="line">  elem       unsafe.Pointer // 指向需要接收、发送的元素</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://golang.org/src/runtime/runtime2.go?h=sudog#L270" target="_blank" rel="noopener">https://golang.org/src/runtime/runtime2.go?h=sudog#L270</a></p><p>所以在之前的阻塞 G1 的过程中，实际上：</p><ol><li>G1 会<font color="DeepPink">给自己</font>创建一个 sudog 的变量</li><li>然后追加到 sendq 的等候队列中，方便将来的<font color="DeepPink">receiver</font> 来使用这些信息恢复 G1。</li></ol><p>这些都是<font color="DeepPink">发生在调用调度器之前</font>。</p><p>那么现在开始看一下如何恢复。</p><p>当 G2 调用 t := &lt;- ch 的时候，channel 的状态是，缓冲是满的，而且还有一个 G1 在等候发送队列里，然后 G2 执行下面的操作：</p><ol><li>G2 先执行 dequeue() 从缓冲队列中取得 task1 给 t</li><li>G2 从 sendq 中弹出一个等候发送的 sudog</li><li>将弹出的 sudog 中的 elem 的值 enqueue() 到 buf 中</li><li>将弹出的 sudog 中的 goroutine，也就是 G1，状态从 waiting 改为 runnable<ol><li>然后，G2 需要通知调度器 G1 已经可以进行调度了，因此调用 goready(G1)。</li><li>调度器将 G1 的状态改为 runnable</li><li>调度器将 G1 压入 P 的运行队列，因此在将来的某个时刻调度的时候，G1 就会开始恢复运行。</li><li>返回到 G2<blockquote><p>注意，这里是由 G2 来负责将 G1 的 elem 压入 buf 的，这是一个优化。这样将来 G1 恢复运行后，就不必再次获取锁、enqueue()、释放锁了。这样就避免了多次锁的开销。</p></blockquote></li></ol></li></ol><h3 id="3-5-如果接收方先阻塞呢？"><a href="#3-5-如果接收方先阻塞呢？" class="headerlink" title="3.5 如果接收方先阻塞呢？"></a>3.5 如果接收方先阻塞呢？</h3><p>更酷的地方是接收方先阻塞的流程。</p><p>如果 G2 先执行了 t := &lt;- ch，此时 buf 是空的，因此 G2 会被阻塞，他的流程是这样：</p><ol><li>G2 给自己创建一个 sudog 结构变量。其中 g 是自己，也就是 G2，而 elem 则指向 t</li><li>将这个 sudog 变量压入 recvq 等候接收队列</li><li>G2 需要告诉 goroutine，自己需要 pause 了，于是调用 gopark(G2) <ol><li>和之前一样，调度器将其 G2 的状态改为 waiting</li><li>断开 G2 和 M 的关系</li><li>从 P 的运行队列中取出一个 goroutine</li><li>建立新的 goroutine 和 M 的关系</li><li>返回，开始继续运行新的 goroutine</li></ol></li></ol><p>这些应该已经不陌生了，那么当 G1 开始发送数据的时候，流程是什么样子的呢？</p><p>G1 可以将 enqueue(task)，然后调用 goready(G2)。不过，我们可以更聪明一些。</p><p>我们根据 hchan 结构的状态，已经知道 task 进入 buf 后，G2 恢复运行后，会读取其值，复制到 t 中。那么 G1 可以根本不走 buf，<font color="DeepPink">G1 可以直接把数据给 G2</font>。</p><p>Goroutine 通常都有自己的栈，互相之间不会访问对方的栈内数据，<font color="DeepPink">除了 channel</font>。这里，由于我们已经知道了 t 的地址（通过 elem指针），而且由于 G2 不在运行，所以我们可以很安全的直接赋值。当 G2 恢复运行的时候，既不需要再次获取锁，也不需要对 buf 进行操作。从而节约了内存复制、以及锁操作的开销。</p><h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><ul><li><p>goroutine-safe</p><ul><li>hchan 中的 lock mutex</li></ul></li><li><p>存储、传递值，FIFO</p><ul><li>通过 hchan 中的环形缓冲区来实现</li></ul></li><li><p>导致 goroutine 的阻塞和恢复</p><ul><li>hchan 中的 sendq和recvq，也就是 sudog 结构的链表队列</li><li>调用运行时调度器 (gopark(), goready())<h1 id="四、其它-channel-的操作"><a href="#四、其它-channel-的操作" class="headerlink" title="四、其它 channel 的操作"></a>四、其它 channel 的操作</h1><h2 id="1、无缓冲-channel"><a href="#1、无缓冲-channel" class="headerlink" title="1、无缓冲 channel"></a>1、无缓冲 channel</h2>无缓冲的 channel 行为就和前面说的<font color="DeepPink">直接发送</font>的例子一样：</li></ul></li><li><p>接收方阻塞 → 发送方<font color="DeepPink">直接写入接收方的栈</font></p></li><li><p>发送方阻塞 → 接受法<font color="DeepPink">直接从发送方的 sudog 中读取</font></p></li></ul><h2 id="2、select"><a href="#2、select" class="headerlink" title="2、select"></a>2、select</h2><p><a href="https://golang.org/src/runtime/select.go" target="_blank" rel="noopener">https://golang.org/src/runtime/select.go</a></p><ol><li>先把所有需要操作的 channel 上锁</li><li>给自己创建一个 sudog，然后添加到所有 channel 的 sendq或recvq（取决于是发送还是接收）</li><li>把所有的 channel 解锁，然后 pause 当前调用 select 的 goroutine（gopark()）</li><li>然后当有任意一个 channel 可用时，select 的这个 goroutine 就会被调度执行。</li><li>resuming mirrors the pause sequence</li></ol><p>五、为什么 Go 会这样设计？<br>1、Simplicity<br>更倾向于带锁的队列，而不是无锁的实现。</p><p>性能提升不是凭空而来的，是随着复杂度增加而增加的。</p><p>dvyokov<br>后者虽然性能可能会更好，但是这个优势，并不一定能够战胜随之而来的实现代码的复杂度所带来的劣势。</p><h2 id="2、Performance"><a href="#2、Performance" class="headerlink" title="2、Performance"></a>2、Performance</h2><ul><li>调用 Go 运行时调度器，这样可以保持 OS 线程不被阻塞跨 goroutine 的栈读、写。</li><li>可以让 goroutine 醒来后不必获取锁。</li><li>可以避免一些内存复制。</li></ul><p>当然，<font color="DeepPink">任何优势都会有其代价</font>。这里的代价是实现的复杂度，所以这里有更复杂的内存管理机制、垃圾回收以及栈收缩机制。</p><p>在这里性能的提高优势，要比复杂度的提高带来的劣势要大。</p><p>所以在 channel 实现的各种代码中，我们都可以见到这种<font color="DeepPink">simplicity vs performance</font> 的权衡后的结果。</p><blockquote><p>本文转载自：<br><a href="https://blog.lab99.org/post/golang-2017-10-04-video-understanding-channels.html#fa-song-jie-shou" target="_blank" rel="noopener">https://blog.lab99.org/post/golang-2017-10-04-video-understanding-channels.html#fa-song-jie-shou</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Channel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[译]ZGC: 一个可伸缩的低延迟垃圾收集器</title>
      <link href="/zgc-a-scalable-low-latency-garbage-collector.html"/>
      <url>/zgc-a-scalable-low-latency-garbage-collector.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>翻译自：JEP 333</p></blockquote><a id="more"></a><blockquote><p>地址：<a href="https://openjdk.java.net/jeps/333" target="_blank" rel="noopener">https://openjdk.java.net/jeps/333</a></p></blockquote><h1 id="一、摘要"><a href="#一、摘要" class="headerlink" title="一、摘要"></a>一、摘要</h1><p>Z垃圾收集器，也称为ZGC，是一个可伸缩的低延迟垃圾收集器。</p><h1 id="二、目标"><a href="#二、目标" class="headerlink" title="二、目标"></a>二、目标</h1><ul><li>GC暂停时间不超过10ms</li><li>能处理大小从相对较小(几百MB)到非常大(TB级)的堆</li><li>与使用G1相比，应用程序吞吐量减少不超过15%</li><li>方便日后在此基础上利用彩色指针和内存屏障进一步优化收集器及实现新特性。【原文：Lay a foundation for future GC features and optimizations leveraging colored pointers and load barriers】</li><li>支持平台:Linux/x64</li></ul><blockquote><p>注：此处及下文中的内存屏障即load barrier，在ZGC中用的是读屏障。</p></blockquote><h1 id="三、动机"><a href="#三、动机" class="headerlink" title="三、动机"></a>三、动机</h1><p>垃圾收集是Java的主要优势之一。但是，当垃圾收集暂停太长时，就会对应用程序的响应时间产生负面影响。通过大幅度缩短停顿时间，我们可以让Java适用于更多类型的应用程序。</p><p>此外，现代系统中可用的内存数量还在继续增长。<strong>用户和应用程序开发人员希望JVM能够以一种有效的方式充分利用这种内存，并且不会出现很长的GC暂停时间。</strong></p><h1 id="四、-描述"><a href="#四、-描述" class="headerlink" title="四、 描述"></a>四、 描述</h1><p>ZGC是一个并发的、单代（不再区分新生代和老年代）的、基于region的、支持numa的压缩收集器。Stop-the-world阶段仅限于根扫描，所以GC暂停时间不会随着堆或存活对象的多少而增加。</p><p><font color="DeepPink">ZGC的一个核心设计原则是结合使用内存屏障和彩色对象指针。这使得ZGC能够在运行Java应用程序线程时执行并发操作，比如对象重定位。从Java线程的角度来看，在Java对象中加载引用字段的行为受到内存屏障的限制。除了对象地址之外，有色对象指针还包含内存屏障需要的信息，用于确定在允许Java线程使用该指针之前是否需要采取某些操作。</font>例如，对象可能已经被重新定位，在这种情况下，内存屏障将检测情况并采取适当的操作。</p><p>与其他技术相比，我们认为颜色指针方案提供了一些非常吸引人的特性。特别是:</p><ul><li><p>这允许我们在移动对象/整理内存阶段，在指向可回收/重用区域的指针确定之前回收/重用这部分内存【原文：It allows us to reclaim and reuse memory during the relocation/compaction phase, before pointers pointing into the reclaimed/reused regions have been fixed. 】。这有助于降低堆开销。这还意味着不需要实现单独的标记压缩算法来处理完整的GC。</p></li><li><p>这允许我们使用相对较少且简单的GC屏障。这有助于降低运行时开销。这还意味着在解释器和JIT编译器中更容易实现、优化和维护GC barrier代码。</p></li><li><p>我们目前将标记和重新定位相关信息存储在彩色指针中。然而，此方案的通用性允许我们存储任何类型的信息(只要我们能将其放入指针中)，并允许内存屏障根据该信息采取它想要采取的任何操作。我们相信这将为将来的许多特性打下基础。举一个例子，在异构内存环境中，这可以用来跟踪堆访问模式，以指导GC重新定位决策，将很少使用的对象移动到冷存储(不常访问的内存区域)中【原文：To pick one example, in a heterogeneous memory environment, this could be used to track heap access patterns to guide GC relocation decisions to move rarely used objects to cold storage.】。</p></li></ul><h1 id="五、性能"><a href="#五、性能" class="headerlink" title="五、性能"></a>五、性能</h1><p>我们已经使用SPECjbb 2015[1]做了常规性能测试。从吞吐量和延迟角度来看，性能都很好。下面是使用128G堆在复合模式下比较ZGC和G1的典型基准分数(以百分比为单位，根据ZGC的max-jOPS进行标准化)【原文：Below are typical benchmark scores (in percent, normalized against ZGC’s max-jOPS), comparing ZGC and G1, in composite mode using a 128G heap.】：</p><blockquote><p>越高越好</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ZGC</span><br><span class="line">       max-jOPS: 100%</span><br><span class="line">  critical-jOPS: 76.1%</span><br><span class="line"></span><br><span class="line">G1</span><br><span class="line">       max-jOPS: 91.2%</span><br><span class="line">  critical-jOPS: 54.7%</span><br></pre></td></tr></table></figure><p>下面是来自相同基准测试的GC暂停时间。ZGC设法保持远低于10ms的目标。注意，确切的数字可能会根据使用的机器和设置而变化(上下都有，但不是很明显)。</p><blockquote><p>越低越好</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ZGC</span><br><span class="line">                avg: 1.091ms (+/-0.215ms)</span><br><span class="line">    95th percentile: 1.380ms</span><br><span class="line">    99th percentile: 1.512ms</span><br><span class="line">  99.9th percentile: 1.663ms</span><br><span class="line"> 99.99th percentile: 1.681ms</span><br><span class="line">                max: 1.681ms</span><br><span class="line"></span><br><span class="line">G1</span><br><span class="line">                avg: 156.806ms (+/-71.126ms)</span><br><span class="line">    95th percentile: 316.672ms</span><br><span class="line">    99th percentile: 428.095ms</span><br><span class="line">  99.9th percentile: 543.846ms</span><br><span class="line"> 99.99th percentile: 543.846ms</span><br><span class="line">                max: 543.846ms</span><br></pre></td></tr></table></figure><p>我们还对其他各种SPEC®基准测试和内部工作负载进行了特别的性能测量。一般情况下，ZGC能够维护个位数的毫秒暂停时间。</p><h1 id="六、-局限性"><a href="#六、-局限性" class="headerlink" title="六、 局限性"></a>六、 局限性</h1><p>ZGC的初始实验版本将不支持类卸载。默认情况下，classunload和ClassUnloadingWithConcurrentMark选项将被禁用。即便你启用也是不生效的。</p><p>此外，ZGC最初不支持JVMCI(即Graal)。如果启用EnableJVMCI选项，将打印一条错误消息。</p><p>这些限制将在本项目的后期解决。</p><h1 id="七、-构建和使用"><a href="#七、-构建和使用" class="headerlink" title="七、 构建和使用"></a>七、 构建和使用</h1><p>按照惯例，构建系统默认禁用JVM中的实验性特性。ZGC是一个实验性特性，因此不会出现在JDK构建中，除非在编译时使用configure选项:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--with-jvm-features=zgc</span><br></pre></td></tr></table></figure><p>显式地启用它。</p><p>(ZGC将出现在Oracle发布的所有Linux/x64 JDK版本中)</p><p>JVM中的实验特性还需要在运行时显式地解锁。因此，要启用/使用ZGC，需要以下JVM选项:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+ unlockexperimental alvmoptions -XX:+UseZGC</span><br></pre></td></tr></table></figure><p>有关如何设置和调优ZGC的更多信息，请参阅ZGC项目Wiki（wiki地址：<a href="https://wiki.openjdk.java.net/display/zgc/Main）。" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/zgc/Main）。</a></p><p>ZGC paper可以参考Azul Pauseless GC Algorithm：</p><p><a href="https://github.com/jiankunking/books-recommendation/blob/master/GC/ZGC/Azul_Pauseless_GC_Algorithm.pdf" target="_blank" rel="noopener">https://github.com/jiankunking/books-recommendation/blob/master/GC/ZGC/Azul_Pauseless_GC_Algorithm.pdf</a></p><p>ZGC 简介PPT:</p><p><a href="https://github.com/jiankunking/books-recommendation/blob/master/GC/ZGC/ZGC-FOSDEM-2018.pdf" target="_blank" rel="noopener">https://github.com/jiankunking/books-recommendation/blob/master/GC/ZGC/ZGC-FOSDEM-2018.pdf</a></p>]]></content>
      
      
      <categories>
          
          <category> GC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> GC </tag>
            
            <tag> ZGC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Lambda表达式 实现原理分析</title>
      <link href="/java-lambda.html"/>
      <url>/java-lambda.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文分析基于JDK 9</p></blockquote><a id="more"></a><h1 id="一、目标"><a href="#一、目标" class="headerlink" title="一、目标"></a>一、目标</h1><p>本文主要解决两个问题： </p><p>1、函数式接口 到底是什么？ </p><p>2、Lambda表达式是怎么实现的？</p><p>先介绍一个jdk的bin目录下的一个字节码查看工具及反编译工具：javap</p><p><img alt data-src="/images/java-lambda/javap.png"></p><h1 id="二、函数式接口"><a href="#二、函数式接口" class="headerlink" title="二、函数式接口"></a>二、函数式接口</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">interface IFunctionTest&lt;T&gt; &#123;</span><br><span class="line">    public void print(T x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过javap 反编译IFunctionTest.class 可以看到如下信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$C:\Users\Code\Java\study&gt;javap -p IFunctionTest.class</span><br><span class="line">Compiled from &quot;FunctionTest.java&quot;</span><br><span class="line">interface IFunctionTest&lt;T&gt; &#123;</span><br><span class="line">  public abstract void print(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到函数式接口编译完之后依然是一个接口，这个接口具有唯一的一个抽像方法。</p><p>为什么说需要是唯一一个抽象方法？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">interface IFunctionTest&lt;T&gt; &#123;</span><br><span class="line">    public void print(T x);</span><br><span class="line">    public void print22(T x,int rr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img alt data-src="/images/java-lambda/javac-FunctionTest.png"></p><p>虽然不能在函数式接口中定义多个方法，但可以定义默认方法、静态方法、定义java.lang.Object里的public方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">interface Print&lt;T&gt; &#123;</span><br><span class="line">    public void print(T x);</span><br><span class="line">    default void doSomeMoreWork1()&#123;</span><br><span class="line">        // Method body</span><br><span class="line">    &#125;</span><br><span class="line">    static void printHello()&#123;</span><br><span class="line">        System.out.println(&quot;Hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    boolean equals(Object obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$C:\Users\Code\Java\study&gt;javap -p IFunctionTest.class</span><br><span class="line">Compiled from &quot;FunctionTest.java&quot;</span><br><span class="line">interface IFunctionTest&lt;T&gt; &#123;</span><br><span class="line">  public abstract void print(T);</span><br><span class="line">  public void doSomeMoreWork1();</span><br><span class="line">  public static void printHello();</span><br><span class="line">  public abstract boolean equals(java.lang.Object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、Lambda"><a href="#三、Lambda" class="headerlink" title="三、Lambda"></a>三、Lambda</h1><h2 id="3-1-示例代码"><a href="#3-1-示例代码" class="headerlink" title="3.1 示例代码"></a>3.1 示例代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class LambdaTest &#123;</span><br><span class="line">    public static void printString(String s, Print&lt;String&gt; print) &#123;</span><br><span class="line">        print.print(s);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        printString(&quot;test&quot;, (x) -&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@FunctionalInterface</span><br><span class="line">interface Print&lt;T&gt; &#123;</span><br><span class="line">    public void print(T x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过javac编译LambdaTest.java文件，会生成LambdaTest.class、Print.class两个class文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac LambdaTest.java</span><br></pre></td></tr></table></figure><p><img alt data-src="/images/java-lambda/javac-LambdaTest.png"></p><h2 id="3-2-对于lambda实现的猜测"><a href="#3-2-对于lambda实现的猜测" class="headerlink" title="3.2 对于lambda实现的猜测"></a>3.2 对于lambda实现的猜测</h2><p>那么编译器对Lambda 都做了什么？反编译一下代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Code\Java\study&gt;javap -p LambdaTest.class</span><br><span class="line">Compiled from &quot;LambdaTest.java&quot;</span><br><span class="line">public class LambdaTest &#123;</span><br><span class="line">  public LambdaTest();</span><br><span class="line">  public static void printString(java.lang.String, Print&lt;java.lang.String&gt;);</span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">  private static void lambda$main$0(java.lang.String);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的代码可以看出编译器会根据Lambda表达式生成一个私有的静态函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static void lambda$main$0(java.lang.String);</span><br></pre></td></tr></table></figure><p>为了验证上面的转化是否正确? 我们在代码中定义一个lambda$main$0这个的函数，最终代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class LambdaTest &#123;</span><br><span class="line">    public static void printString(String s, Print&lt;String&gt; print) &#123;</span><br><span class="line">        print.print(s);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        printString(&quot;test&quot;, (x) -&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">    private static void lambda$main$0(String s) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@FunctionalInterface</span><br><span class="line">interface Print&lt;T&gt; &#123;</span><br><span class="line">    public void print(T x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码在编译时会报错，错误信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Code\Java\study&gt;javac LambdaTest.java</span><br><span class="line">LambdaTest.java:8: 错误: 符号lambda$main$0(String)与LambdaTest中的 compiler-synt</span><br><span class="line">hesized 符号冲突</span><br><span class="line">    private static void lambda$main$0(String s) &#123;</span><br><span class="line">                        ^</span><br><span class="line">LambdaTest.java:1: 错误: 符号lambda$main$0(String)与LambdaTest中的 compiler-synt</span><br><span class="line">hesized 符号冲突</span><br><span class="line">public class LambdaTest &#123;</span><br><span class="line">^</span><br><span class="line">2 个错误</span><br></pre></td></tr></table></figure><p>有了上面的内容，可以知道的是Lambda表达式在Java 9中首先会生成一个私有的静态函数，这个私有的静态函数干的就是Lambda表达式里面的内容，那么又是如何调用的生成的私有静态函数（lambda$main$0(String s)）呢？</p><h2 id="3-3-反编译代码详解"><a href="#3-3-反编译代码详解" class="headerlink" title="3.3 反编译代码详解"></a>3.3 反编译代码详解</h2><p>查看更加详细的反编译结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">$C:\Users\Code\Java\study&gt; javap -p -v -c LambdaTest.class</span><br><span class="line">Classfile /C:/Users/Code/Java/study/LambdaTest.class</span><br><span class="line">  Last modified 2018-4-5; size 1184 bytes</span><br><span class="line">  MD5 checksum b144b5a936a04a7c975eae93c7370174</span><br><span class="line">  Compiled from &quot;LambdaTest.java&quot;</span><br><span class="line">public class LambdaTest</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #9.#24         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = InterfaceMethodref #25.#26        // Print.print:(Ljava/lang/Object;)V</span><br><span class="line">   #3 = String             #27            // test</span><br><span class="line">   #4 = InvokeDynamic      #0:#33         // #0:print:()LPrint;</span><br><span class="line">   #5 = Methodref          #8.#34         // LambdaTest.printString:(Ljava/lang/String;LPrint;)V</span><br><span class="line">   #6 = Fieldref           #35.#36        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #7 = Methodref          #37.#38        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #8 = Class              #39            // LambdaTest</span><br><span class="line">   #9 = Class              #40            // java/lang/Object</span><br><span class="line">  #10 = Utf8               &lt;init&gt;</span><br><span class="line">  #11 = Utf8               ()V</span><br><span class="line">  #12 = Utf8               Code</span><br><span class="line">  #13 = Utf8               LineNumberTable</span><br><span class="line">  #14 = Utf8               printString</span><br><span class="line">  #15 = Utf8               (Ljava/lang/String;LPrint;)V</span><br><span class="line">  #16 = Utf8               Signature</span><br><span class="line">  #17 = Utf8               (Ljava/lang/String;LPrint&lt;Ljava/lang/String;&gt;;)V</span><br><span class="line">  #18 = Utf8               main</span><br><span class="line">  #19 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #20 = Utf8               lambda$main$0</span><br><span class="line">  #21 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #22 = Utf8               SourceFile</span><br><span class="line">  #23 = Utf8               LambdaTest.java</span><br><span class="line">  #24 = NameAndType        #10:#11        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #25 = Class              #41            // Print</span><br><span class="line">  #26 = NameAndType        #42:#43        // print:(Ljava/lang/Object;)V</span><br><span class="line">  #27 = Utf8               test</span><br><span class="line">  #28 = Utf8               BootstrapMethods</span><br><span class="line">  #29 = MethodHandle       #6:#44         // invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #30 = MethodType         #43            //  (Ljava/lang/Object;)V</span><br><span class="line">  #31 = MethodHandle       #6:#45         // invokestatic LambdaTest.lambda$main$0:(Ljava/lang/String;)V</span><br><span class="line">  #32 = MethodType         #21            //  (Ljava/lang/String;)V</span><br><span class="line">  #33 = NameAndType        #42:#46        // print:()LPrint;</span><br><span class="line">  #34 = NameAndType        #14:#15        // printString:(Ljava/lang/String;LPrint;)V</span><br><span class="line">  #35 = Class              #47            // java/lang/System</span><br><span class="line">  #36 = NameAndType        #48:#49        // out:Ljava/io/PrintStream;</span><br><span class="line">  #37 = Class              #50            // java/io/PrintStream</span><br><span class="line">  #38 = NameAndType        #51:#21        // println:(Ljava/lang/String;)V</span><br><span class="line">  #39 = Utf8               LambdaTest</span><br><span class="line">  #40 = Utf8               java/lang/Object</span><br><span class="line">  #41 = Utf8               Print</span><br><span class="line">  #42 = Utf8               print</span><br><span class="line">  #43 = Utf8               (Ljava/lang/Object;)V</span><br><span class="line">  #44 = Methodref          #52.#53        // java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #45 = Methodref          #8.#54         // LambdaTest.lambda$main$0:(Ljava/lang/String;)V</span><br><span class="line">  #46 = Utf8               ()LPrint;</span><br><span class="line">  #47 = Utf8               java/lang/System</span><br><span class="line">  #48 = Utf8               out</span><br><span class="line">  #49 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #50 = Utf8               java/io/PrintStream</span><br><span class="line">  #51 = Utf8               println</span><br><span class="line">  #52 = Class              #55            // java/lang/invoke/LambdaMetafactory</span><br><span class="line">  #53 = NameAndType        #56:#60        // metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #54 = NameAndType        #20:#21        // lambda$main$0:(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">  #55 = Utf8               java/lang/invoke/LambdaMetafactory</span><br><span class="line">  #56 = Utf8               metafactory</span><br><span class="line">  #57 = Class              #62            // java/lang/invoke/MethodHandles$Lookup</span><br><span class="line">  #58 = Utf8               Lookup</span><br><span class="line">  #59 = Utf8               InnerClasses</span><br><span class="line">  #60 = Utf8               (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  #61 = Class              #63            // java/lang/invoke/MethodHandles</span><br><span class="line">  #62 = Utf8               java/lang/invoke/MethodHandles$Lookup</span><br><span class="line">  #63 = Utf8               java/lang/invoke/MethodHandles</span><br><span class="line">&#123;</span><br><span class="line">  public LambdaTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 1: 0</span><br><span class="line"></span><br><span class="line">  public static void printString(java.lang.String, Print&lt;java.lang.String&gt;);</span><br><span class="line">    descriptor: (Ljava/lang/String;LPrint;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=2</span><br><span class="line">         0: aload_1</span><br><span class="line">         1: aload_0</span><br><span class="line">         2: invokeinterface #2,  2            // InterfaceMethod Print.print:(Ljava/lang/Object;)V</span><br><span class="line">         7: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">        line 4: 7</span><br><span class="line">    Signature: #17                          // (Ljava/lang/String;LPrint&lt;Ljava/lang/String;&gt;;)V</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: ldc           #3                  // String test</span><br><span class="line">         2: invokedynamic #4,  0              // InvokeDynamic #0:print:()LPrint;</span><br><span class="line">         7: invokestatic  #5                  // Method printString:(Ljava/lang/String;LPrint;)V</span><br><span class="line">        10: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 6: 0</span><br><span class="line">        line 7: 10</span><br><span class="line"></span><br><span class="line">  private static void lambda$main$0(java.lang.String);</span><br><span class="line">    descriptor: (Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: aload_0</span><br><span class="line">         4: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         7: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 6: 0</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;LambdaTest.java&quot;</span><br><span class="line">InnerClasses:</span><br><span class="line">     public static final #58= #57 of #61; //Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles</span><br><span class="line">BootstrapMethods:</span><br><span class="line">  0: #29 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;Method arguments:</span><br><span class="line">      #30 (Ljava/lang/Object;)V</span><br><span class="line">      #31 invokestatic LambdaTest.lambda$main$0:(Ljava/lang/String;)V</span><br><span class="line">      #32 (Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><p>这个 class 文件展示了三个主要部分：常量池、构造器方法和 printString、main、lambdamainmain0方法还有lambda表达式生成的内部类。</p><h3 id="3-3-1-动态链接"><a href="#3-3-1-动态链接" class="headerlink" title="3.3.1 动态链接"></a>3.3.1 动态链接</h3><p>每个栈帧都有一个运行时常量池的引用。这个引用指向栈帧当前运行方法所在类的常量池。通过这个引用支持动态链接（dynamic linking）。</p><p>C/C++ 代码一般被编译成对象文件，然后多个对象文件被链接到一起产生可执行文件或者 dll。在链接阶段，每个对象文件的符号引用被替换成了最终执行文件的相对偏移内存地址。在 Java中，链接阶段是运行时动态完成的。</p><p><font color="DeepPink">当 Java 类文件编译时，所有变量和方法的引用都被当做符号引用存储在这个类的常量池中。符号引用是一个逻辑引用，实际上并不指向物理内存地址。JVM 可以选择符号引用解析的时机，一种是当类文件加载并校验通过后，这种解析方式被称为饥饿方式。另外一种是符号引用在第一次使用的时候被解析，这种解析方式称为惰性方式。无论如何 ，JVM 必须要在第一次使用符号引用时完成解析并抛出可能发生的解析错误。绑定是将对象域、方法、类的符号引用替换为直接引用的过程。绑定只会发生一次。一旦绑定，符号引用会被完全替换。如果一个类的符号引用还没有被解析，那么就会载入这个类。每个直接引用都被存储为相对于存储结构（与运行时变量或方法的位置相关联的）偏移量。</font></p><h3 id="3-3-2-常量池"><a href="#3-3-2-常量池" class="headerlink" title="3.3.2 常量池"></a>3.3.2 常量池</h3><p>JVM 维护了一个按类型区分的常量池，一个类似于符号表的运行时数据结构。尽管它包含更多数据。Java 字节码需要数据。这个数据经常因为太大不能直接存储在字节码中，取而代之的是存储在常量池中，字节码包含这个常量池的引用。</p><p>常量池中可以存储多种类型的数据：</p><ul><li>数字型</li><li>字符串型</li><li>类引用型</li><li>域引用型</li><li>方法引用</li></ul><h3 id="3-3-3-方法"><a href="#3-3-3-方法" class="headerlink" title="3.3.3 方法"></a>3.3.3 方法</h3><p>每一个方法包含四个区域：</p><ul><li>签名和访问标签</li><li>字节码</li><li>LineNumberTable：为调试器提供源码中的每一行对应的字节码信息</li><li>LocalVariableTable：列出了所有栈帧中的局部变量</li></ul><table><thead><tr><th>操作码</th><th>作用</th></tr></thead><tbody><tr><td>aload0</td><td>这个操作码是aload格式操作码中的一个。它们用来把对象引用加载到操作码栈。表示正在被访问的局部变量数组的位置，但只能是0、1、2、3 中的一个。还有一些其它类似的操作码用来载入非对象引用的数据，如iload, lload, float 和 dload。其中 i 表示 int，l 表示 long，f 表示 float，d 表示 double。局部变量数组位置大于 3 的局部变量可以用 iload, lload, float, dload 和 aload 载入。这些操作码都只需要一个操作数，即数组中的位置。</td></tr><tr><td>ldc</td><td>这个操作码用来将常量从运行时常量池压栈到操作数栈。</td></tr><tr><td>getstatic</td><td>这个操作码用来把一个静态变量从运行时常量池的静态变量列表中压栈到操作数栈。</td></tr><tr><td>return</td><td>这个操作码属于ireturn、lreturn、freturn、dreturn、areturn 和 return 操作码组。每个操作码返回一种类型的返回值，其中 i 表示 int，l 表示 long，f 表示 float，d 表示 double，a 表示 对象引用。没有前缀类型字母的 return 表示返回 void。</td></tr></tbody></table><table><thead><tr><th>函数调用操作码</th><th>作用</th></tr></thead><tbody><tr><td>invokestatic</td><td>调用类方法（静态绑定，速度快）</td></tr><tr><td>invokevirtual</td><td>指令调用一个对象的实例方法（动态绑定）</td></tr><tr><td>invokespecial</td><td>指令调用实例初始化方法、私有方法、父类方法。（静态绑定，速度快）</td></tr><tr><td>invokeinterface</td><td>调用引用类型为interface的实例方法（动态绑定）</td></tr><tr><td>invokedynamic</td><td>JDK 7引入的，主要是为了支持动态语言的方法调用</td></tr></tbody></table><h3 id="3-3-4-代码分析"><a href="#3-3-4-代码分析" class="headerlink" title="3.3.4 代码分析"></a>3.3.4 代码分析</h3><p>注意反编译后main方法部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         // ldc 这个操作码用来将常量从运行时常量池压栈到操作数栈</span><br><span class="line">         0: ldc           #3                  // String test</span><br><span class="line">         // 注意下面两句：通过实例调用 print</span><br><span class="line">         2: invokedynamic #4,  0              // InvokeDynamic #0:print:()LPrint;        </span><br><span class="line">         //调用静态方法 printString</span><br><span class="line">         7: invokestatic  #5                  // Method printString:(Ljava/lang/String;LPrint;)V</span><br><span class="line">        10: return</span><br></pre></td></tr></table></figure><p>那么，既然是调用实例方法，那么实例在哪？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">InnerClasses:</span><br><span class="line">     public static final #58= #57 of #61; //Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles</span><br><span class="line">BootstrapMethods:</span><br><span class="line">  0: #29 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">  Method arguments:</span><br><span class="line">      //对象类型终结符为 L 和 ;</span><br><span class="line">      //Object V</span><br><span class="line">      #30 (Ljava/lang/Object;)V</span><br><span class="line">      #31 invokestatic LambdaTest.lambda$main$0:(Ljava/lang/String;)V</span><br><span class="line">      #32 (Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><p>可以在运行时加上-Djdk.internal.lambda.dumpProxyClasses，加上这个参数后，运行时，会将生成的内部类class码输出到一个文件中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djdk.internal.lambda.dumpProxyClasses LambdaTest</span><br></pre></td></tr></table></figure><p><img alt data-src="/images/java-lambda/dumpProxyClasses.png"><br>通过jad反编译LambdaTest$$Lambda$1.class文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.</span><br><span class="line">// Jad home page: http://www.kpdus.com/jad.html</span><br><span class="line">// Decompiler options: packimports(3) </span><br><span class="line">final class LambdaTest$$Lambda$1 implements Print &#123;</span><br><span class="line">    private LambdaTest$$Lambda$1() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print(Object obj) &#123;</span><br><span class="line">        LambdaTest.lambda$main$0((String) obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-5-代码还原"><a href="#3-3-5-代码还原" class="headerlink" title="3.3.5 代码还原"></a>3.3.5 代码还原</h3><p>至此，我们可以推断出最终执行代码应该是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class LambdaTest &#123;</span><br><span class="line">    public static void PrintString(String s, Print&lt;String&gt; print) &#123;</span><br><span class="line">        print.print(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        PrintString(&quot;test&quot;, new LambdaTest$$Lambda$1());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void lambda$main$0(String x) &#123;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static final class LambdaTest$$Lambda$1 implements Print &#123;</span><br><span class="line">        public void print(Object obj) &#123;</span><br><span class="line">            LambdaTest.lambda$main$0((String) obj);</span><br><span class="line">        &#125;</span><br><span class="line">        private LambdaTest$$Lambda$1() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@FunctionalInterface</span><br><span class="line">interface Print&lt;T&gt; &#123;</span><br><span class="line">    public void print(T x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><ul><li>在类编译时，会生成一个私有静态方法+一个内部类；</li><li>在内部类中实现了函数式接口，在实现接口的方法中，会调用编译器生成的静态方法；</li><li>在使用lambda表达式的地方，通过传递内部类实例，来调用函数式接口方法。</li></ul><blockquote><p>就是传递个函数指针，在Java中搞得这么复杂。。。。。。</p></blockquote><p>参考资料： </p><p><a href="https://www.cnblogs.com/WJ5888/p/4667086.html" target="_blank" rel="noopener">https://www.cnblogs.com/WJ5888/p/4667086.html</a> </p><p><a href="https://www.jianshu.com/p/57bffc6e7acd" target="_blank" rel="noopener">https://www.jianshu.com/p/57bffc6e7acd</a> </p><p><a href="http://www.importnew.com/17770.html" target="_blank" rel="noopener">http://www.importnew.com/17770.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReentrantReadWriteLock原理解析</title>
      <link href="/java-reentrantreadwritelock.html"/>
      <url>/java-reentrantreadwritelock.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java JDK 11 ReentrantReadWriteLock 原理分析</p></blockquote><a id="more"></a><h1 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h1><p>希望在阅读本文之前，建议先看一下以下三篇文章：</p><p>1、<a href="https://juejin.im/post/5d37019a51882564c966add6" target="_blank" rel="noopener">面试必备：Java AQS 实现原理（图文）分析</a> </p><p>2、<a href="https://juejin.im/post/5d3848e951882556d1684532" target="_blank" rel="noopener">面试必备：Java AQS Condition的实现分析</a> </p><p>3、<a href="https://juejin.im/post/5d3952bff265da1b7c615dba" target="_blank" rel="noopener">面试必备：Java volatile的内存语义与AQS锁内存可见性</a> </p><p>读完了以上三篇文章，先看一下ReentrantReadWriteLock的代码路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package java.util.concurrent.locks;</span><br></pre></td></tr></table></figure><p>来先猜一下ReentrantReadWriteLock会如何实现？</p><p>都在java.util.concurrent包下，那么可以明确一点，那就是关于锁的实现，应该用的就是AQS，那么，读锁、写锁会不会对应的就是AQS中的共享模式与独占模式？</p><h1 id="2、读写锁使用场景"><a href="#2、读写锁使用场景" class="headerlink" title="2、读写锁使用场景"></a>2、读写锁使用场景</h1><p>读是多于写（比如cache）</p><blockquote><p>一般情况下，读写锁的性能都会比排它锁好，因为大多数场景读是多于写的。在读多于写的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。</p></blockquote><h1 id="3、读写锁接口：ReadWriteLock"><a href="#3、读写锁接口：ReadWriteLock" class="headerlink" title="3、读写锁接口：ReadWriteLock"></a>3、读写锁接口：ReadWriteLock</h1><p>代码地址：<a href="https://github.com/jiankunking/openjdk11/blob/master/src/java.base/share/classes/java/util/concurrent/locks/ReadWriteLock.java" target="_blank" rel="noopener">ReadWriteLock</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface ReadWriteLock &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Returns the lock used for reading.</span><br><span class="line">     *</span><br><span class="line">     * @return the lock used for reading</span><br><span class="line">     */</span><br><span class="line">    Lock readLock();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the lock used for writing.</span><br><span class="line">     *</span><br><span class="line">     * @return the lock used for writing</span><br><span class="line">     */</span><br><span class="line">    Lock writeLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、读写锁的接口与示例</p><p>ReadWriteLock仅定义了获取读锁和写锁的两个方法，即readLock()方法和writeLock()方法，而其实现：ReentrantReadWriteLock，除了接口方法之外，还提供了一些便于外界监控其内部工作状态的方法，这些方法以及描述如表所示：</p><p><img alt data-src="/images/java-reentrantreadwritelock/ReadWriteLock%E6%8E%A5%E5%8F%A3.png"><br>接下来，通过一个缓存示例说明读写锁的使用方式，示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Cache &#123;</span><br><span class="line">    static Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">    static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</span><br><span class="line">    static Lock r = rwl.readLock();</span><br><span class="line">    static Lock w = rwl.writeLock();</span><br><span class="line"></span><br><span class="line">    // 获取一个key对应的value</span><br><span class="line">    public static final Object get(String key) &#123;</span><br><span class="line">        r.lock();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            return map.get(key);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置key对应的value，并返回旧的value</span><br><span class="line">    public static final Object put(String key, Object value) &#123;</span><br><span class="line">        w.lock();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            return map.put(key, value);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 清空所有的内容</span><br><span class="line">    public static final void clear() &#123;</span><br><span class="line">        w.lock();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            map.clear();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述示例中，Cache组合一个非线程安全的HashMap作为缓存的实现，同时使用读写锁的读锁和写锁来保证Cache是线程安全的。在读操作get(String key)方法中，需要获取读锁，这使得并发访问该方法时不会被阻塞。写操作put(String key,Object value)方法和clear()方法，在更新HashMap时必须提前获取写锁，当获取写锁后，其他线程对于读锁和写锁的获取均被阻塞，而只有写锁被释放之后，其他读写操作才能继续。Cache使用读写锁提升读操作的并发性，也保证每次写操作对所有的读写操作的可见性，同时简化了编程方式。</p><h1 id="5、ReentrantReadWriteLock脉络梳理"><a href="#5、ReentrantReadWriteLock脉络梳理" class="headerlink" title="5、ReentrantReadWriteLock脉络梳理"></a>5、ReentrantReadWriteLock脉络梳理</h1><p>代码地址：<a href="https://github.com/jiankunking/openjdk11/blob/master/src/java.base/share/classes/java/util/concurrent/locks/ReentrantReadWriteLock.java" target="_blank" rel="noopener">ReentrantReadWriteLock</a></p><p>先看一下继承结构：</p><p><img alt data-src="/images/java-reentrantreadwritelock/%E8%AF%BB%E5%86%99%E9%94%81%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png"><br>再看一下代码结构：</p><p><img alt data-src="/images/java-reentrantreadwritelock/%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84.png"><br>图中可以看出ReentrantReadWriteLock的实现还是比较复杂的，所以接下来主要分析ReentrantReadWriteLock实现关键点，包括：</p><ul><li>读写状态的设计</li><li>写锁的获取与释放</li><li>读锁的获取与释放</li><li>锁降级</li></ul><h2 id="5-1-读写状态的设计"><a href="#5-1-读写状态的设计" class="headerlink" title="5.1 读写状态的设计"></a>5.1 读写状态的设计</h2><p>读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。回想ReentrantLock中自定义同步器的实现，同步状态表示锁被一个线程重复获取的次数，而读写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状态，使得该状态的设计成为读写锁实现的关键。</p><p>如果在一个整型变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将变量切分成了两个部分，高16位表示读，低16位表示写，划分方式如下图所示:</p><p><img alt data-src="/images/java-reentrantreadwritelock/32%E4%BD%8D%E8%AF%BB%E5%86%99%E6%A0%87%E8%AF%86.png"></p><p>当前同步状态表示一个线程已经获取了写锁，且重进入了两次，同时也连续获取了两次读锁。读写锁是如何迅速确定读和写各自的状态呢？</p><p>答案是通过位运算。假设当前同步状态值为S，写状态等于S&amp;0x0000FFFF（将高16位全部抹去），读状态等于S&gt;&gt;&gt;16（无符号补0右移16位）。当写状态增加1时，等于S+1，当读状态增加1时，等于S+(1&lt;&lt;16)，也就是S+0x00010000。</p><blockquote><p>1、0x0000FFFF=00000000000000001111111111111111（16个0 16个1）</p></blockquote><blockquote><p>2、&gt;&gt;&gt;： 无符号右移，忽略符号位，空位都以0补齐</p></blockquote><blockquote><p>3、0x00010000=10000000000000000（1个1 16个0）</p></blockquote><p>根据状态的划分能得出一个推论：S不等于0时，当写状态（S&amp;0x0000FFFF）等于0时，则读状态（S&gt;&gt;&gt;16）大于0，即读锁已被获取。</p><h2 id="5-2-写锁的获取与释放"><a href="#5-2-写锁的获取与释放" class="headerlink" title="5.2 写锁的获取与释放"></a>5.2 写锁的获取与释放</h2><p>写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取（读状态不为0）或者该线程不是已经获取写锁的线程，则当前线程进入等待状态，获取写锁的代码如代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * Walkthrough:</span><br><span class="line">             * 1. If read count nonzero or write count nonzero</span><br><span class="line">             *    and owner is a different thread, fail.</span><br><span class="line">             * 2. If count would saturate, fail. (This can only</span><br><span class="line">             *    happen if count is already nonzero.)</span><br><span class="line">             * 3. Otherwise, this thread is eligible for lock if</span><br><span class="line">             *    it is either a reentrant acquire or</span><br><span class="line">             *    queue policy allows it. If so, update state</span><br><span class="line">             *    and set owner.</span><br><span class="line">             */</span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            int c = getState();</span><br><span class="line">            int w = exclusiveCount(c);</span><br><span class="line">            if (c != 0) &#123;</span><br><span class="line">               // 存在读锁或者当前获取线程不是已经获取写锁的线程</span><br><span class="line">                if (w == 0 || current != getExclusiveOwnerThread())</span><br><span class="line">                    return false;</span><br><span class="line">                if (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                // Reentrant acquire</span><br><span class="line">                setState(c + acquires);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (writerShouldBlock() ||</span><br><span class="line">                !compareAndSetState(c, c + acquires))</span><br><span class="line">                return false;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>该方法除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。<font color="DeepPink">如果存在读锁，则写锁不能被获取，原因在于：读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。</font></p><p><font color="DeepPink">写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁，同时前次写线程的修改对后续读写线程可见。</font></p><h2 id="5-3-读锁的获取与释放"><a href="#5-3-读锁的获取与释放" class="headerlink" title="5.3 读锁的获取与释放"></a>5.3 读锁的获取与释放</h2><p>读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在没有其他写线程访问（或者写状态为0）时，读锁总会被成功地获取，而所做的也只是（线程安全的）增加读状态。如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。获取读锁的实现从Java 5到Java 6变得复杂许多，主要原因是新增了一些功能，例如getReadHoldCount()方法，作用是返回当前线程获取读锁的次数。读状态是所有线程获取读锁次数的总和，而每个线程各自获取读锁的次数只能选择保存在ThreadLocal中，由线程自身维护，这使获取读锁的实现变得复杂。因此，这里将获取读锁的代码做了删减，保留必要的部分，如代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected final int tryAcquireShared(int unused) &#123;</span><br><span class="line">          for (;;) &#123;</span><br><span class="line">                  int c = getState();</span><br><span class="line">                  int nextc = c + (1 &lt;&lt; 16);</span><br><span class="line">                  if (nextc &lt; c)</span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                  if (exclusiveCount(c) != 0 &amp;&amp; owner != Thread.currentThread())</span><br><span class="line">                    return -1;</span><br><span class="line">                  if (compareAndSetState(c, nextc))</span><br><span class="line">                    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。<font color="DeepPink"> 如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。</font></p><p>读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是（1&lt;&lt;16）。</p><h2 id="5-4-锁降级"><a href="#5-4-锁降级" class="headerlink" title="5.4 锁降级"></a>5.4 锁降级</h2><p>锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。</p><p>接下来看一个锁降级的示例。因为数据不常变化，所以多个线程可以并发地进行数据处理，当数据变更后，如果当前线程感知到数据变化，则进行数据的准备工作，同时其他处理线程被阻塞，直到当前线程完成数据的准备工作，如代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void processData() &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        if (!update) &#123;</span><br><span class="line">            // 必须先释放读锁</span><br><span class="line">            readLock.unlock();</span><br><span class="line">            // 锁降级从写锁获取到开始</span><br><span class="line">            writeLock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                if (!update) &#123;</span><br><span class="line">                    // 准备数据的流程（略）</span><br><span class="line">                    update = true;</span><br><span class="line">                &#125;</span><br><span class="line">                readLock.lock();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                writeLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            // 锁降级完成，写锁降级为读锁</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 使用数据的流程（略）</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述示例中，当数据发生变更后，update变量（布尔类型且volatile修饰）被设置为false，此时所有访问processData()方法的线程都能够感知到变化，但只有一个线程能够获取到写锁，其他线程会被阻塞在读锁和写锁的lock()方法上。当前线程获取写锁完成数据准备之后，再获取读锁，随后释放写锁，完成锁降级。</p><p><font color="DeepPink">锁降级中读锁的获取是否必要呢？答案是必要的。主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程（记作线程T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。如果当前线程获取读锁，即遵循锁降级的步骤，则线程T将会被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进行数据更新。</font></p><p><font color="DeepPink">RentrantReadWriteLock不支持锁升级（把持读锁、获取写锁，最后释放读锁的过程）。目的也是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。</font></p><h1 id="6、小结"><a href="#6、小结" class="headerlink" title="6、小结"></a>6、小结</h1><p>RentrantReadWriteLock的具体流程梳理完了，回过头来想一下前言的问题，好像并没有得到答案，那么来到ReentrantReadWriteLock代码中，此处主要看一下读锁的获取、释放是否对应AQS中的共享模式。</p><h2 id="6-1-读锁的获取、释放"><a href="#6-1-读锁的获取、释放" class="headerlink" title="6.1 读锁的获取、释放"></a>6.1 读锁的获取、释放</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void lock() &#123;</span><br><span class="line">         //看到这里是不是就明白了，我们的猜想是正确的</span><br><span class="line">         sync.acquireShared(1);</span><br><span class="line">     &#125;</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">         //看到这里是不是就明白了，我们的猜想是正确的</span><br><span class="line">         sync.releaseShared(1);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>先来看一下ReadLock的具体实现，在ReentrantReadWriteLock初始化的时候，会在构造函数中初始化ReadLock、WriteLock，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantReadWriteLock() &#123;</span><br><span class="line">       this(false);</span><br><span class="line">   &#125;</span><br><span class="line">   public ReentrantReadWriteLock(boolean fair) &#123;</span><br><span class="line">       sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">       readerLock = new ReadLock(this);</span><br><span class="line">       writerLock = new WriteLock(this);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>从ReentrantReadWriteLock构造函数的代码中，可以看到ReadLock初始化的参数是ReentrantReadWriteLock，那么ReadLock需要ReentrantReadWriteLock来做什么呢？</p><p>来看一下ReadLock：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private final Sync sync;</span><br><span class="line">    protected ReadLock(ReentrantReadWriteLock lock) &#123;</span><br><span class="line">        sync = lock.sync;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从ReadLock的构造函数中，可以看出，ReadLock需要获取到Sync，那么Sync是谁，又是用来做什么的？</p><blockquote><p>其实，如果看过JUC下面代码的话，看到Sync，就明白它应该就是AQS的实现类，通过它来实现相关锁的操作。</p></blockquote><p>来看一下代码验证一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Synchronization implementation for ReentrantReadWriteLock.</span><br><span class="line">     * Subclassed into fair and nonfair versions.</span><br><span class="line">     */</span><br><span class="line">    abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">    //具体代码略</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看到这里可以大体得出这么一个结果：ReadLock获取锁的时候，是通过ReentrantReadWriteLock 内部Sync类来获取的共享锁，也就是读锁的获取是对应AQS中的共享模式。</p><p>点进 sync.acquireShared(1)方法，可以看到是调用Sync的父类AQS中方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">        if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看到这里，也就明白为啥AQS子类需要重写：</p><ul><li>tryAcquire</li><li>tryRelease</li><li>tryReleaseShared</li><li>isHeldExclusively</li></ul><p>等方法了。</p><h1 id="7、参考资料"><a href="#7、参考资料" class="headerlink" title="7、参考资料"></a>7、参考资料</h1><p>本文第4、5小节整理自：《Java并发编程的艺术》</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> AQS </tag>
            
            <tag> JDK </tag>
            
            <tag> Java </tag>
            
            <tag> ReentrantReadWriteLock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java volatile的内存语义与AQS锁内存可见性</title>
      <link href="/java-volatile-aqs.html"/>
      <url>/java-volatile-aqs.html</url>
      
        <content type="html"><![CDATA[<p>提到volatile首先想到就是：</p><ul><li>保证此变量对所有线程的可见性，这里的 “可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。</li><li>禁止指令重排序优化。</li></ul><p>到这里大家感觉自己对volatile理解了吗？ </p><p>如果理解了，大家考虑这么一个问题：ReentrantLock（或者其它基于AQS实现的锁）是如何保证代码段中变量（变量主要是指共享变量，存在竞争问题的变量）的可见性？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static ReentrantLock reentrantLock = new ReentrantLock();</span><br><span class="line">private static intcount = 0;</span><br><span class="line">//...</span><br><span class="line">// 多线程 run 如下代码</span><br><span class="line">reentrantLock.lock();</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125; </span><br><span class="line">finally</span><br><span class="line">&#123;</span><br><span class="line">    reentrantLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">//...</span><br></pre></td></tr></table></figure><p>既然提到了可见性，那就先熟悉几个概念：</p><h1 id="1、JMM"><a href="#1、JMM" class="headerlink" title="1、JMM"></a>1、JMM</h1><p>JMM：Java Memory Model 即 Java 内存模型</p><blockquote><p>The Java Memory Model describes what behaviors are legal in multithreaded code, and how threads may interact through memory.</p></blockquote><blockquote><p>It describes the relationship between variables in a program and the low-level details of storing and retrieving them to and from memory or registers in a real computer system.</p></blockquote><blockquote><p>It does this in a way that can be implemented correctly using a wide variety of hardware and a wide variety of compiler optimizations.</p></blockquote><p><font color="DeepPink">Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。</font>此处的变量主要是指共享变量，存在竞争问题的变量。Java内存模型规定所有的变量都存储在主内存中，而每条线程还有自己的工作内存，线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量（<font color="DeepPink">根据Java虚拟机规范的规定，volatile变量依然有共享内存的拷贝，但是由于它特殊的操作顺序性规定——从工作内存中读写数据前，必须先将主内存中的数据同步到工作内存中，所有看起来如同直接在主内存中读写访问一般，因此这里的描述对于volatile也不例外</font>）。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值得传递均需要通过主内存来完成。</p><h1 id="2、重排序"><a href="#2、重排序" class="headerlink" title="2、重排序"></a>2、重排序</h1><p>在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类型：</p><ul><li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ul><p>从Java源代码到最终实际执行的指令序列，会分别经历下面3种重排序：</p><p><img alt data-src="/images/java-aqs-voliate/%E9%87%8D%E6%8E%92%E5%BA%8F.png"></p><p>对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障（Memory Barriers，Intel称之为Memory Fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序。 </p><p>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p><h1 id="3、happens-before"><a href="#3、happens-before" class="headerlink" title="3、happens-before"></a>3、happens-before</h1><ul><li>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li><li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li><li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。（对一个volatile变量的读，总是能看到【任意线程】对这个volatile变量最后的写入）</li><li>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</li></ul><blockquote><p>两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。</p></blockquote><h1 id="4、内存屏障"><a href="#4、内存屏障" class="headerlink" title="4、内存屏障"></a>4、内存屏障</h1><ul><li>硬件层的内存屏障分为两种：Load Barrier 和 Store Barrier即读屏障和写屏障。</li><li><font color="DeepPink">对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据；</font></li><li><font color="DeepPink">对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。</font></li><li>内存屏障有两个作用：<ul><li>阻止屏障两侧的指令重排序；</li><li>强制把写缓冲区/高速缓存中的数据等写回主内存，让缓存中相应的数据失效。<h1 id="5、volatile的内存语义"><a href="#5、volatile的内存语义" class="headerlink" title="5、volatile的内存语义"></a>5、volatile的内存语义</h1></li></ul></li></ul><p>从JSR-133开始（即从JDK5开始），volatile变量的写-读可以实现线程之间的通信。</p><p><font color="DeepPink">从内存语义的角度来说，volatile的写-读与锁的释放-获取有相同的内存效果</font>：</p><ul><li>volatile写和锁的释放有相同的内存语义；</li><li>volatile读与锁的获取有相同的内存语义。<blockquote><p>volatile仅仅保证对单个volatile变量的读/写具有原子性，而锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。在功能上，锁比volatile更强大；在可伸缩性和执行性能上，volatile更有优势。</p></blockquote></li></ul><p>volatile变量自身具有下列特性：</p><ul><li>可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</li><li>原子性：对任意单个volatile变量的读/写具有原子性，即使是64位的long型和double型变量，只要它是volatile变量，对该变量的读/写就具有原子性。如果是多个volatile操作或类似于volatile++这种复合操作，这些操作整体上不具有原子性。</li></ul><p>volatile写和volatile读的内存语义：</p><ul><li><font color="DeepPink">线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程发出了（其对共享变量所做修改的）消息。</font></li><li><font color="DeepPink">线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile变量之前对共享变量所做修改的）消息。</font></li><li><font color="DeepPink">线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过主内存向线程B发送消息。</font></li></ul><p>JMM针对编译器制定的volatile重排序规则表</p><p><img alt data-src="/images/java-aqs-voliate/JMM%E9%92%88%E5%AF%B9%E7%BC%96%E8%AF%91%E5%99%A8%E5%88%B6%E5%AE%9A%E7%9A%84volatile%E9%87%8D%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99%E8%A1%A8.png"></p><ul><li><font color="DeepPink">当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</font></li><li><font color="DeepPink">当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</font></li><li><font color="DeepPink">当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</font></li></ul><p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。<strong>对于编译器来说，发现一个最优布置来最小化插入屏障几乎是不可能的。为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略。</strong></p><ul><li>在每个volatile写操作的前面插入一个StoreStore屏障。</li><li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li><li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li><li>在每个volatile读操作的后面插入一个LoadStore屏障。<blockquote><p>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</p></blockquote></li></ul><blockquote><p>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。  LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</p></blockquote><blockquote><p>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。<br>上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的volatile内存语义。</p></blockquote><p>下面是保守策略下，volatile写插入内存屏障后生成的指令序列示意图. </p><p><img alt data-src="/images/java-aqs-voliate/volatile%E5%86%99%E6%8F%92%E5%85%A5%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E5%90%8E%E7%94%9F%E6%88%90%E7%9A%84%E6%8C%87%E4%BB%A4%E5%BA%8F%E5%88%97%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><p>图中的StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作已经对任意处理器可见了。这是因为<strong>StoreStore屏障将保障上面所有的普通写在volatile写之前刷新到主内存。</strong></p><p>这里比较有意思的是，volatile写后面的StoreLoad屏障。此屏障的作用是避免volatile写与后面可能有的volatile读/写操作重排序。因为编译器常常无法准确判断在一个volatile写的后面是否需要插入一个StoreLoad屏障（比如，一个volatile写之后方法立即return）。为了保证能正确实现volatile的内存语义，JMM在采取了保守策略：在每个volatile写的后面，或者在每个volatile读的前面插入一个StoreLoad屏障。从整体执行效率的角度考虑，JMM最终选择了在每个volatile写的后面插入一个StoreLoad屏障。因为volatile写-读内存语义的常见使用模式是：一个写线程写volatile变量，多个读线程读同一个volatile变量。当读线程的数量大大超过写线程时，选择在volatile写之后插入StoreLoad屏障将带来可观的执行效率的提升。从这里可以看到JMM在实现上的一个特点：首先确保正确性，然后再去追求执行效率。</p><p>下面是在保守策略下，volatile读插入内存屏障后生成的指令序列示意图:<br><img alt data-src="/images/java-aqs-voliate/volatile%E8%AF%BB%E6%8F%92%E5%85%A5%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E5%90%8E%E7%94%9F%E6%88%90%E7%9A%84%E6%8C%87%E4%BB%A4%E5%BA%8F%E5%88%97%E7%A4%BA%E6%84%8F%E5%9B%BE.png"><br>图中的LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序。 </p><p>上述volatile写和volatile读的内存屏障插入策略非常保守。在实际执行时，只要不改变volatile写-读的内存语义，编译器可以根据具体情况省略不必要的屏障。</p><h1 id="6、AQS"><a href="#6、AQS" class="headerlink" title="6、AQS"></a>6、AQS</h1><p>对于AQS需要了解这么几点： </p><ul><li>锁的状态通过volatile int state来表示。 </li><li>获取不到锁的线程会进入AQS的队列等待。 </li><li>子类需要重写tryAcquire、tryRelease等方法。</li></ul><p>AQS 详解参见：<a href="https://juejin.im/post/5d37019a51882564c966add6" target="_blank" rel="noopener">面试必备：Java AQS 实现原理（图文）分析</a> </p><h1 id="7、ReentrantLock"><a href="#7、ReentrantLock" class="headerlink" title="7、ReentrantLock"></a>7、ReentrantLock</h1><p>以公平锁为例，看看 ReentrantLock 获取锁 &amp; 释放锁的关键代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The synchronization state.</span><br><span class="line"> */</span><br><span class="line">private volatile int state;</span><br><span class="line">/**</span><br><span class="line"> * Returns the current value of synchronization state.</span><br><span class="line"> * This operation has memory semantics of a &#123;@code volatile&#125; read.</span><br><span class="line"> * @return current state value</span><br><span class="line"> */</span><br><span class="line">protected final int getState() &#123;</span><br><span class="line">    return state;</span><br><span class="line">&#125;</span><br><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    int c = getState() - releases;</span><br><span class="line">    if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    boolean free = false;</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        free = true;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);// 释放锁的最后，写volatile变量state</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br><span class="line"> protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">        final Thread current = Thread.currentThread();</span><br><span class="line">        int c = getState();// 获取锁的开始，首先读volatile变量state</span><br><span class="line">        if (c == 0) &#123;</span><br><span class="line">            if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            int nextc = c + acquires;</span><br><span class="line">            if (nextc &lt; 0)</span><br><span class="line">                throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="DeepPink">公平锁在释放锁的最后写volatile变量state，在获取锁时首先读这个volatile变量。根据volatile的happens-before规则，释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取同一个volatile变量后将立即变得对获取锁的线程可见。从而保证了代码段中变量（变量主要是指共享变量，存在竞争问题的变量）的可见性。</font></p><p>8、小结</p><p>如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式。 </p><ul><li>首先，<font color="DeepPink">声明共享变量为volatile。 </font></li><li>然后，<font color="DeepPink">使用CAS的原子条件更新来实现线程之间的同步。</font></li><li>同时，<font color="DeepPink">配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。</font><blockquote><p>前文我们提到过，编译器不会对volatile读与volatile读后面的任意内存操作重排序；编译器不会对volatile写与volatile写前面的任意内存操作重排序。组合这两个条件，意味着为了同时实现volatile读和volatile写的内存语义，编译器不能对CAS与CAS前面和后面的任意内存操作重排序。</p></blockquote></li></ul><p>本文参考： </p><p>1、《Java并发编程的艺术》 方腾飞　魏鹏　程晓明　著</p><p>2、<a href="https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247485795&idx=2&sn=73d5bcd83378f6176f9593d33dc402dc&chksm=eb538c55dc240543df3cd113cb3e586e98d3ccd0a93c6a87829a04e296b990a554596338046e#rd" target="_blank" rel="noopener">Java 可重入锁内存可见性分析</a> </p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> AQS </tag>
            
            <tag> JDK </tag>
            
            <tag> Java </tag>
            
            <tag> Volatile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java AQS Condition的实现分析</title>
      <link href="/java-aqs-condition.html"/>
      <url>/java-aqs-condition.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文整理自《Java并发编程的艺术》第五章 作者：方腾飞　魏鹏　程晓明</p></blockquote><a id="more"></a><p>AQS:AbstractQueuedSynchronizer</p><p>ConditionObject是同步器AQS的内部类，因为Condition的操作需要获取相关联的锁，所以作为同步器的内部类也较为合理。每个Condition对象都包含着一个队列（以下称为等待队列），该队列是Condition对象实现等待/通知功能的关键。</p><p>下面将分析Condition的实现，主要包括：等待队列、等待和通知，下面提到的Condition如果不加说明均指的是ConditionObject。</p><h1 id="1、等待队列"><a href="#1、等待队列" class="headerlink" title="1、等待队列"></a>1、等待队列</h1><p>等待队列是一个FIFO的队列，在队列中的每个节点都包含了一个线程引用，该线程就是在Condition对象上等待的线程，如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态。事实上，节点的定义复用了同步器中节点的定义，也就是说，同步队列和等待队列中节点类型都是同步器的静态内部类AbstractQueuedSynchronizer.Node。</p><p>一个Condition包含一个等待队列，Condition拥有首节点（firstWaiter）和尾节点（lastWaiter）。当前线程调用Condition.await()方法，将会以当前线程构造节点，并将节点从尾部加入等待队列，等待队列的基本结构如图5-9所示。<br><img alt data-src="/images/java-juc-aqs-condition/59.png"></p><p>如图所示，Condition拥有首尾节点的引用，而新增节点只需要将原有的尾节点nextWaiter指向它，并且更新尾节点即可。上述节点引用更新的过程并没有使用CAS保证，原因在于<font color="DeepPink">调用await()方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的。 </font></p><p>在Object的监视器模型上，一个对象拥有一个同步队列和等待队列，而<font color="DeepPink">并发包中的Lock（更确切地说是同步器）拥有一个同步队列和多个等待队列 </font>，其对应关系如图5-10所示。</p><p><img alt data-src="/images/java-juc-aqs-condition/510.png"></p><h1 id="2、等待"><a href="#2、等待" class="headerlink" title="2、等待"></a>2、等待</h1><p><font color="DeepPink">调用Condition的await()方法（或者以await开头的方法），会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。当从await()方法返回时，当前线程一定获取了Condition相关联的锁。</font></p><p>如果从队列（同步队列和等待队列）的角度看await()方法，当调用await()方法时，相当于同步队列的首节点（获取了锁的节点）移动到Condition的等待队列中。</p><p>Condition的await()方法，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">        if (Thread.interrupted())</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        // 当前线程加入等待队列</span><br><span class="line">        Node node = addConditionWaiter();</span><br><span class="line">        // 释放同步状态，也就是释放锁</span><br><span class="line">        int savedState = fullyRelease(node);</span><br><span class="line">        int interruptMode = 0;</span><br><span class="line">        while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            LockSupport.park(this);</span><br><span class="line">            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        if (node.nextWaiter != null)</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        if (interruptMode != 0)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>调用该方法的线程成功获取了锁的线程，也就是同步队列中的首节点，该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同步队列中的后继节点，然后当前线程会进入等待状态。</p><p>当等待队列中的节点被唤醒，则唤醒节点的线程开始尝试获取同步状态。如果不是通过其他线程调用Condition.signal()方法唤醒，而是对等待线程进行中断，则会抛出InterruptedException。</p><p>如果从队列的角度去看，当前线程加入Condition的等待队列，该过程如图5-11示。</p><p>如图所示，同步队列的首节点并不会直接加入等待队列，而是通过addConditionWaiter()方法把当前线程构造成一个新的节点并将其加入等待队列中。</p><h1 id="3、通知"><a href="#3、通知" class="headerlink" title="3、通知"></a>3、通知</h1><p>调用Condition的signal()方法，将会唤醒在等待队列中等待时间最长的节点（首节点），在唤醒节点之前，会将节点移到同步队列中。</p><p>Condition的signal()方法，如代码清单5-23所示。<br><img alt data-src="/images/java-juc-aqs-condition/511.png"><br>代码清单5-23　ConditionObject的signal方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final void signal() &#123;</span><br><span class="line">       //isHeldExclusively() AQS 子类实现</span><br><span class="line">       if (!isHeldExclusively())</span><br><span class="line">           throw new IllegalMonitorStateException();</span><br><span class="line">       Node first = firstWaiter;</span><br><span class="line">       if (first != null)</span><br><span class="line">           doSignal(first);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><font color="DeepPink">调用该方法的前置条件是当前线程必须获取了锁，可以看到signal()方法进行了isHeldExclusively()检查，也就是当前线程必须是获取了锁的线程。</font>接着获取等待队列的首节点，将其移动到同步队列并使用LockSupport唤醒节点中的线程。</p><p>节点从等待队列移动到同步队列的过程如图5-12所示。</p><p><img alt data-src="/images/java-juc-aqs-condition/512.png"><br>通过调用同步器的enq(Node node)方法，等待队列中的头节点线程安全地移动到同步队列。当节点移动到同步队列后，当前线程再使用LockSupport唤醒该节点的线程。</p><p>被唤醒后的线程，将从await()方法中的while循环中退出（isOnSyncQueue(Node node)方法返回true，节点已经在同步队列中），进而调用同步器的acquireQueued()方法加入到获取同步状态的竞争中。</p><p>成功获取同步状态（或者说锁）之后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功地获取了锁。</p><p>Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> AQS </tag>
            
            <tag> JDK </tag>
            
            <tag> Java </tag>
            
            <tag> Condition </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java AQS 实现原理（图文）分析</title>
      <link href="/java-aqs.html"/>
      <url>/java-aqs.html</url>
      
        <content type="html"><![CDATA[<p>AQS：AbstractQueuedSynchronizer</p><h1 id="1、AQS设计简介"><a href="#1、AQS设计简介" class="headerlink" title="1、AQS设计简介"></a>1、AQS设计简介</h1><ul><li>AQS的实现是基于一个FIFO的等待队列。</li><li><font color="DeepPink">使用单个原子变量来表示获取、释放锁状态（final int）改变该int值使用的是CAS。</font>（思考：为什么一个int值可以保证内存可见性？）</li><li><font color="DeepPink">子类应该定义一个非公开的内部类继承AQS，并实现其中方法。</font></li><li>AQS支持exclusive与shared两种模式。</li><li>内部类ConditionObject用于支持子类实现exclusive模式</li><li>子类需要重写：<ul><li>tryAcquire</li><li>tryRelease</li><li>tryReleaseShared</li><li>isHeldExclusively等方法，并确保是线程安全的。</li></ul></li></ul><p>贯穿全文的图（核心）：</p><p><img alt data-src="/images/java-juc-aqs/AQS%E5%9B%BE%E8%A7%A3.png"></p><blockquote><p>模板方法设计模式：定义一个操作中算法的骨架，而将一些步骤的实现延迟到子类中。</p></blockquote><h1 id="2、类结构"><a href="#2、类结构" class="headerlink" title="2、类结构"></a>2、类结构</h1><ul><li>ConditionObject类</li><li>Node类</li><li>N多方法</li></ul><p><img alt data-src="/images/java-juc-aqs/AQS%E7%B1%BB%E7%BB%93%E6%9E%84.png"></p><h1 id="3、FIFO队列"><a href="#3、FIFO队列" class="headerlink" title="3、FIFO队列"></a>3、FIFO队列</h1><p>等待队列是CLH（Craig, Landin, and Hagersten）锁队列。</p><p><strong>通过节点中的“状态”字段来判断一个线程是否应该阻塞。当该节点的前一个节点释放锁的时候，该节点会被唤醒。</strong> </p><p><img alt data-src="/images/java-juc-aqs/AQS%E9%98%9F%E5%88%97.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private transient volatile Node head;</span><br><span class="line">private transient volatile Node tail;</span><br><span class="line">//The synchronization state.</span><br><span class="line">//在互斥锁中它表示着线程是否已经获取了锁，0未获取，1已经获取了，大于1表示重入数。</span><br><span class="line">private volatile int state;</span><br></pre></td></tr></table></figure><p>AQS维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。</p><p>state的访问方式有三种:</p><ul><li>getState()</li><li>setState()</li><li>compareAndSetState()</li></ul><p>AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。</p><p>不同的自定义同步器争用共享资源的方式也不同。<font color="DeepPink">自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可</font>，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。</p><p>自定义同步器实现时主要实现以下几种方法：</p><ul><li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul><p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，<font color="DeepPink">获取多少次就要释放多么次，这样才能保证state是能回到零态的。</font></p><p>再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后续动作。</p><p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现：<br>tryAcquire-tryRelease<br>tryAcquireShared-tryReleaseShared<br>中的一种即可。</p><p>当然AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p><p>以下部分来自源码注释：</p><p>每次进入CLH队列时，需要对尾节点进入队列过程，是一个原子性操作。在出队列时，我们只需要更新head节点即可。在节点确定它的后继节点时， 需要花一些功夫，用于处理那些，由于等待超时时间结束或中断等原因， 而取消等待锁的线程。</p><p>节点的前驱指针，主要用于处理，取消等待锁的线程。如果一个节点取消等待锁，则此节点的前驱节点的后继指针，要指向，此节点后继节点中，非取消等待锁的线程（有效等待锁的线程节点）。</p><p>我们用next指针连接实现阻塞机制。每个节点均持有自己线程，节点通过节点的后继连接唤醒其后继节点。</p><p>CLH队列需要一个傀儡结点作为开始节点。我们不会再构造函数中创建它，因为如果没有线程竞争锁，那么，努力就白费了。取而代之的方案是，当有第一个竞争者时，我们才构造头指针和尾指针。</p><p>线程通过同一节点等待条件，但是用另外一个连接。条件只需要放在一个非并发的连接队列与节点关联，因为只有当线程独占持有锁的时候，才会去访问条件。当一个线程等待条件的时候，节点将会插入到条件队列中。当条件触发时，节点将会转移到主队列中。用一个状态值，描述节点在哪一个队列上。</p><h1 id="4、Node"><a href="#4、Node" class="headerlink" title="4、Node"></a>4、Node</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static final class Node &#123;</span><br><span class="line">    //该等待节点处于共享模式</span><br><span class="line">    static final Node SHARED = new Node();</span><br><span class="line">    //该等待节点处于独占模式</span><br><span class="line">    static final Node EXCLUSIVE = null;</span><br><span class="line">    </span><br><span class="line">    //表示节点的线程是已被取消的</span><br><span class="line">    static final int CANCELLED =  1;</span><br><span class="line">    //表示当前节点的后继节点的线程需要被唤醒</span><br><span class="line">    static final int SIGNAL    = -1;</span><br><span class="line">    //表示线程正在等待某个条件</span><br><span class="line">    static final int CONDITION = -2;</span><br><span class="line">    //表示下一个共享模式的节点应该无条件的传播下去</span><br><span class="line">    static final int PROPAGATE = -3;</span><br><span class="line"></span><br><span class="line">    //状态位 ，分别可以使CANCELLED、SINGNAL、CONDITION、PROPAGATE、0 </span><br><span class="line">    volatile int waitStatus;</span><br><span class="line"></span><br><span class="line">    volatile Node prev;//前驱节点</span><br><span class="line">    volatile Node next;//后继节点</span><br><span class="line">    volatile Thread thread;//等待锁的线程</span><br><span class="line"></span><br><span class="line">    //ConditionObject链表的后继节点或者代表共享模式的节点。</span><br><span class="line">    //因为Condition队列只能在独占模式下被能被访问,我们只需要简单的使用链表队列来链接正在等待条件的节点。</span><br><span class="line">    //然后它们会被转移到同步队列（AQS队列）再次重新获取。</span><br><span class="line">    //由于条件队列只能在独占模式下使用，所以我们要表示共享模式的节点的话只要使用特殊值SHARED来标明即可。</span><br><span class="line">    Node nextWaiter;</span><br><span class="line">    //Returns true if node is waiting in shared mode</span><br><span class="line">    final boolean isShared() &#123;</span><br><span class="line">            return nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>waitStatus不同值含义：</p><ul><li>SIGNAL(-1)：当前节点的后继节点已经 (或即将)被阻塞（通过park） , 所以当当前节点释放或则被取消时候，一定要unpark它的后继节点。为了避免竞争，获取方法一定要首先设置node为signal，然后再次重新调用获取方法，如果失败，则阻塞。</li><li>CANCELLED(1)：当前节点由于超时或者被中断而被取消。一旦节点被取消后，那么它的状态值不在会被改变，且当前节点的线程不会再次被阻塞。</li><li>CONDITION(-2) ：该节点的线程处于等待条件状态,不会被当作是同步队列上的节点,直到被唤醒(signal),设置其值为0,重新进入阻塞状态.</li><li>PROPAGATE(-3：)共享模式下的释放操作应该被传播到其他节点。该状态值在doReleaseShared方法中被设置的。</li><li>0：以上都不是</li></ul><p>该状态值为了简便使用，所以使用了数值类型。非负数值意味着该节点不需要被唤醒。所以，大多数代码中不需要检查该状态值的确定值。</p><p>一个正常的Node，它的waitStatus初始化值是0。如果想要修改这个值，可以使用AQS提供CAS进行修改。</p><h1 id="5、独占模式与共享模式"><a href="#5、独占模式与共享模式" class="headerlink" title="5、独占模式与共享模式"></a>5、独占模式与共享模式</h1><p>在锁的获取时，并不一定只有一个线程才能持有这个锁（或者称为同步状态），所以此时有了独占模式和共享模式的区别，也就是在Node节点中由nextWaiter来标识。比如ReentrantLock就是一个独占锁，只能有一个线程获得锁，而WriteAndReadLock的读锁则能由多个线程同时获取，但它的写锁则只能由一个线程持有。</p><h2 id="5-1、独占模式"><a href="#5-1、独占模式" class="headerlink" title="5.1、独占模式"></a>5.1、独占模式</h2><h3 id="5-1-1-独占模式同步状态的获取"><a href="#5-1-1-独占模式同步状态的获取" class="headerlink" title="5.1.1 独占模式同步状态的获取"></a>5.1.1 独占模式同步状态的获取</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//忽略中断的（即不手动抛出InterruptedException异常）独占模式下的获取方法。</span><br><span class="line">//该方法在成功返回前至少会调用一次tryAcquire()方法(该方法是子类重写的方法，如果返回true则代表能成功获取).</span><br><span class="line">//否则当前线程会进入队列排队，重复的阻塞和唤醒等待再次成功获取后返回, </span><br><span class="line">//该方法可以用来实现Lock.lock</span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">       if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法首先尝试获取锁( tryAcquire(arg)的具体实现定义在了子类中),如果获取到,则执行完毕,否则通过addWaiter(Node.EXCLUSIVE), arg)方法把当前节点添加到等待队列末尾,并设置为独占模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">        //把当前线程包装为node,设为独占模式</span><br><span class="line">        Node node = new Node(Thread.currentThread(), mode);</span><br><span class="line">        // 尝试快速入队，即无竞争条件下肯定成功。如果失败，则进入enq自旋重试入队</span><br><span class="line">        Node pred = tail;</span><br><span class="line">        if (pred != null) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            //CAS替换当前尾部。成功则返回</span><br><span class="line">            if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">//插入节点到队列中，如果队列未初始化则初始化，然后再插入。</span><br><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            if (t == null) &#123; // Must initialize</span><br><span class="line">                if (compareAndSetHead(new Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    return t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果tail节点为空,执行enq(node);重新尝试,最终把node插入.在把node插入队列末尾后,它并不立即挂起该节点中线程,因为在插入它的过程中,前面的线程可能已经执行完成,所以它会先进行自旋操作acquireQueued(node, arg),尝试让该线程重新获取锁!当条件满足获取到了锁则可以从自旋过程中退出，否则继续。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">        boolean failed = true;</span><br><span class="line">        try &#123;</span><br><span class="line">            boolean interrupted = false;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                final Node p = node.predecessor();</span><br><span class="line">                //如果它的前继节点为头结点,尝试获取锁,获取成功则返回           </span><br><span class="line">                if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                //判断当前节点的线程是否应该被挂起，如果应该被挂起则挂起。</span><br><span class="line">                //等待release唤醒释放</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (failed)</span><br><span class="line">                //在队列中取消当前节点</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果没获取到锁,则判断是否应该挂起,而这个判断则得通过它的前驱节点的waitStatus来确定:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">        int ws = pred.waitStatus;</span><br><span class="line">        //该节点如果状态如果为SIGNAL。则返回true，然后park挂起线程</span><br><span class="line">        if (ws == Node.SIGNAL)</span><br><span class="line">            return true;</span><br><span class="line">       //表明该节点已经被取消，向前循环重新调整链表节点</span><br><span class="line">        if (ws &gt; 0) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * Predecessor was cancelled. Skip over predecessors and</span><br><span class="line">             * indicate retry.</span><br><span class="line">             */</span><br><span class="line">            do &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //执行到这里代表节点是0或者PROPAGATE，然后标记他们为SIGNAL，但是</span><br><span class="line">            //还不能park挂起线程。需要重试是否能获取，如果不能，则挂起。</span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">//挂起当前线程，且返回线程的中断状态</span><br><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        return Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后,我们对获取独占式锁过程对做个总结:</p><p>AQS的模板方法acquire通过调用子类自定义实现的tryAcquire获取同步状态失败后-&gt;将线程构造成Node节点(addWaiter)-&gt;将Node节点添加到同步队列对尾(addWaiter)-&gt;节点以自旋的方法获取同步状态(acquirQueued)。在节点自旋获取同步状态时，只有其前驱节点是头节点的时候才会尝试获取同步状态，如果该节点的前驱不是头节点或者该节点的前驱节点是头节点单获取同步状态失败，则判断当前线程需要阻塞，如果需要阻塞则需要被唤醒过后才返回。</p><p><font color="DeepPink">获取锁的过程：</font></p><ul><li><font color="DeepPink">当线程调用acquire()申请获取锁资源，如果成功，则进入临界区。</font></li><li><font color="DeepPink">当获取锁失败时，则进入一个FIFO等待队列，然后被挂起等待唤醒。</font></li><li><font color="DeepPink">当队列中的等待线程被唤醒以后就重新尝试获取锁资源，如果成功则进入临界区，否则继续挂起等待。</font></li></ul><h3 id="5-1-2-独占模式同步状态的释放"><a href="#5-1-2-独占模式同步状态的释放" class="headerlink" title="5.1.2 独占模式同步状态的释放"></a>5.1.2 独占模式同步状态的释放</h3><p>既然是释放,那肯定是持有锁的该线程执行释放操作,即head节点中的线程释放锁.</p><p>AQS中的release释放同步状态和acquire获取同步状态一样，都是模板方法，tryRelease释放的具体操作都有子类去实现，父类AQS只提供一个算法骨架。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">//如果node的后继节点不为空且不是作废状态,则唤醒这个后继节点,</span><br><span class="line">//否则从末尾开始寻找合适的节点,如果找到,则唤醒</span><br><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">        int ws = node.waitStatus;</span><br><span class="line">        if (ws &lt; 0)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">            s = null;</span><br><span class="line">            for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                if (t.waitStatus &lt;= 0)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s != null)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>过程：首先调用子类的tryRelease()方法释放锁，然后唤醒后继节点，在唤醒的过程中，需要判断后继节点是否满足情况，如果后继节点不为空且不是作废状态，则唤醒这个后继节点，否则从tail节点向前寻找合适的节点，如果找到，则唤醒。</p><p><font color="DeepPink">释放锁过程：</font></p><ul><li><font color="DeepPink">当线程调用release()进行锁资源释放时，如果没有其他线程在等待锁资源，则释放完成。</font></li><li><font color="DeepPink">如果队列中有其他等待锁资源的线程需要唤醒，则唤醒队列中的第一个等待节点（先入先出）。</font></li></ul><h2 id="5-2、共享模式"><a href="#5-2、共享模式" class="headerlink" title="5.2、共享模式"></a>5.2、共享模式</h2><h3 id="5-2-1-共享模式同步状态的获取"><a href="#5-2-1-共享模式同步状态的获取" class="headerlink" title="5.2.1 共享模式同步状态的获取"></a>5.2.1 共享模式同步状态的获取</h3><ul><li><font color="DeepPink">当线程调用acquireShared()申请获取锁资源时，如果成功，则进入临界区。</font></li><li><font color="DeepPink">当获取锁失败时，则创建一个共享类型的节点并进入一个FIFO等待队列，然后被挂起等待唤醒。</font></li><li><font color="DeepPink">当队列中的等待线程被唤醒以后就重新尝试获取锁资源，如果成功则唤醒后面还在等待的共享节点并把该唤醒事件传递下去，即会依次唤醒在该节点后面的所有共享节点，然后进入临界区，否则继续挂起等待。</font></li></ul><h3 id="5-2-2-共享模式同步状态的释放"><a href="#5-2-2-共享模式同步状态的释放" class="headerlink" title="5.2.2 共享模式同步状态的释放"></a>5.2.2 共享模式同步状态的释放</h3><ul><li><font color="DeepPink">当线程调用releaseShared()进行锁资源释放时，如果释放成功，则唤醒队列中等待的节点，如果有的话。</font></li></ul><h1 id="6-AQS小结"><a href="#6-AQS小结" class="headerlink" title="6. AQS小结"></a>6. AQS小结</h1><p>java.util.concurrent中的很多可阻塞类（比如ReentrantLock）都是基于AQS来实现的。<font color="DeepPink">AQS是一个同步框架，它提供通用机制来原子性管理同步状态、阻塞和唤醒线程，以及维护被阻塞线程的队列。</font></p><p>JDK中AQS被广泛使用，基于AQS实现的同步器包括：</p><ul><li>ReentrantLock</li><li>Semaphore</li><li>ReentrantReadWriteLock（后续会出文章讲解）</li><li>CountDownLatch</li><li>FutureTask</li></ul><p>每一个基于AQS实现的同步器都会包含两种类型的操作，如下：</p><ul><li>至少一个acquire操作。这个操作阻塞调用线程，除非/直到AQS的状态允许这个线程继续执行。</li><li>至少一个release操作。这个操作改变AQS的状态，改变后的状态可允许一个或多个阻塞线程被解除阻塞。</li></ul><p><font color="DeepPink">基于“复合优先于继承”的原则，基于AQS实现的同步器一般都是：声明一个内部私有的继承于AQS的子类Sync，对同步器所有公有方法的调用都会委托给这个内部子类。</font></p><h1 id="7-后续"><a href="#7-后续" class="headerlink" title="7.后续"></a>7.后续</h1><p>后面会推出以下有关AQS的文章，已加深对于AQS的理解</p><ul><li>AQS ConditionObject对象解析</li><li>AQS 应用案例 ReentrantReadWriteLock解析</li><li>Java volatile的内存语义与AQS锁内存可见性</li></ul><h1 id="8-感谢"><a href="#8-感谢" class="headerlink" title="8.感谢"></a>8.感谢</h1><p>本文很多内容整理自网络，参考文献：<br><a href="https://segmentfault.com/a/1190000011376192" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011376192</a><br><a href="https://segmentfault.com/a/1190000011391092" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011391092</a><br><a href="https://zhuanlan.zhihu.com/p/27134110" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27134110</a><br><a href="https://blog.csdn.net/wojiaolinaaa/article/details/50070031" target="_blank" rel="noopener">https://blog.csdn.net/wojiaolinaaa/article/details/50070031</a><br><a href="https://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">https://www.cnblogs.com/waterystone/p/4920797.html</a></p><p>FIFO队列:<a href="https://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">https://www.cnblogs.com/waterystone/p/4920797.html</a></p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> AQS </tag>
            
            <tag> JDK </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 垃圾回收算法之G1</title>
      <link href="/java-gc-g1.html"/>
      <url>/java-gc-g1.html</url>
      
        <content type="html"><![CDATA[<p>G1(Garbage-First)回收器是在JDK1.7中正式使用的全新垃圾回收器，G1拥有独特的垃圾回收策略，从分代上看，G1依然属于分代垃圾回收器，它会区分年代和老年代，依然有eden和survivor区，但从堆的结构上看，它并不要求整个eden区、年清代或者老年代都连续。它使用了全新的分区算法。</p><p>其特点如下：</p><ul><li><p>并行性：G1在回收期间，可以由多个GC线程同时工作，有效利用多核计算能力。</p></li><li><p>并发性：G1拥有与应用程序交替执行的能力，因此一般来说，不会在整个回收期间完全阻塞应用程序。</p></li><li><p>分代GC：与之前回收器不同，其他回收器，它们要么工作在年轻代要么工作在老年代。G1可以同时兼顾年轻代与老年代。</p></li><li><p>空间整理：G1在回收过程中，会进行适当的对象移动，不像CMS，只是简单的标记清除，在若干次GC后CMS必须进行一次碎片整理，G1在每次回收时都会有效的复制对象，减少空间碎片。</p></li><li><p>可预见性：由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收范围，因此对于全局停顿也能得到更好的控制。</p></li></ul><h1 id="一、G1的内存划分和主要收集过程"><a href="#一、G1的内存划分和主要收集过程" class="headerlink" title="一、G1的内存划分和主要收集过程"></a>一、G1的内存划分和主要收集过程</h1><p>G1收集回收器将堆进行分区，划分为一个个的区域，每次收集的时候，只收集其中几个区域，以此来控制垃圾回收产生一次停顿时间。</p><p>G1的收集过程可能有4个阶段：</p><ul><li><p>新生代GC</p></li><li><p>并发标记周期</p></li><li><p>混合收集</p></li><li><p>（如果需要）进行Full GC。</p></li></ul><h1 id="二、G1的新生代GC"><a href="#二、G1的新生代GC" class="headerlink" title="二、G1的新生代GC"></a>二、G1的新生代GC</h1><p>新生代GC的主要工作是回收eden区和survivor区。</p><p>一旦eden区被占满，新生代GC就会启动。新生代GC收集前后的堆数据如下图所示，其中E表示eden区，S表示survivor区，O表示老年代。</p><p><img alt data-src="/images/java-gc-g1/%E6%96%B0%E7%94%9F%E4%BB%A3.png"></p><p>可以看到，新生代GC只处理eden和survivor区，回收后，所有的eden区都应该被清空，而survivor区会被收集一部分数据，但是应该至少仍然存在一个survivor区，类比其他的新生代收集器，这一点似乎并没有太大变化。另一个重要的变化是老年代的区域增多，因为部分survivor区或者eden区的对象可能会晋升到老年代。</p><p>三、G1并发标记周期</p><p>G1的并发阶段和CMS有些类似，它们都是为了降低一次停顿时间，而将可以和应用程序并发执行的部分单独提取出来执行。</p><blockquote><p>并发标记周期针对老年代</p></blockquote><p>并发标记周期可分为以下几步：</p><ul><li><p>初始标记：标记从根节点直接可达的对象。这个阶段会伴随一次新生代GC，它是会产生<font color="DeepPink">全局停顿</font>的，应用程序在这个阶段必须停止执行。</p></li><li><p>根区域扫描：由于初始标记必然会伴随一次新生代GC，所以在初始化标记后，eden被清空，并且存活对象被移到survivor区。在这个阶段，将扫描由survivor区直接可达的老年代区域，并标记这些直接可达的对象。这个过程是可以和应用程序并发执行的。但是根区域扫描不能和新生代GC同时发生（因为根区域扫描依赖survivor区的对象，而新生代GC会修改这个区域），故如果恰巧此时需要新生代GC，GC就需要等待根区域扫描结束后才能进行，如果发生这种情况，这次新生代GC的时间就会延长。</p></li><li><p>并发标记：和CMS类似，并发标记将会扫描并查找整个堆的存活对象，并做好标记。这是一个并发过程，并且这个过程可以被一次新生代GC打断。</p></li><li><p>重新标记：和CMS一样，重新标记也是会使<font color="DeepPink">应用程序停顿</font>，由于在并发标记过程中，应用程序依然运行，因此标记结果可能需要修正，所以在此阶段对上一次标记进行补充。在G1中，这个过程使用SATB（Snapshot-At-The-Begining）算法完成，即G1会在标记之初为存活对象创建一个快照，这个快照有助于加速重新标记的速度。</p></li><li><p>独占清理：顾名思义，这个阶段会引起<font color="DeepPink">停顿</font>。它将计算各个区域的存活对象和GC回收比例并进行排序，识别可供混合回收的区域。在这个阶段，还会更新记忆集。该阶段给出了需要被混合回收的区域并进行了标记，在混合回收阶段，需要这些信息。</p></li><li><p>并发清理阶段：识别并清理完全空闲的区域。它是并发的清理，不会引起停顿。</p></li></ul><blockquote><p>SATB全称是Snapshot-At-The-Beginning，由字面理解，是GC开始时活着的对象的一个快照。它是通过Root Tracing得到的，作用是维持并发GC的正确性。那么它是怎么维持并发GC的正确性的呢？根据三色标记算法，我们知道对象存在三种状态：白：对象没有被标记到，标记阶段结束后，会被当做垃圾回收掉。灰：对象被标记了，但是它的field还没有被标记或标记完。黑：对象被标记了，且它的所有field也被标记完了。</p></blockquote><blockquote><p>SATB 利用 write barrier 将所有即将被删除的引用关系的旧引用记录下来，最后以这些旧引用为根 Stop The World 地重新扫描一遍即可避免漏标问题。 因此G1 Remark阶段 Stop The World 与 CMS了的remark有一个本质上的区别，那就是这个暂停只需要扫描有 write barrier 所追中对象为根的对象， 而 CMS 的remark 需要重新扫描整个根集合，因而CMS remark有可能会非常慢。</p></blockquote><h1 id="四、混合回收"><a href="#四、混合回收" class="headerlink" title="四、混合回收"></a>四、混合回收</h1><p><strong>在并发标记周期中，虽有部分对象被回收，但是回收的比例是非常低的。但是在并发标记周期后，G1已经明确知道哪些区域含有比较多的垃圾对象，在混合回收阶段，就可以专门针对这些区域进行回收。当然G1会优先回收垃圾比例较高的区域（回收这些区域的性价比高），这正是G1名字的由来（Garbage First Garbage Collector：译为垃圾优先的垃圾回收器），这里的垃圾优先（Garbage First）指的是回收时优先选取垃圾比例最高的区域。</strong></p><p>这个阶段叫做混合回收，是因为在这个阶段，即会执行正常的年轻代GC,又会选取一些被标记的老年代区域进行回收，同时处理了新生代和老年代。</p><p><font color="DeepPink">混合回收会被执行多次，直到回收了足够多的内存空间</font>，然后，它会触发一次新生代GC。新生代GC后，又可能会发生一次并发标记周期的处理，最后又会引起混合回收，因此整个过程可能是如下图：</p><p><img alt data-src="/images/java-gc-g1/%E5%9B%9E%E6%94%B6%E5%BE%AA%E7%8E%AF.png"></p><h1 id="五、必要时的Full-GC"><a href="#五、必要时的Full-GC" class="headerlink" title="五、必要时的Full GC"></a>五、必要时的Full GC</h1><p>和CMS类似，并发收集让应用程序和GC线程交替工作，因此在特别繁忙的情况下无可避免的会发生回收过程中内存不足的情况，当遇到这种情况，G1会转入一个Full GC 进行回收。</p><p>以下4种情况会触发这类的Full GC：</p><h2 id="1、并发模式失效"><a href="#1、并发模式失效" class="headerlink" title="1、并发模式失效"></a>1、并发模式失效</h2><p>G1启动标记周期，但在Mix GC之前，老年代就被填满，这时候G1会放弃标记周期。这种情形下，需要增加堆大小，或者调整周期（例如增加线程数-XX:ConcGCThreads等）。</p><p>GC日志如下的示例：</p><p><img alt data-src="/images/java-gc-g1/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E5%A4%B1%E6%95%88.png"></p><p>解决办法：发生这种失败意味着堆的大小应该增加了，或者G1收集器的后台处理应该更早开始，或者需要调整周期，让它运行得更快（如，增加后台处理的线程数）。</p><h2 id="2、晋升失败"><a href="#2、晋升失败" class="headerlink" title="2、晋升失败"></a>2、晋升失败</h2><p>（to-space exhausted或者to-space overflow）</p><p>G1收集器完成了标记阶段，开始启动混合式垃圾回收，清理老年代的分区，不过，老年代空间在垃圾回收释放出足够内存之前就会被耗尽。（G1在进行GC的时候没有足够的内存供存活对象或晋升对象使用），由此触发了Full GC。</p><p>下面日志中（可以在日志中看到(to-space exhausted)或者（to-space overflow）），反应的现象是混合式GC之后紧接着一次Full GC。</p><p><img alt data-src="/images/java-gc-g1/%E6%99%8B%E5%8D%87%E5%A4%B1%E8%B4%A5.png"></p><p>这种失败通常意味着混合式收集需要更迅速的完成垃圾收集：每次新生代垃圾收集需要处理更多老年代的分区。</p><p>解决这种问题的方式是：</p><ul><li><p>增加 -XX:G1ReservePercent选项的值（并相应增加总的堆大小），为“目标空间”增加预留内存量。</p></li><li><p>通过减少 -XX:InitiatingHeapOccupancyPercent 提前启动标记周期。</p></li><li><p>也可以通过增加 -XX:ConcGCThreads 选项的值来增加并行标记线程的数目。</p></li></ul><h2 id="3、疏散失败"><a href="#3、疏散失败" class="headerlink" title="3、疏散失败"></a>3、疏散失败</h2><p>（to-space exhausted或者to-space overflow）</p><p>进行新生代垃圾收集是，Survivor空间和老年代中没有足够的空间容纳所有的幸存对象。这种情形在GC日志中通常是：</p><p><img alt data-src="/images/java-gc-g1/%E7%96%8F%E6%95%A3%E5%A4%B1%E8%B4%A5.png"></p><p>这条日志表明堆已经几乎完全用尽或者碎片化了。G1收集器会尝试修复这一失败，但可以预期，结果会更加恶化：G1收集器会转而使用Full GC。</p><p>解决这种问题的方式是：</p><ul><li><p>增加 -XX:G1ReservePercent选项的值（并相应增加总的堆大小），为“目标空间”增加预留内存量。</p></li><li><p>通过减少 -XX:InitiatingHeapOccupancyPercent 提前启动标记周期。</p></li><li><p>也可以通过增加 -XX:ConcGCThreads 选项的值来增加并行标记线程的数目。</p></li></ul><h2 id="4、Humongous-Object-分配失败"><a href="#4、Humongous-Object-分配失败" class="headerlink" title="4、Humongous Object 分配失败"></a>4、Humongous Object 分配失败</h2><p>当Humongous Object 找不到合适的空间进行分配时，就会启动Full GC，来释放空间。这种情况下，应该避免分配大量的巨型对象，增加内存或者增大-XX:G1HeapRegionSize，使巨型对象不再是巨型对象。</p><blockquote><p>对于Humongous Object 的处理还有一种方式就是切换GC算法到ZGC，因为ZGC中对于Humongous Object 的回收不会特殊处理（比如不会延迟收集）。</p></blockquote><h1 id="六、巨型对象"><a href="#六、巨型对象" class="headerlink" title="六、巨型对象"></a>六、巨型对象</h1><p>Humongous Object：巨型对象<br>Humongous regions：巨型区域</p><p>对于G1而言，只要超过regin大小的一半，就被认为是巨型对象。巨型对象直接被分配到老年代中的“巨型区域”。这些巨型区域是一个连续的区域集。StartsHumongous 标记该连续集的开始，ContinuesHumongous 标记它的延续。</p><p>在分配巨型对象之前先检查是否超过 initiating heap occupancy percent和the marking threshold, 如果超过的话，就启动global concurrent marking，为的是提早回收，防止 evacuation failures 和 Full GC。</p><p>对于巨型对象，有以下几个点需要注意：</p><ul><li><p>没有被引用的巨型对象会在标记清理阶段或者Full GC时被释放掉。</p></li><li><p>为了减少拷贝负载，只有在Full GC的时候，才会压缩大对象region。</p></li><li><p>每一个region中都只有一个巨型对象，该region剩余的部分得不到利用，会导致堆碎片化。</p></li><li><p>如果看到由于大对象分配导致频繁的并发回收，需要把大对象变为普通的对象，建议增大Region size。（或者切换到ZGC）</p></li></ul><blockquote><p>对于增大Region size有一个负面影响就是：减少了可用region的数量。因此，对于这种情况，你需要进行相应的测试，以查看是否实际提高了应用程序的吞吐量或延迟。</p></blockquote><h1 id="七、常见调优参数"><a href="#七、常见调优参数" class="headerlink" title="七、常见调优参数"></a>七、常见调优参数</h1><h2 id="1、-XX-MaxGCPauseMillis-N"><a href="#1、-XX-MaxGCPauseMillis-N" class="headerlink" title="1、-XX:MaxGCPauseMillis=N"></a>1、-XX:MaxGCPauseMillis=N</h2><p>默认200毫秒</p><p>前面介绍过使用GC的最基本的参数：</p><blockquote><p>-XX:+UseG1GC -Xmx32g -XX:MaxGCPauseMillis=200</p></blockquote><p>前面2个参数都好理解，后面这个MaxGCPauseMillis参数该怎么配置呢？这个参数从字面的意思上看，就是允许的GC最大的暂停时间。G1尽量确保每次GC暂停的时间都在设置的MaxGCPauseMillis范围内。那G1是如何做到最大暂停时间的呢？这涉及到另一个概念，CSet(collection set)。它的意思是在一次垃圾收集器中被收集的区域集合。</p><ul><li><p>Young GC：选定所有新生代里的region。通过控制新生代的region个数来控制young GC的开销。</p></li><li><p>Mixed GC：选定所有新生代里的region，外加根据global concurrent marking统计得出收集收益高的若干老年代region。在用户指定的开销目标范围内尽可能选择收益高的老年代region。</p></li></ul><p>在理解了这些后，我们再设置最大暂停时间就有了方向。首先，我们能容忍的最大暂停时间是有一个限度的，我们需要在这个限度范围内设置。但是应该设置的值是多少呢？我们需要在吞吐量跟MaxGCPauseMillis之间做一个平衡。如果MaxGCPauseMillis设置的过小，那么GC就会频繁，吞吐量就会下降。如果MaxGCPauseMillis设置的过大，应用程序暂停时间就会变长。G1的默认暂停时间是200毫秒，我们可以从这里入手，调整合适的时间。</p><h2 id="2、-XX-G1HeapRegionSize-n"><a href="#2、-XX-G1HeapRegionSize-n" class="headerlink" title="2、-XX:G1HeapRegionSize=n"></a>2、-XX:G1HeapRegionSize=n</h2><p>设置的 G1 区域的大小。值是 2 的幂，范围是 1 MB 到 32 MB 之间。目标是根据最小的 Java 堆大小划分出约 2048 个区域。</p><ul><li>-XX:ParallelGCThreads=n（调整G1垃圾收集的后台线程数）</li></ul><p>设置 STW 工作线程数的值。将 n 的值设置为逻辑处理器的数量。n 的值与逻辑处理器的数量相同，最多为 8。</p><p>如果逻辑处理器不止八个，则将 n 的值设置为逻辑处理器数的 5/8 左右。这适用于大多数情况，除非是较大的 SPARC 系统，其中 n 的值可以是逻辑处理器数的 5/16 左右。</p><p>-XX:ConcGCThreads=n（调整G1垃圾收集的后台线程数）</p><p>设置并行标记的线程数。将 n 设置为并行垃圾回收线程数 (ParallelGCThreads) 的 1/4 左右。</p><h2 id="3、-XX-InitiatingHeapOccupancyPercent-45（调整G1垃圾收集运行频率）"><a href="#3、-XX-InitiatingHeapOccupancyPercent-45（调整G1垃圾收集运行频率）" class="headerlink" title="3、 -XX:InitiatingHeapOccupancyPercent=45（调整G1垃圾收集运行频率）"></a>3、 -XX:InitiatingHeapOccupancyPercent=45（调整G1垃圾收集运行频率）</h2><p>设置触发标记周期的 Java 堆占用率阈值。默认占用率是整个 Java 堆的 45%。</p><p>该值设置太高：会陷入Full GC泥潭之中，因为并发阶段没有足够的时间在剩下的堆空间被填满之前完成垃圾收集。</p><p>如果该值设置太小：应用程序又会以超过实际需要的节奏进行大量的后台处理。</p><p>避免使用以下参数：避免使用 -Xmn 选项或 -XX:NewRatio 等其他相关选项显式设置年轻代大小。固定年轻代的大小会覆盖暂停时间目标。</p><h1 id="八、细节"><a href="#八、细节" class="headerlink" title="八、细节"></a>八、细节</h1><h2 id="1、G1-mixed-GC时机？"><a href="#1、G1-mixed-GC时机？" class="headerlink" title="1、G1 mixed GC时机？"></a>1、G1 mixed GC时机？</h2><p>mixed gc中也有一个阈值参数 -XX:InitiatingHeapOccupancyPercent，当老年代大小占整个堆大小百分比达到该阈值时，会触发一次mixed gc.</p><p>在分配humongous object之前先检查是否超过 initiating heap occupancy percent, 如果超过的话，就启动global concurrent marking，为的是提早回收，防止 evacuation failures 和 Full GC。</p><p>为了减少连续H-objs分配对GC的影响，需要把大对象变为普通的对象，建议增大Region size。</p><p>一个Region的大小可以通过参数-XX:G1HeapRegionSize设定，取值范围从1M到32M，且是2的指数。</p><h2 id="2、XX：G1-HeapRegionSize-默认值？"><a href="#2、XX：G1-HeapRegionSize-默认值？" class="headerlink" title="2、XX：G1 HeapRegionSize 默认值？"></a>2、XX：G1 HeapRegionSize 默认值？</h2><p>默认把堆内存按照2048份均分，最后得到一个合理的大小。</p><h2 id="3、直接内存配置"><a href="#3、直接内存配置" class="headerlink" title="3、直接内存配置"></a>3、直接内存配置</h2><p>Q: 什么时候用直接内存？</p><p>A: 读写频繁的场合，出于性能考虑，可以考虑使用直接内存。</p><p>直接内存也是 Java 程序中非常重要的组成部分，特别是 NIO 被广泛使用之后，直接内存可以跳过 Java 堆，使 Java 程序可以直接访问原生堆空间。因此可以在一定程度上加快内存的访问速度。直接内存可以用 -XX:MaxDirectMemorySize 设置，默认值为最大堆空间，也就是 -Xmx。当直接内存达到最大值的时候，也会触发垃圾回收，如果垃圾回收不能有效释放空间，直接内存溢出依然会引起系统的 OOM。</p><p>一般而言直接内存在访问读写上直接内存有较大优势（速度较快），但是在内存空间申请的时候，直接内存毫无优势而言。</p><h2 id="4、RSet"><a href="#4、RSet" class="headerlink" title="4、RSet"></a>4、RSet</h2><p>全称是Remembered Set，是辅助GC过程的一种结构，典型的空间换时间工具，和Card Table有些类似。G1的RSet是在Card Table的基础上实现的：每个Region会记录下别的Region有指向自己的指针，并标记这些指针分别在哪些Card的范围内。这个RSet其实是一个Hash Table，Key是别的Region的起始地址，Value是一个集合，里面的元素是Card Table的Index。</p><p>RSet究竟是怎么辅助GC的呢？</p><p>在做YGC的时候，只需要选定young generation region的RSet作为根集，这些RSet记录了old-&gt;young的跨代引用，避免了扫描整个old generation。而mixed gc的时候，old generation中记录了old-&gt;old的RSet，young-&gt;old的引用由扫描全部young generation region得到，这样也不用扫描全部old generation region。所以RSet的引入大大减少了GC的工作量。</p><h1 id="九、JDK-12中G1的新特性"><a href="#九、JDK-12中G1的新特性" class="headerlink" title="九、JDK 12中G1的新特性"></a>九、JDK 12中G1的新特性</h1><h2 id="1、可中断-mixed-GC"><a href="#1、可中断-mixed-GC" class="headerlink" title="1、可中断 mixed GC"></a>1、可中断 mixed GC</h2><p>如果 Mixed GC 的 G1 存在超出暂停目标的可能性，则使其可被中止。</p><h2 id="2、G1未使用分配内存即时返回"><a href="#2、G1未使用分配内存即时返回" class="headerlink" title="2、G1未使用分配内存即时返回"></a>2、G1未使用分配内存即时返回</h2><p>增强 G1垃圾收集器，以便在空闲时自动将 Java 堆内存返回给操作系统。</p><h1 id="十、GC-发展趋势"><a href="#十、GC-发展趋势" class="headerlink" title="十、GC 发展趋势"></a>十、GC 发展趋势</h1><p>其实可以看到Java 垃圾回收器的趋势，就是在大内存堆的前提下尽 GC 可能的降低对应用程序的影响；从 CMS 的分阶段增量标记，到 G1 通过 SATB 算法改正 remark 阶段的 Stop The World 的影响，再到 ZGC/C4甚至在标记阶段无需 Stop The World，莫不如此。</p><h1 id="十一、结尾"><a href="#十一、结尾" class="headerlink" title="十一、结尾"></a>十一、结尾</h1><p>推荐几种学习这种GC的方式：</p><ul><li><p>看JEP（JDK Enhancement Proposal）知道它的来龙去脉。</p></li><li><p>看相应算法的paper（之前看Shenandoah GC Paper的时候，就有一种收获很大的感觉，因为Shenandoah GC的处理方式，介于G1跟ZGC之间，所以看了Shenandoah GC Paper感觉对于G1、ZGC的理解也更加深入了）。</p></li></ul><p>会在文章结束，补充上JEP官网地址跟我收集的一些GC资料（包含部分paper）github地址。</p><p>补一个我自己归纳的GC图：</p><p><img alt data-src="/images/java-gc-g1/GC%E8%84%89%E7%BB%9C.png"></p><p>各种GC算法都是围绕着，图中内容展开的，只是各自的处理方式不同而已。</p><p>资料推荐：</p><p>1、GC算法及paper</p><p><a href="https://github.com/jiankunking/books-recommendation/tree/master/GC" target="_blank" rel="noopener">https://github.com/jiankunking/books-recommendation/tree/master/GC</a></p><p>2、Java相关书籍推荐</p><p><a href="https://github.com/jiankunking/books-recommendation/tree/master/Java" target="_blank" rel="noopener">https://github.com/jiankunking/books-recommendation/tree/master/Java</a></p><p>参考文献</p><p>1、实战JAVA虚拟机 JVM故障诊断与性能优化</p><p>2、jeps</p><p>3、其它</p><p><a href="https://www.oracle.com/technetwork/articles/java/g1gc-1984535.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/articles/java/g1gc-1984535.html</a></p><p><a href="https://plumbr.io/handbook/gc-tuning-in-practice/other-examples/humongous-allocations" target="_blank" rel="noopener">https://plumbr.io/handbook/gc-tuning-in-practice/other-examples/humongous-allocations</a></p>]]></content>
      
      
      <categories>
          
          <category> GC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> GC </tag>
            
            <tag> G1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Spring AOP与IOC的个人思考</title>
      <link href="/spring-aop-ioc-think.html"/>
      <url>/spring-aop-ioc-think.html</url>
      
        <content type="html"><![CDATA[<p>在阅读本文前，强烈建议阅读：<br><a href="http://www.jiankunking.com/java-jdk-aop.html" target="_blank" rel="noopener">Java JDK 动态代理（AOP）使用及实现原理分析</a></p><a id="more"></a><p>AOP是Spring提供的关键特性之一。AOP即面向切面编程，是OOP编程的有效补充。使用AOP技术，可以将一些系统性相关的编程工作，独立提取出来，独立实现，然后通过切面切入进系统。从而避免了在业务逻辑的代码中混入很多的系统相关的逻辑——比如权限管理，事物管理，日志记录等等。这些系统性的编程工作都可以独立编码实现，然后通过AOP技术切入进系统即可。从而达到了将不同的关注点分离出来的效果。<br><img alt data-src="/images/spring-jdk-aop-think/AOP%E7%A4%BA%E6%84%8F.png"><br>本文深入剖析Spring的AOP的原理。</p><h1 id="一、AOP-的实现原理"><a href="#一、AOP-的实现原理" class="headerlink" title="一、AOP 的实现原理"></a>一、AOP 的实现原理</h1><p>AOP分为静态AOP和动态AOP。</p><p>静态AOP是指AspectJ实现的AOP，他是将切面代码直接编译到Java类文件中。</p><p>动态AOP是指将切面代码进行动态织入实现的AOP。</p><p>Spring的AOP为动态AOP，实现的技术为：JDK提供的动态代理技术 和 CGLIB(动态字节码增强技术)。尽管实现技术不一样，但都是基于代理模式，都是生成一个代理对象。</p><h2 id="1、JDK动态代理"><a href="#1、JDK动态代理" class="headerlink" title="1、JDK动态代理"></a>1、JDK动态代理</h2><p>JDK部分解析参考：<br><a href="https://juejin.im/post/5d31c1b7f265da1b9421845d" target="_blank" rel="noopener">Java JDK 动态代理（AOP）使用及实现原理分析</a></p><h2 id="2、CGLIB（code-generate-libary）"><a href="#2、CGLIB（code-generate-libary）" class="headerlink" title="2、CGLIB（code generate libary）"></a>2、CGLIB（code generate libary）</h2><p>字节码生成技术实现AOP，其实就是继承被代理对象，然后Override需要被代理的方法，在覆盖该方法时，自然是可以插入我们自己的代码的。</p><p><font color="DeepPink">因为需要Override被代理对象的方法，所以自然CGLIB技术实现AOP时，就必须要求需要被代理的方法不能是final方法，因为final方法不能被子类覆盖。</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package net.aazj.aop;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import net.sf.cglib.proxy.Enhancer;</span><br><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line">public class CGProxy implements MethodInterceptor&#123;</span><br><span class="line">    private Object target;    // 被代理对象</span><br><span class="line">    public CGProxy(Object target)&#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;do sth before....&quot;);</span><br><span class="line">        Object result = proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(&quot;do sth after....&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    public Object getProxyObject() &#123;</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">        // 设置父类</span><br><span class="line">        enhancer.setSuperclass(this.target.getClass());    </span><br><span class="line">        // 设置回调</span><br><span class="line">        enhancer.setCallback(this);    // 在调用父类方法时，回调 this.intercept()</span><br><span class="line">        // 创建代理对象</span><br><span class="line">        return enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line">    public void addUser(User user);</span><br><span class="line">    public User getUser(int id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    public void addUser(User user) &#123;</span><br><span class="line">        System.out.println(&quot;add user into database.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public User getUser(int id) &#123;</span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setId(id);</span><br><span class="line">        System.out.println(&quot;getUser from database.&quot;);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CGProxyTest &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">         // 被代理的对象</span><br><span class="line">        Object proxyedObject = new UserServiceImpl();   </span><br><span class="line">        CGProxy cgProxy = new CGProxy(proxyedObject);</span><br><span class="line">        UserService proxyObject = (UserService) cgProxy.getProxyObject();</span><br><span class="line">        proxyObject.getUser(1);</span><br><span class="line">        proxyObject.addUser(new User());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">do sth before....</span><br><span class="line">getUser from database.</span><br><span class="line">do sth after....</span><br><span class="line">do sth before....</span><br><span class="line">add user into database.</span><br><span class="line">do sth after....</span><br></pre></td></tr></table></figure><p>它的原理是：生成一个父类<br>enhancer.setSuperclass(this.target.getClass())<br>的子类enhancer.create(),然后对父类的方法进行拦截enhancer.setCallback(this). </p><h1 id="二、思考"><a href="#二、思考" class="headerlink" title="二、思考"></a>二、思考</h1><p>从以上两种代理方式可以看出，<font color="DeepPink">实现AOP的关键是：动态代理，即将需要用的接口、类再包装一层，通过动态修改字节码文件实现各种拦截与通知。</font></p><p><font color="DeepPink">注意，两者(JDK动态代理、CGLIB)都需要：要代理真实对象的实例。</font></p><p>比如：在Spring MVC的Controller层一般@Autowired是Service接口，但带有@Service标识的却是实现Service接口的实体类，这样对于JDK动态代理来说已经足以生成代理类了(其实，不过是cglib还是jdk的动态代理，你直接@Autowired Service接口实现类，也是可以注入成功的，但不如注入Service接口灵活)，大家在跟踪代码的时候可以看一下Spring注入的bean真正的类型，你就可以发现它是代理生成的实例。 </p><p>比如这种： </p><p><img alt data-src="/images/spring-jdk-aop-think/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B.png"></p><p>带有注解标识的接口或者在Spring.XML中配置的bean会在Spring初始化的时候，被Spring通过反射加载实例化到Spring容器中。</p><blockquote><p>做过Client/Server架构开发的朋友应该知道，在Application运行过程中一般都会有一个应用上下文Context，一般将一些系统信息放在里面，比如一些登录信息、WCF连接实例等。这些信息在系统的任何地方都可以取到（其实就是一些顶级变量集合，生命周期最长的一些家伙）。</p></blockquote><blockquote><p>换个角度想一下，如果我们在Application初始化的时候，用反射（获取要代理对象的实例）和动态代理获取有注解标识或者在xml中配置bean的实例，并放到应用上下文Context中，在需要的地方都能取到，这不就是一个简单版的Spring 容器吗？</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
            <tag> Spring </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-JDK-动态代理（AOP）使用及实现原理分析</title>
      <link href="/java-jdk-aop.html"/>
      <url>/java-jdk-aop.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、什么是代理？"><a href="#一、什么是代理？" class="headerlink" title="一、什么是代理？"></a>一、什么是代理？</h1><p>代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问。代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。</p><p>代理模式UML图：</p><p><img alt data-src="/images/spring-jdk-aop/UML.png"><br>简单结构示意图：</p><p><img alt data-src="/images/spring-jdk-aop/%E7%AE%80%E5%8D%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png"><br>为了保持行为的一致性，代理类和委托类通常会实现相同的接口，所以在访问者看来两者没有丝毫的区别。通过代理类这中间一层，能有效控制对委托类对象的直接访问，也可以很好地隐藏和保护委托类对象，同时也为实施不同控制策略预留了空间，从而在设计上获得了更大的灵活性。Java 动态代理机制以巧妙的方式近乎完美地实践了代理模式的设计理念。</p><h1 id="二、Java-动态代理类"><a href="#二、Java-动态代理类" class="headerlink" title="二、Java 动态代理类"></a>二、Java 动态代理类</h1><p>Java动态代理类位于java.lang.reflect包下，一般主要涉及到以下两个类：</p><p>(1)Interface InvocationHandler：该接口中仅定义了一个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public object invoke(Object obj,Method method, Object[] args)</span><br></pre></td></tr></table></figure><p>在实际使用时，<font color="DeepPink">第一个参数obj一般是指代理类，method是被代理的方法，如上例中的request()，args为该方法的参数数组。</font>这个抽象方法在代理类中动态实现。</p><p>(2)Proxy：该类即为动态代理类，其中主要包含以下内容：</p><p>protected Proxy(InvocationHandler h)：构造函数，用于给内部的h赋值。</p><p>static Class getProxyClass(</p><p>ClassLoader loader,</p><p>Class[] interfaces)：获得一个代理类，其中loader是类装载器，interfaces是真实类所拥有的全部接口的数组。</p><p>static Object newProxyInstance(ClassLoaderloader, Class[] interfaces,InvocationHandler h)：返回代理类的一个实例，返回后的代理类可以当作被代理类使用(可使用被代理类的在Subject接口中声明过的方法)</p><p>所谓DynamicProxy是这样一种class：<font color="DeepPink">它是在运行时生成的class，在生成它时你必须提供一组interface给它，然后该class就宣称它实现了这些interface。</font>你当然可以把该class的实例当作这些interface中的任何一个来用。当然，这个DynamicProxy其实就是一个Proxy，它不会替你作实质性的工作，<font color="DeepPink">在生成它的实例时你必须提供一个handler，由它接管实际的工作。</font></p><p>在使用动态代理类时，我们必须实现InvocationHandler接口</p><p>通过这种方式，被代理的对象(RealSubject)可以在运行时动态改变，需要控制的接口(Subject接口)可以在运行时改变，控制的方式(DynamicSubject类)也可以动态改变，从而实现了非常灵活的动态代理关系。</p><p>动态代理步骤：</p><ol><li><p>创建一个实现接口InvocationHandler的类，它必须实现invoke方法</p></li><li><p>创建被代理的类以及接口</p></li><li><p>通过Proxy的静态方法</p></li></ol><p>newProxyInstance(ClassLoaderloader,Class[]interfaces,InvocationHandler h)创建一个代理</p><ol start="4"><li>通过代理调用方法</li></ol><h1 id="三、JDK的动态代理怎么使用？"><a href="#三、JDK的动态代理怎么使用？" class="headerlink" title="三、JDK的动态代理怎么使用？"></a>三、JDK的动态代理怎么使用？</h1><p>1、需要动态代理的接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package jiankunking;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 需要动态代理的接口</span><br><span class="line"> */</span><br><span class="line">public interface Subject &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 你好</span><br><span class="line">     *</span><br><span class="line">     * @param name</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String SayHello(String name);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 再见</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String SayGoodBye();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、需要代理的实际对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package jiankunking;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 实际对象</span><br><span class="line"> */</span><br><span class="line">public class RealSubject implements Subject &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 你好</span><br><span class="line">     *</span><br><span class="line">     * @param name</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public String SayHello(String name) &#123;</span><br><span class="line">        return &quot;hello &quot; + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 再见</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public String SayGoodBye() &#123;</span><br><span class="line">        return &quot; good bye &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、调用处理器实现类（有木有感觉这里就是传说中的AOP啊）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package jiankunking;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 调用处理器实现类</span><br><span class="line"> * 每次生成动态代理类对象时都需要指定一个实现了该接口的调用处理器对象</span><br><span class="line"> */</span><br><span class="line">public class InvocationHandlerImpl implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这个就是我们要代理的真实对象</span><br><span class="line">     */</span><br><span class="line">    private Object subject;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构造方法，给我们要代理的真实对象赋初值</span><br><span class="line">     *</span><br><span class="line">     * @param subject</span><br><span class="line">     */</span><br><span class="line">    public InvocationHandlerImpl(Object subject) &#123;</span><br><span class="line">        this.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 该方法负责集中处理动态代理类上的所有方法调用。</span><br><span class="line">     * 调用处理器根据这三个参数进行预处理或分派到委托类实例上反射执行</span><br><span class="line">     *</span><br><span class="line">     * @param proxy  代理类实例</span><br><span class="line">     * @param method 被调用的方法对象</span><br><span class="line">     * @param args   调用参数</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Throwable</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        //在代理真实对象前我们可以添加一些自己的操作</span><br><span class="line">        System.out.println(&quot;在调用之前，我要干点啥呢？&quot;);</span><br><span class="line">        System.out.println(&quot;Method:&quot; + method);</span><br><span class="line">        //当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用</span><br><span class="line">        Object returnValue = method.invoke(subject, args);</span><br><span class="line">        //在代理真实对象后我们也可以添加一些自己的操作</span><br><span class="line">        System.out.println(&quot;在调用之后，我要干点啥呢？&quot;);</span><br><span class="line">        return returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package jiankunking;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 动态代理演示</span><br><span class="line"> */</span><br><span class="line">public class DynamicProxyDemonstration &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //代理的真实对象</span><br><span class="line">        Subject realSubject = new RealSubject();</span><br><span class="line">        /**</span><br><span class="line">         * InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发</span><br><span class="line">         * 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用.</span><br><span class="line">         * 即：要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法</span><br><span class="line">         */</span><br><span class="line">        InvocationHandler handler = new InvocationHandlerImpl(realSubject);</span><br><span class="line"></span><br><span class="line">        ClassLoader loader = handler.getClass().getClassLoader();</span><br><span class="line">        Class&lt;?&gt;[] interfaces = realSubject.getClass().getInterfaces();</span><br><span class="line">        /**</span><br><span class="line">         * 该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</span><br><span class="line">         */</span><br><span class="line">        Subject subject = (Subject) Proxy.newProxyInstance(loader, interfaces, handler);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;动态代理对象的类型：&quot; + subject.getClass().getName());</span><br><span class="line"></span><br><span class="line">        String hello = subject.SayHello(&quot;jiankunking&quot;);</span><br><span class="line">        System.out.println(hello);</span><br><span class="line">//        String goodbye = subject.SayGoodBye();</span><br><span class="line">//        System.out.println(goodbye);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、输出结果如下：</p><p><img alt data-src="/images/spring-jdk-aop/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%BC%94%E7%A4%BA%E8%BE%93%E5%87%BA.png"></p><h1 id="四、动态代理怎么实现的？"><a href="#四、动态代理怎么实现的？" class="headerlink" title="四、动态代理怎么实现的？"></a>四、动态代理怎么实现的？</h1><p>从使用代码中可以看出，关键点在：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Subject subject = (Subject) Proxy.newProxyInstance(loader, interfaces, handler);</span><br></pre></td></tr></table></figure><p>通过跟踪提示代码可以看出：<font color="DeepPink">当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用。</font></p><p>也就是说，当代码执行到：subject.SayHello(“jiankunking”)这句话时，会自动调用InvocationHandlerImpl的invoke方法。这是为啥呢？</p><blockquote><p>下面是代码跟分析的过程，不想看的朋友可以直接看结论</p></blockquote><p>以下代码来自:JDK1.8.0_92</p><p>既然生成代理对象是用的Proxy类的静态方newProxyInstance，那么我们就去它的源码里看一下它到底都做了些什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns an instance of a proxy class for the specified interfaces</span><br><span class="line"> * that dispatches method invocations to the specified invocation</span><br><span class="line"> * handler.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;&#123;@code Proxy.newProxyInstance&#125; throws</span><br><span class="line"> * &#123;@code IllegalArgumentException&#125; for the same reasons that</span><br><span class="line"> * &#123;@code Proxy.getProxyClass&#125; does.</span><br><span class="line"> *</span><br><span class="line"> * @param   loader the class loader to define the proxy class</span><br><span class="line"> * @param   interfaces the list of interfaces for the proxy class</span><br><span class="line"> *          to implement</span><br><span class="line"> * @param   h the invocation handler to dispatch method invocations to</span><br><span class="line"> * @return  a proxy instance with the specified invocation handler of a</span><br><span class="line"> *          proxy class that is defined by the specified class loader</span><br><span class="line"> *          and that implements the specified interfaces</span><br><span class="line"> * @throws  IllegalArgumentException if any of the restrictions on the</span><br><span class="line"> *          parameters that may be passed to &#123;@code getProxyClass&#125;</span><br><span class="line"> *          are violated</span><br><span class="line"> * @throws  SecurityException if a security manager, &lt;em&gt;s&lt;/em&gt;, is present</span><br><span class="line"> *          and any of the following conditions is met:</span><br><span class="line"> *          &lt;ul&gt;</span><br><span class="line"> *          &lt;li&gt; the given &#123;@code loader&#125; is &#123;@code null&#125; and</span><br><span class="line"> *               the caller&apos;s class loader is not &#123;@code null&#125; and the</span><br><span class="line"> *               invocation of &#123;@link SecurityManager#checkPermission</span><br><span class="line"> *               s.checkPermission&#125; with</span><br><span class="line"> *               &#123;@code RuntimePermission(&quot;getClassLoader&quot;)&#125; permission</span><br><span class="line"> *               denies access;&lt;/li&gt;</span><br><span class="line"> *          &lt;li&gt; for each proxy interface, &#123;@code intf&#125;,</span><br><span class="line"> *               the caller&apos;s class loader is not the same as or an</span><br><span class="line"> *               ancestor of the class loader for &#123;@code intf&#125; and</span><br><span class="line"> *               invocation of &#123;@link SecurityManager#checkPackageAccess</span><br><span class="line"> *               s.checkPackageAccess()&#125; denies access to &#123;@code intf&#125;;&lt;/li&gt;</span><br><span class="line"> *          &lt;li&gt; any of the given proxy interfaces is non-public and the</span><br><span class="line"> *               caller class is not in the same &#123;@linkplain Package runtime package&#125;</span><br><span class="line"> *               as the non-public interface and the invocation of</span><br><span class="line"> *               &#123;@link SecurityManager#checkPermission s.checkPermission&#125; with</span><br><span class="line"> *               &#123;@code ReflectPermission(&quot;newProxyInPackage.&#123;package name&#125;&quot;)&#125;</span><br><span class="line"> *               permission denies access.&lt;/li&gt;</span><br><span class="line"> *          &lt;/ul&gt;</span><br><span class="line"> * @throws  NullPointerException if the &#123;@code interfaces&#125; array</span><br><span class="line"> *          argument or any of its elements are &#123;@code null&#125;, or</span><br><span class="line"> *          if the invocation handler, &#123;@code h&#125;, is</span><br><span class="line"> *          &#123;@code null&#125;</span><br><span class="line"> */</span><br><span class="line">@CallerSensitive </span><br><span class="line">public static Object newProxyInstance(ClassLoader loader,</span><br><span class="line">                                          Class&lt;?&gt;[] interfaces,</span><br><span class="line">                                          InvocationHandler h) throws IllegalArgumentException &#123;</span><br><span class="line">        //检查h 不为空，否则抛异常</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line"> </span><br><span class="line">        final Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">        final SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        if (sm != null) &#123;</span><br><span class="line">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        /*</span><br><span class="line">         * 获得与指定类装载器和一组接口相关的代理类类型对象</span><br><span class="line">         */</span><br><span class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"> </span><br><span class="line">        /*</span><br><span class="line">         * 通过反射获取构造函数对象并生成代理类实例</span><br><span class="line">         */</span><br><span class="line">        try &#123;</span><br><span class="line">            if (sm != null) &#123;</span><br><span class="line">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">            &#125;</span><br><span class="line">            //获取代理对象的构造方法（也就是$Proxy0(InvocationHandler h)） </span><br><span class="line">            final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">            final InvocationHandler ih = h;</span><br><span class="line">            if (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    public Void run() &#123;</span><br><span class="line">                        cons.setAccessible(true);</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            //生成代理类的实例并把InvocationHandlerImpl的实例传给它的构造方法</span><br><span class="line">            return cons.newInstance(new Object[]&#123;h&#125;);</span><br><span class="line">        &#125; catch (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">            throw new InternalError(e.toString(), e);</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            Throwable t = e.getCause();</span><br><span class="line">            if (t instanceof RuntimeException) &#123;</span><br><span class="line">                throw (RuntimeException) t;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new InternalError(t.toString(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            throw new InternalError(e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们再进去getProxyClass0方法看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Generate a proxy class.  Must call the checkProxyAccess method</span><br><span class="line"> * to perform permission checks before calling this.</span><br><span class="line"> */</span><br><span class="line">private static Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                       Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    if (interfaces.length &gt; 65535) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;interface limit exceeded&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // If the proxy class defined by the given loader implementing</span><br><span class="line">    // the given interfaces exists, this will simply return the cached copy;</span><br><span class="line">    // otherwise, it will create the proxy class via the ProxyClassFactory</span><br><span class="line">    return proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真相还是没有来到，继续，看一下 proxyClassCache</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * a cache of proxy classes</span><br><span class="line"> */</span><br><span class="line">private static final WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory());</span><br></pre></td></tr></table></figure><p>奥，原来用了一下缓存啊</p><p>那么它对应的get方法啥样呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Look-up the value through the cache. This always evaluates the</span><br><span class="line"> * &#123;@code subKeyFactory&#125; function and optionally evaluates</span><br><span class="line"> * &#123;@code valueFactory&#125; function if there is no entry in the cache for given</span><br><span class="line"> * pair of (key, subKey) or the entry has already been cleared.</span><br><span class="line"> *</span><br><span class="line"> * @param key       possibly null key</span><br><span class="line"> * @param parameter parameter used together with key to create sub-key and</span><br><span class="line"> *                  value (should not be null)</span><br><span class="line"> * @return the cached value (never null)</span><br><span class="line"> * @throws NullPointerException if &#123;@code parameter&#125; passed in or</span><br><span class="line"> *                              &#123;@code sub-key&#125; calculated by</span><br><span class="line"> *                              &#123;@code subKeyFactory&#125; or &#123;@code value&#125;</span><br><span class="line"> *                              calculated by &#123;@code valueFactory&#125; is null.</span><br><span class="line"> */</span><br><span class="line">public V get(K key, P parameter) &#123;</span><br><span class="line">    Objects.requireNonNull(parameter);</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line">    Object cacheKey = CacheKey.valueOf(key, refQueue);</span><br><span class="line">    // lazily install the 2nd level valuesMap for the particular cacheKey</span><br><span class="line">    ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);</span><br><span class="line">    if (valuesMap == null) &#123;</span><br><span class="line">       //putIfAbsent这个方法在key不存在的时候加入一个值,如果key存在就不放入</span><br><span class="line">        ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap = map.putIfAbsent(cacheKey,valuesMap = new ConcurrentHashMap&lt;&gt;());</span><br><span class="line">        if (oldValuesMap != null) &#123;</span><br><span class="line">            valuesMap = oldValuesMap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // create subKey and retrieve the possible Supplier&lt;V&gt; stored by that</span><br><span class="line">    // subKey from valuesMap</span><br><span class="line">    Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class="line">    Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">    Factory factory = null;</span><br><span class="line"> </span><br><span class="line">    while (true) &#123;</span><br><span class="line">        if (supplier != null) &#123;</span><br><span class="line">            // supplier might be a Factory or a CacheValue&lt;V&gt; instance</span><br><span class="line">            V value = supplier.get();</span><br><span class="line">            if (value != null) &#123;</span><br><span class="line">                return value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // else no supplier in cache</span><br><span class="line">        // or a supplier that returned null (could be a cleared CacheValue</span><br><span class="line">        // or a Factory that wasn&apos;t successful in installing the CacheValue)</span><br><span class="line"> </span><br><span class="line">        // lazily construct a Factory</span><br><span class="line">        if (factory == null) &#123;</span><br><span class="line">            factory = new Factory(key, parameter, subKey, valuesMap);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        if (supplier == null) &#123;        </span><br><span class="line">            supplier = valuesMap.putIfAbsent(subKey, factory);</span><br><span class="line">            if (supplier == null) &#123;</span><br><span class="line">                // successfully installed Factory</span><br><span class="line">                supplier = factory;</span><br><span class="line">            &#125;</span><br><span class="line">            // else retry with winning supplier</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (valuesMap.replace(subKey, supplier, factory)) &#123;</span><br><span class="line">                // successfully replaced</span><br><span class="line">                // cleared CacheEntry / unsuccessful Factory</span><br><span class="line">                // with our Factory</span><br><span class="line">                supplier = factory;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // retry with current supplier</span><br><span class="line">                supplier = valuesMap.get(subKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到它调用了 supplier.get(); 获取动态代理类，其中supplier是Factory,这个类定义在WeakCach的内部。</p><p>来瞅瞅，get里面又做了什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V get() &#123; // serialize access</span><br><span class="line">            // re-check</span><br><span class="line">            Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">            if (supplier != this) &#123;</span><br><span class="line">                // something changed while we were waiting:</span><br><span class="line">                // might be that we were replaced by a CacheValue</span><br><span class="line">                // or were removed because of failure -&gt;</span><br><span class="line">                // return null to signal WeakCache.get() to retry</span><br><span class="line">                // the loop</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            // else still us (supplier == this)</span><br><span class="line"> </span><br><span class="line">            // create new value</span><br><span class="line">            V value = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                value = Objects.requireNonNull(valueFactory.apply(key, parameter));</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (value == null) &#123; // remove us on failure</span><br><span class="line">                    valuesMap.remove(subKey, this);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // the only path to reach here is with non-null value</span><br><span class="line">            assert value != null;</span><br><span class="line"> </span><br><span class="line">            // wrap value with CacheValue (WeakReference)</span><br><span class="line">            CacheValue&lt;V&gt; cacheValue = new CacheValue&lt;&gt;(value);</span><br><span class="line"> </span><br><span class="line">            // try replacing us with CacheValue (this should always succeed)</span><br><span class="line">            if (valuesMap.replace(subKey, this, cacheValue)) &#123;</span><br><span class="line">                // put also in reverseMap</span><br><span class="line">                reverseMap.put(cacheValue, Boolean.TRUE);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new AssertionError(&quot;Should not reach here&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            // successfully replaced us with new CacheValue -&gt; return the value</span><br><span class="line">            // wrapped by it</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>发现重点还是木有出现，但我们可以看到它调用了valueFactory.apply(key, parameter)方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * A factory function that generates, defines and returns the proxy class given</span><br><span class="line"> * the ClassLoader and array of interfaces.</span><br><span class="line"> */</span><br><span class="line">private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; &#123;</span><br><span class="line">    // prefix for all proxy class names</span><br><span class="line">    private static final String proxyClassNamePrefix = &quot;$Proxy&quot;;</span><br><span class="line"> </span><br><span class="line">    // next number to use for generation of unique proxy class names</span><br><span class="line">    private static final AtomicLong nextUniqueNumber = new AtomicLong();</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">        for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * Verify that the class loader resolves the name of this</span><br><span class="line">             * interface to the same Class object.</span><br><span class="line">             */</span><br><span class="line">            Class&lt;?&gt; interfaceClass = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                interfaceClass = Class.forName(intf.getName(), false, loader);</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            if (interfaceClass != intf) &#123;</span><br><span class="line">                throw new IllegalArgumentException(</span><br><span class="line">                    intf + &quot; is not visible from class loader&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            /*</span><br><span class="line">             * Verify that the Class object actually represents an</span><br><span class="line">             * interface.</span><br><span class="line">             */</span><br><span class="line">            if (!interfaceClass.isInterface()) &#123;</span><br><span class="line">                throw new IllegalArgumentException(</span><br><span class="line">                    interfaceClass.getName() + &quot; is not an interface&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            /*</span><br><span class="line">             * Verify that this interface is not a duplicate.</span><br><span class="line">             */</span><br><span class="line">            if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123;</span><br><span class="line">                throw new IllegalArgumentException(</span><br><span class="line">                    &quot;repeated interface: &quot; + interfaceClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        String proxyPkg = null;     // package to define proxy class in</span><br><span class="line">        int accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"> </span><br><span class="line">        /*</span><br><span class="line">         * Record the package of a non-public proxy interface so that the</span><br><span class="line">         * proxy class will be defined in the same package.  Verify that</span><br><span class="line">         * all non-public proxy interfaces are in the same package.</span><br><span class="line">         */</span><br><span class="line">        for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">            int flags = intf.getModifiers();</span><br><span class="line">            if (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">                accessFlags = Modifier.FINAL;</span><br><span class="line">                String name = intf.getName();</span><br><span class="line">                int n = name.lastIndexOf(&apos;.&apos;);</span><br><span class="line">                String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1));</span><br><span class="line">                if (proxyPkg == null) &#123;</span><br><span class="line">                    proxyPkg = pkg;</span><br><span class="line">                &#125; else if (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                    throw new IllegalArgumentException(</span><br><span class="line">                        &quot;non-public interfaces from different packages&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        if (proxyPkg == null) &#123;</span><br><span class="line">            // if no non-public proxy interfaces, use com.sun.proxy package</span><br><span class="line">            proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        /*</span><br><span class="line">         * Choose a name for the proxy class to generate.</span><br><span class="line">         */</span><br><span class="line">        long num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">        String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"> </span><br><span class="line">        /*</span><br><span class="line">         * Generate the specified proxy class.</span><br><span class="line">         */</span><br><span class="line">        byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">            proxyName, interfaces, accessFlags);</span><br><span class="line">        try &#123;</span><br><span class="line">            return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length);</span><br><span class="line">        &#125; catch (ClassFormatError e) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * A ClassFormatError here means that (barring bugs in the</span><br><span class="line">             * proxy class generation code) there was some other</span><br><span class="line">             * invalid aspect of the arguments supplied to the proxy</span><br><span class="line">             * class creation (such as virtual machine limitations</span><br><span class="line">             * exceeded).</span><br><span class="line">             */</span><br><span class="line">            throw new IllegalArgumentException(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过看代码终于找到了重点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//生成字节码</span><br><span class="line">byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</span><br></pre></td></tr></table></figure><p>那么接下来我们也使用测试一下，使用这个方法生成的字节码是个什么样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">package jiankunking;</span><br><span class="line"> </span><br><span class="line">import sun.misc.ProxyGenerator;</span><br><span class="line"> </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 动态代理演示</span><br><span class="line"> */</span><br><span class="line">public class DynamicProxyDemonstration &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //代理的真实对象</span><br><span class="line">        Subject realSubject = new RealSubject();</span><br><span class="line"> </span><br><span class="line">        /**</span><br><span class="line">         * InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发</span><br><span class="line">         * 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用.</span><br><span class="line">         * 即：要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法</span><br><span class="line">         */</span><br><span class="line">        InvocationHandler handler = new InvocationHandlerImpl(realSubject);</span><br><span class="line"> </span><br><span class="line">        ClassLoader loader = handler.getClass().getClassLoader();</span><br><span class="line">        Class[] interfaces = realSubject.getClass().getInterfaces();</span><br><span class="line">        /**</span><br><span class="line">         * 该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</span><br><span class="line">         */</span><br><span class="line">        Subject subject = (Subject) Proxy.newProxyInstance(loader, interfaces, handler);</span><br><span class="line">        System.out.println(&quot;动态代理对象的类型：&quot;+subject.getClass().getName());</span><br><span class="line"></span><br><span class="line">        String hello = subject.SayHello(&quot;jiankunking&quot;);</span><br><span class="line">        System.out.println(hello);</span><br><span class="line">        // 将生成的字节码保存到本地，</span><br><span class="line">        createProxyClassFile();</span><br><span class="line">    &#125;</span><br><span class="line">    private static void createProxyClassFile()&#123;</span><br><span class="line">        String name = &quot;ProxySubject&quot;;</span><br><span class="line">        byte[] data = ProxyGenerator.generateProxyClass(name,new Class[]&#123;Subject.class&#125;);</span><br><span class="line">        FileOutputStream out =null;</span><br><span class="line">        try &#123;</span><br><span class="line">            out = new FileOutputStream(name+&quot;.class&quot;);</span><br><span class="line">            System.out.println((new File(&quot;hello&quot;)).getAbsolutePath());</span><br><span class="line">            out.write(data);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            if(null!=out) try &#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看一下这里代理对象的类型：</p><p><img alt data-src="/images/spring-jdk-aop/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B.png"><br>我们用jd-jui 工具将生成的字节码反编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line">import jiankunking.Subject;</span><br><span class="line"> </span><br><span class="line">public final class ProxySubject extends Proxy implements Subject &#123;</span><br><span class="line">  private static Method m1;</span><br><span class="line">  private static Method m3;</span><br><span class="line">  private static Method m4;</span><br><span class="line">  private static Method m2;</span><br><span class="line">  private static Method m0;</span><br><span class="line">  </span><br><span class="line">  public ProxySubject(InvocationHandler paramInvocationHandler) &#123;</span><br><span class="line">    super(paramInvocationHandler);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public final boolean equals(Object paramObject)&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return ((Boolean)this.h.invoke(this, m1, new Object[] &#123; paramObject &#125;)).booleanValue();</span><br><span class="line">    &#125; catch (Error|RuntimeException localError)&#123;</span><br><span class="line">        throw localError;</span><br><span class="line">    &#125; catch (Throwable localThrowable) &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public final String SayGoodBye() &#123;</span><br><span class="line">    try&#123;</span><br><span class="line">      return (String)this.h.invoke(this, m3, null);</span><br><span class="line">    &#125; catch (Error|RuntimeException localError) &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125; catch (Throwable localThrowable) &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public final String SayHello(String paramString) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      return (String)this.h.invoke(this, m4, new Object[] &#123; paramString &#125;);</span><br><span class="line">    &#125; catch (Error|RuntimeException localError)&#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125; catch (Throwable localThrowable)&#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public final String toString() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      return (String)this.h.invoke(this, m2, null);</span><br><span class="line">    &#125; catch (Error|RuntimeException localError) &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125; catch (Throwable localThrowable) &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public final int hashCode() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      return ((Integer)this.h.invoke(this, m0, null)).intValue();</span><br><span class="line">    &#125; catch (Error|RuntimeException localError) &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125; catch (Throwable localThrowable) &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  static</span><br><span class="line">  &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;);</span><br><span class="line">      m3 = Class.forName(&quot;jiankunking.Subject&quot;).getMethod(&quot;SayGoodBye&quot;, new Class[0]);</span><br><span class="line">      m4 = Class.forName(&quot;jiankunking.Subject&quot;).getMethod(&quot;SayHello&quot;, new Class[] &#123; Class.forName(&quot;java.lang.String&quot;) &#125;);</span><br><span class="line">      m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);</span><br><span class="line">      m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);</span><br><span class="line">      return;</span><br><span class="line">    &#125; catch (NoSuchMethodException localNoSuchMethodException) &#123;</span><br><span class="line">      throw new NoSuchMethodError(localNoSuchMethodException.getMessage());</span><br><span class="line">    &#125; catch (ClassNotFoundException localClassNotFoundException) &#123;</span><br><span class="line">      throw new NoClassDefFoundError(localClassNotFoundException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是最终真正的代理类，它继承自Proxy并实现了我们定义的Subject接口，也就是说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Subject subject = (Subject) Proxy.newProxyInstance(loader, interfaces, handler);</span><br></pre></td></tr></table></figure><p>这里的subject实际是这个类的一个实例，那么我们调用它的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final String SayHello(String paramString)</span><br></pre></td></tr></table></figure><p>就是调用我们定义的InvocationHandlerImpl的 invoke方法：</p><p><img alt data-src="/images/spring-jdk-aop/sayhello.png"></p><blockquote><p>上面是代码跟分析的过程，不想看的朋友可以直接看结论</p></blockquote><h1 id="五、结论"><a href="#五、结论" class="headerlink" title="五、结论"></a>五、结论</h1><p>到了这里，终于解答了：</p><p>subject.SayHello(“jiankunking”)这句话时，为什么会自动调用InvocationHandlerImpl的invoke方法？</p><p>因为JDK生成的最终真正的代理类，它继承自Proxy并实现了我们定义的Subject接口，在实现Subject接口方法的内部，通过反射调用了InvocationHandlerImpl的invoke方法。</p><p>通过分析代码可以看出Java 动态代理，具体有如下四步骤：</p><ol><li><p>通过实现 InvocationHandler 接口创建自己的调用处理器；</p></li><li><p>通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类；</p></li><li><p>通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；</p></li><li><p>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。</p></li></ol><p>演示代码下载：<br><a href="https://github.com/jiankunking/DynamicProxyDemo" target="_blank" rel="noopener">https://github.com/jiankunking/DynamicProxyDemo</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
            <tag> Spring </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
