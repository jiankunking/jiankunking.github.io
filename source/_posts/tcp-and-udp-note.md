---
layout: w
title: TCP与UDP 笔记
date: 2018-02-13 16:13:46
categories:
  - Network
tags:
  - Network
  - TCP
  - UDP
  - 读书笔记
---

本文整理自：《图解TCP/IP 第5版》 
作者：[日] 竹下隆史，[日] 村山公保，[日] 荒井透，[日] 苅田幸雄 著
译者：乌尼日其其格
出版时间：2013-07

<!-- more -->

![](/images/tcp-and-udp-note/网络分层.png)

# 传输层的作用
TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。

## 两种传输层协议TCP和UDP
### TCP
TCP是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管道中的水流。TCP为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。
### UDP
UDP是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。UDP情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。

## TCP与UDP区分
TCP用于在传输层有必要实现可靠性传输的情况。由于它是面向有连接并具备顺序控制、重发控制等机制的。所以它可以为应用提供可靠传输。

UDP主要用于那些对高速传输和实时性有较高要求的通信或广播通信。举一个IP电话进行通话的例子。如果使用TCP，数据在传送途中如果丢失会被重发，但是这样无法流畅地传输通话人的声音，会导致无法进行正常交流。而采用UDP，它不会进行重发处理。从而也就不会有声音大幅度延迟到达的问题。即使有部分数据丢失，也只是影响某一小部分的通话。此外，在多播与广播通信中也使用UDP而不是TCP。RIP、DHCP等基于广播的协议也要依赖于UDP。

# 端口号
## 端口号定义
<font color=DeepPink>**数据链路和IP中的地址，分别指的是MAC地址和IP地址。前者用来识别同一链路中不同的计算机，后者用来识别TCP/IP网络中互连的主机和路由器。传输层也有类似概念，就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址。**</font>

## 通过IP地址、端口号、协议号进行通信识别
<font color=DeepPink>**TCP/IP或UDP/IP通信中通常采用5个信息来识别一个通信。它们是“源IP地址”、“目标IP地址”、“协议号”、“源端口号”、“目标端口号”。**</font>只要其中某一项不同，则被认为是其他通信。

## 端口号与协议
<font color=DeepPink>**端口号由其使用的传输层协议决定。因此，不同的传输协议可以使用相同的端口号。**</font>例如，TCP与UDP使用同一个端口号，但使用目的各不相同。

数据到达IP层后，会先检查IP首部中的协议号，再传给相应协议的模块。传给TCP或UDP去做端口号处理。即使是同一个端口号，由于传输协议是各自独立地进行处理，因此相互之间不会影响。

# UDP
UDP是User Datagram Protocol的缩写，即用户数据包协议。

UDP不提供复杂控制机制，利用IP提供面向无连接的通信服务。且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。

UDP面向无连接，可以随时发送数据。它常用于几个方面：
* 包总量较少的通信（DNS、SNMP等）
* 视频、音频等多媒体通信（即时通信）
* 限定于LAN等特定网络中的应用通信
* 广播通信（广播、多播）

# TCP
TCP是Transmission Control Protocol的缩写，传输控制协议。

TCP充分实现了数据传输时各种控制功能，可以进行丢包的重发控制，还可以对次序乱掉的分包进行顺序控制。此外，TCP作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。

> 连接
连接是指各种设备、线路,或网络中进行通信的两个应用程序为了相互传递消息而专有的、虚拟的通信线路,也叫做虚拟电路。
一旦建立了连接,进行通信的应用程序只是用这个虚拟的通信线路发送和接收数据,就可以保障信息的传输。应用程序不用顾虑IP网络上可能发生的各种问题,依然可以转发数据。TCP则负责控制链接的建立、断开、保持等管理工作。
> ![](/images/tcp-and-udp-note/连接.png)

## TCP的特点及其目的
为了通过数据包实现可靠性传输,需要考虑很多事情,例如数据的破坏、丢包、重复记忆分片顺序混乱等问题。如不能解决这些问题,也就无从谈起可靠传输。

<font color=DeepPink>**TCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。**</font>

## 通过序列号与确认应答提高可靠性
在TCP中，当发送端数据到达接受主机时，接收端主机会返回一个已收到的消息的通知。这个消息叫做确认应答（ACK Positive Acknowledgement）。

TCP通过肯定的确认应答（ACK）实现可靠的数据传输。当发送端将数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。

在一定时间内没有等到确认应答，发送端就可以认为数据已经丢失，并进行重发。由此，即使产生了丢包，仍然能够保证数据能够到达对端，实现可靠传输。

未确认应答并不意味着数据一定丢失。也有可能是数据对方已经收到，只是返回的确认应答在途中丢失。

为了防止出现随意重发的情况，就需要引入一种机制，它能够识别是否已经接收数据，又能判断是否需要接收。

这些确认应答处理、重发控制以及重复控制等功能都可以通过序列号实现。<font color=DeepPink>**序列号是按照顺序给发送数据的每个字节（8位字节）都标上号码的编号（序列号的初始值并非为0。而是在建立连接以后由随机数生成。而后面的计算则是对每一字节加一）。接收端查询接收数据TCP首部中序列号和数据的长度，将自己下一步应该接收的序列号作为确认应答返送回去。这样，通过序列号和确认应答号，TCP可以实现可靠传输。**</font>

![](/images/tcp-and-udp-note/发送数据.png)

## 重发超时如何确定
重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔。如果超过了这个时间仍未收到确认应答，发送端将进行数据重发。那么这个重发超时的具体时间长度又是如何确定的呢？

最理想的是，找到一个最小时间，它能保证“确认应答一定能在这个时间内返回”。然而这个时间长短随着数据包途径的网络环境的不同而有所变化。例如在高速的LAN中时间相对较短，而在长距离的通信当中应该比LAN要长一些。即使是在同一个网络中，根据不同时段的网络堵塞程度时间的长短也会发生变化。TCP要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。为此，它在每次发包时都会计算往返时间及其偏差。将这个往返时间和偏差相加重发超时的时间，就是比这个总和要稍大一点的值。

![](/images/tcp-and-udp-note/往返时间的计算与重发超时的时间推移.png)

在BSD的Unix以及Windows系统中，超时都以0.5秒为单位进行控制，因此重发超时都是0.5秒的整数倍。不过，由于最初的数据包还不知道往返时间，所以其重发超时一般设置为6秒左右。数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。此外，数据也不会被无限、反复地重发。达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接。并且通知应用通信异常强行终止。

## 连接管理
TCP提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好通信两端之间的准备工作。

UDP是一种面向无连接的通信协议，因此不检查对端是否可以通信，直接将UDP包发出去。TCP与此相反，它会在数据通信之前，通过TCP首部发送一个SYN包作为建立连接的请求等待确认应答（<font color=DeepPink>**TCP中发送第一个SYN包的一方叫客户端，接收这个的一方叫服务端**</font>）。如果对端发来确认应答，则认为可以进行数据通信。如果对端的确认应答未能到达，就不会进行数据通信。此外，在通信结束时会进行断开连接的处理（FIN包）。

可以使用TCP首部用于控制的字段来管理TCP连接（也叫控制域）。一个连接的建立与断开，正常过程至少需要来回发送7个包才能完成。（建立一个TCP连接需要发送3个包，这个过程也称为3次握手）

![](/images/tcp-and-udp-note/TCP连接的建立与断开.png)

## TCP以段为单位发送数据
<font color=DeepPink>**在建立TCP连接的同时，也可以确定发送数据包的单位，我们也可以称其为“最大消息长度”（MSS：Maximum Segment Size）。**</font> 最理想的情况是，最大消息长度正好是IP中不会被分片处理的最大数据长度。

TCP在传输大量数据时，是以MSS的大小将数据进行分割发送的。进行重发时也是以MSS为单位。

MSS是在三次握手的时候，在两端主机之间被计算得出。<font color=DeepPink>**两端的主机在发出建立连接的请求时，会在TCP首部中写入MSS选项，告诉对方自己的接口能够适应的MSS的大小（为附加MSS选项，TCP首部将不再是20字节，而是4字节的整数倍）。然后会在两者之间选择一个较小的值投入使用。**</font>

![](/images/tcp-and-udp-note/接入以太网主机与接入FDDI主机之间通信的情况.png)

> SYN(synchronous建立联机) ACK(acknowledgement 确认) FIN(finish结束) 

## 利用窗口控制提高速度
TCP以1个段为单位，每发一个段进行一次确认应答的处理，如下图，这样传输的缺点是，包的往返时间越长通信性能就越低。

![](/images/tcp-and-udp-note/按数据包进行确认应答.png)

为解决这个问题，TCP引入了窗口这个概念。如下图，确认应答不再是以每个分段，而是以更大的单位进行确认时，转发时间将会被大幅度的缩短。就是说，发送端主机，在发送了一个段以后不必要一直等待确认应答，而是继续发送。

<font color=DeepPink>**窗口大小就是指无需等待确认应答而可以继续发送数据的最大值。**</font> 如下图中，窗口大小为4个段。

这个机制实现了使用大量的缓冲区（Buffer 在此处标识临时保存收发数据的场所。通常是在计算机内存中开辟的一部分空间），通过对多个段同时进行确认应答的功能。

用滑动窗口方式并行处理：

![](/images/tcp-and-udp-note/用滑动窗口方式并行处理.png)

下面的图中发送数据中高亮圈起的部分正是前面所提到的窗口。在这个窗口内的数据即便没有收到确认应答也可以发送出去。此外，<font color=DeepPink>**从该窗口中能看到的数据因其某种数据已在传输中丢失，所以发送端才能收到确认应答，这种情况也需要重发。为此，发送端主机在等到确认应答返回之前，必须在缓冲区中保留这部分数据。**</font>

在滑动窗口以外的部分包括尚未发送的数据以及已经确认对端已收到的数据。当数据发出后若如期收到确认应答就可以不用再重发，此时数据皆可以从缓冲区清除。

<font color=DeepPink>**收到确认应答，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也被称为滑动窗口控制。**</font>

滑动窗口方式：

![](/images/tcp-and-udp-note/滑动窗口方式.png)

## 窗口控制与重发控制
使用窗口控制中， 如果出现段丢失怎么办？

首先考虑确认应答未能返回的情况。这种情况下，数据已经达到对端，是不需要进行重发的。然而，在没有使用窗口控制的时候，没有收到确认应答的数据会被重发。而使用了窗口控制，如下图，某些确认应答即便丢失也无需重发。

![](/images/tcp-and-udp-note/没有确认应答也不受影响.png)

其次，考虑一下某个报文段丢失的情况。如下图，接收主机如果收到一个自己应该接收的序号以外的数据时，会针对当前位置收到数据返回确认应答（不过<font color=DeepPink>**即使接收端主机收到的包序号并不连续，也不会将数据丢弃而是暂时保存至缓冲区中**</font>）。

当某一报文段丢失后，发送端会一直收到序号为1001的确认应答，这个确认应答好像在提醒发送端“我想接收的是从1001开始的数据”。因此，在窗口比较大，又出现报文段丢失的情况下，同一个序号的确认应答将会被重复不断地返回。而发送端主机如果连续3次收到同一个确认应答（之所以连续收到3次而不是两次的理由是因为，即使数据段的序号被替换两次也不会触发重发机制）。就会将其所对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称作高速重发控制。

![](/images/tcp-and-udp-note/高速重发控制.png)

## 流控制

发送端根据自己的实际情况发送数据。但是，接收端可能收到的是一个毫无关系的数据包有可能会在处理其他问题上花费一些时间。因此在为这个数据包做其他处理时会耗费一些时间，甚至在高负荷情况下无法接收任何数据。如此一来，如果接收端将本应该接收的数据丢弃的话，就又会触发重发机制，从而导致网络流量的浪费。

为了防止这种现象发生，<font color=DeepPink>**TCP提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量。这就是所谓的流控制。它的具体操作时，接收端主机向发送端主机通知自己可以接收数据的大小，于是发送端会发送不超过这个限制的数据。该大小限度就被称为窗口大小。**</font>

<font color=DeepPink>**TCP首部中，专门有一个字段用来通知窗口大小。接收主机将自己的可以接收的缓冲区大小放入这个字段通知给发送端。这个值越大，说明网络的吞吐量越高。**</font>

<font color=DeepPink>**不过，接收端这个缓冲区一旦面临数据溢出时，窗口大小的值也会随之被设置为一个更小的值通知给发送端，从而控制数据发送量。就是说，发送端主机会根据接收端主机的指示，对发送数据的量进行控制。这也形成了一个完整的TCP流控制（流量控制）。**</font>

根据窗口大小控制流量过程示例：

![](/images/tcp-and-udp-note/流控制.png)

当接收端收到从3001号开始的数据段后其缓冲区即满，不得不暂时停止接收数据。之后，在收到发送窗口更新通知后通信才得以继续进行。如果这个窗口更新通知在传输途中丢失，可能会导致无法继续通信。为避免此类问题，发送端主机会时不时发送一个叫做窗口探测的数据段，此数据段仅含一个字节以获取最新的窗口大小信息。

## 拥塞控制

有了TCP窗口控制，收发主机之间即使不再以一个数据段为单位发送确认应答，也能够连续发送大量数据包。然而，如果在通信刚开始就发送大量数据，也可能会引发其他问题。

TCP为了防止该问题的出现，在通信一开始就会通过一个叫做慢启动的算法得出的数值，对发送数据量进行控制。

<font color=DeepPink>**首先，为了在发送端调节所要发送数据的量，定义了一个叫做“拥塞窗口”的概念。于是在慢启动的时候，将这个拥塞窗口的大小设置为1个数据段（1MSS）发送数据，之后每收到一次确认应答（ACK），拥塞窗口的值就加1。在发送数据包时，将拥塞窗口的大小与接收端主机通知的窗口大小做比较，然后按照它们当中较小的那个值，发送比其还要小的数据量。**</font>

![](/images/tcp-and-udp-note/慢启动.png)

如果重发采用超时机制,那么拥塞窗口的初始值可以设置为1以后再进行慢启动修正。有了上述这些机制,就可以有限的减少通信开始时连续发包导致的网络拥堵,还可以避免网络拥塞情况的发生。

不过,随着包的每次往返,拥塞窗口也会以1、2、4等指数函数的增长,拥堵状况激增甚至导致网络拥塞的发生。为了防止这些,引入了慢启动阀值的概念。只要拥塞窗口的值超出这个阀值,在每收到一次确认应答时,只允许以下面这种比例方法拥塞窗口:

![](/images/tcp-and-udp-note/拥塞调整公式.png)

![](/images/tcp-and-udp-note/TCP的窗口变化.png)

拥塞窗口越大，确认应答的数目也会增加，不过随着每收到一个确认应答，其涨幅也会逐渐减少，甚至小过比一个数据段还要小的字节数。所以，拥塞窗口的大小会呈直线上升的趋势。

TCP通信开始时，并没有设置相应的慢启动阈值（与窗口的最大值相同)，而是在超时重发时才会设置为当时拥塞窗口一半的大小。

由重发确认应答而触发的高速重发与超时重发机制的处理多少有些不同。因为前者要求至少3次的确认应答数据段到达对方主机后才会触发，相比后者网络的拥堵要轻一些。

而由重复确认应答进行高速重发控制时，慢启动阈值的大小被设置为当时窗口大小的一半（严格来说，是设置为“实际已发送但未收到确认应答的数据量”的一半）。然后将窗口的大小设置为该慢启动阈值+3个数据段的大小。

有了这样一种控制，TCP的拥塞窗口如上图所示发生变化。由于窗口的大小会直接影响数据被转发的吞吐量，所以一般情况下，窗口越大，越会形成高吞吐量的通信。

当TCP通信开始以后,网络吞吐量会逐渐上升,但是随着网络拥堵的发生吞吐量也会急剧下降。于是会再次进入吞吐量慢慢上升的过程。因此所谓TCP的吞吐量的特点就好像是在逐步占领网络带宽的感觉。

# UDP首部的格式
下图展示了UDP首部的格式。除去数据的部分正式UDP的首部。UDP首部由源端口号，目标端口号，包长和校验和组成。

![](/images/tcp-and-udp-note/UDP数据报格式.png)

## 源端口号（Source Port）
表示发送端端口号，字段长16位。该字段是可选项，有时可能不会设置源端口号。没有源端口号的时候该字段的值设置为0。可用于不需要返回的通信中。

## 目标端口号（Destination Port）
表示接收端端口，字段长度16位。

## 包长度（Length）
该字段保存了UDP首部的长度跟数据的长度之和。单位为字节（8位字节）。

## 校验和（Checksum）
校验和是为了提供可靠的UDP首部和数据而设计。在计算校验和时，附加在UDP伪首部与UDP数据报之前。通过在最后一位增加一个“0”将全长增加16倍。此时将UDP首部的校验和字段设置为“0”。然后以16比特为单位进行1的补码和，并将所得到的1的补码和写入校验和字段。

![](/images/tcp-and-udp-note/校验和计算中使用的UDP伪首部.png)

接收主机在收到UDP数据报以后，从IP首部获知IP地址信息构造UDP伪首部，再进行校验和计算。校验和制度按的值是校验和字段以外余下部分的1的补码和。因此，包括校验和字段在内的所有数据之和结果为“16位全部为1”时，才会被认为所收到的数据时正确的。

另外，UDP也可有可能不用校验和。此时，校验和字段中填入0。这种情况下，由于不进行校验和计算，协议处理的开销（在处理实际数据之外，为了进行通信控制的处理而不得不付出的必要的消耗部分）就会降低，从而提高数据转发的速度。然而，如果UDP首部的端口号或是IP首部的IP地址遇到损坏，那么可能会对其他通信造成不好的影响。因此，在互联网中比较推荐使用校验和检查。

>校验和计算中计算UDP伪首部的理由
TCP/IP中识别一个通信的应用需要5大要素，它们分别是“源IP地址”、“目标IP地址”、“源端口”、“目标端口”、“协议号”。然而，在UDP的首部中只包含它们当中的两项（源端口和目标端口），余下的3项都包含在IP首部里。
假定其他3项都被破坏？显然，这极有可能会导致应该收包的应用收不到包，不该收到包的应用却收到了包。
为了避免这类问题，有必要验证一个通信中必要的5项识别码是否正确。为此，在校验和的计算中就引入和伪首部的概念。
此外，IPv6中的IP首部没有检验和字段。TCP和UDP通过伪首部，得以对5项数字进行校验，从而实现即使在IP首部并不可靠的情况下仍然能够提供可靠的通信传输。

# TCP首部格式
![](/images/tcp-and-udp-note/TCP数据段格式.png)

TCP中没有表示包长度和数据长度的字段。可由IP层获知TCP的包长，由TCO的包长可知数据的长度。

## 源端口号（Source Port）
表示发送端端口号，字段长16位。

## 目标端口号（Destination Port）
表示接收端端口号，字段长度16位。

## 序列号（Sequence Number）
字段长32位。序列号（序号）是指发送数据的位置，每发送一次数据，就累加一次该数据字节数的大小。

<font color=DeepPink>**序列号不会从0或1开始，而是建立连接时由计算机生成的随机数作为其初始值，通过SYN包传给接收端主机。**</font>然后再将每转发过去的字节数累加到初始值上表示数据的位置。此外，在建立连接和断开连接时发送的SYN包和FIN包虽然并不携带数据，但是也会作为一个字节增加对应的序列号。

## 确认应答号（Acknowledgement Number）
确认应答号字段长度32位。是指下一次应该受到的数据的序列号。实际上，它是指已收到确认应答号减一为止的数据。发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。

## 数据偏移（Data Offset）
该字段表示TCP所传输的数据部分应该从TCP包的哪个位开始计算，当然也可以把它看做TCP首部的长度。该字段长4位，单位为4字节（即32位）。

## 保留（Reserved）
该字段主要是为了以后扩展时使用，其长度为4位。一般设置为0，但即使收到的包在该字段不为0，此包也不会被丢弃。

## 控制位（Control Flag）
字段长为8位，每一位从左至右分别为CWR、ECE、URG、ACK、PSH、RST、SYN、FIN。这些控制标志也叫作控制位。

![](/images/tcp-and-udp-note/控制位.png)

### CWR（Congestion Window Reduced）
CWR标志与后面的ECE标志都用于IP首部的ECN字段。ECE标志为1时，则通知对方已将拥塞窗口缩小。
### ECE（ECN-Echo）
ECE标志表示ECN-Echo。置为1会通知通信对方，从对方到这边的网络有拥塞。在收到数据包的IP首部中ECN为1时将TCP首部中的ECE设置为1。
### URG（Urgent Flag）
该位为1时，确认应答的字段变为有效。TCP规定除了最初建立连接时的SYN包之外该位必须设置为1。
### PSH（Push Flag）
该位为1时，表示需要将受到的数据立即传给上层应用协议。PSH为0时，则不需要立即传而是先进性缓存。
### RST（Reset Flag）
该位为1时表示TCP连接中出现异常必须强制断开连接。
### SYN（Synchronize Flag）
用于建立连接。SYN为1 表示希望建立连接，并在其序列号的字段进行序列号初始值的设定。
### FIN（Fin Flag）
该位为1时，表示今后不会再有数据发送，希望断开连接。
窗口大小（Window Size）

## 窗口大小（Window Size）
该字段长为16位。用于通知从相同TCP首部的确认应答号所指位置开始能够接收的数据大小（8位字节）。TCP不允许发送超过此处所示大小的数据。不过，如果窗口为0，则表示可以发送窗口探测，以了解最新的窗口大小。但这个数据必须是1个字节。

## 校验和（Checksum）
TCP的校验和与UDP相似，区别在于TCP的校验和无法关闭。
TCP和UDP一样在计算校验和的时候使用TCP伪首部。

接收端在收到TCP数据段以后，从IP首部获取IP地址信息构造TCP伪首部，再进行校验和计算。由于校验和字段里保存着除本字段以外洽谈部分的和的补码值，一次如果计算校验和字段在内的所有数据的16位和以后，得出的结果是“16位全部为1”说明所收到数据是正确的。

## 紧急指针（Urgent Pointer）
略
## 选项（Options）
略




